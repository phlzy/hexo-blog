{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/butterfly-icon.png","path":"img/butterfly-icon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/error-page.png","path":"img/error-page.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/ANT_1.md","hash":"802957835340d9c5c5b387859bb2e19fee852af5","modified":1683514375236},{"_id":"source/_posts/AVL_Tree.md","hash":"7eebbb50d1ba80c1749c84e0fd53dd88967094d2","modified":1677303971826},{"_id":"source/_posts/GYM104081.md","hash":"fd3c10b4bf21a7ba724c1f9b8d7b19a58ae62dc5","modified":1683085320575},{"_id":"source/_posts/KM.md","hash":"168d31f17f9353058e1db870a8c4b4313b54dcb5","modified":1677303971826},{"_id":"source/_posts/HRBUST2022.md","hash":"41b83907f311191f850bf22dab6567180c3a1119","modified":1677303971827},{"_id":"source/_posts/CO1.md","hash":"1c6b7c5f8eef33559386126733c4e90bcfb1c36f","modified":1764834824953},{"_id":"source/_posts/LA0.md","hash":"a029703d6b7f281fecb0f55a7b72b4d40aea0032","modified":1677303971829},{"_id":"source/_posts/JSCPC2021.md","hash":"bb752116479fc86b09bb468c8270a1274892c618","modified":1682770835149},{"_id":"source/_posts/LA1.md","hash":"70a88590110c184f2b8e23c06f3d7a313e174c04","modified":1677303971829},{"_id":"source/_posts/Manacher.md","hash":"6f0b7db4ee7a52f16884b236d97fda51b717c923","modified":1677303971839},{"_id":"source/_posts/LA2.md","hash":"f845afed46313e8cff8113eb7406acc0f3ed1043","modified":1677303971829},{"_id":"source/_posts/_POST_TEMPLATE_.MD","hash":"1f61b521bc3f286857a2c0e19dcd14475e2ba19a","modified":1764833399514},{"_id":"source/_posts/frac_programming.md","hash":"34adeacf105a036adeb7d319cfc32f5759170494","modified":1680793460169},{"_id":"source/_posts/gf_0.md","hash":"241eb195eec24bd520282b5590b4242e567d6c88","modified":1682845738927},{"_id":"source/_posts/ubuntu_config.md","hash":"cdd964f4589effda05ce7349530578d9a9c83908","modified":1677303971840},{"_id":"source/categories/index.md","hash":"25e95f997048a82b7882048bc4dee764b9cb0066","modified":1764830705896},{"_id":"source/_posts/writing_blog_on_multiple_PC.md","hash":"23de2f66ef50ccb90e64a5b96ba1efac305f34c1","modified":1764833476330},{"_id":"source/tags/index.md","hash":"19e67d64af5d7efc7f8d1fcecd531f9249c77d47","modified":1764830675057},{"_id":"themes/butterfly/.gitignore","hash":"1e843a7254515d97ddb1d1d32ae83ebfae937f54","modified":1764826507703},{"_id":"themes/butterfly/README.md","hash":"4ff8ff47a38674ac55270b844171d7a0a6b52afd","modified":1764826507704},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1764826507703},{"_id":"themes/butterfly/_config.yml","hash":"67078bc79cf051430112fee16d91b44e71544fe2","modified":1764835244067},{"_id":"themes/butterfly/package.json","hash":"75c968e9986f4572c4eb36d299b8e33121709cf8","modified":1764826507741},{"_id":"themes/butterfly/README_CN.md","hash":"5595df16d0b28133a232cb5f45bbcf60798073e9","modified":1764826507704},{"_id":"themes/butterfly/.github/FUNDING.yml","hash":"859c2448942ab4fcf4a2fbdeff52dac8e68a9e96","modified":1764826507701},{"_id":"themes/butterfly/languages/default.yml","hash":"97e89708bea9740e7e156b53304d7f4697f6332d","modified":1764826507705},{"_id":"themes/butterfly/languages/en.yml","hash":"6d2a5795862abc121a164e8519e7587bb57af7c7","modified":1764826507706},{"_id":"themes/butterfly/languages/ja.yml","hash":"d97b97ebb8a1c8754373b450d4e81341b5dcd208","modified":1764826507706},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"25e717994a3eab37ccb9cf3ae5fec5647b525ced","modified":1764826507707},{"_id":"themes/butterfly/languages/zh-HK.yml","hash":"e2958e5b72fd2cb33b6706bc1588de6b8d9dde8f","modified":1764826507707},{"_id":"themes/butterfly/plugins.yml","hash":"3dec580c9198ca28bc931d2d627abfb19ac070db","modified":1764826507742},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"af38319aa58cab193f90ef8caecdb9a26cdd165a","modified":1764826507707},{"_id":"themes/butterfly/languages/ko.yml","hash":"4a959730509b211484b20d9fcabc80a9c7e8cc1f","modified":1764826507706},{"_id":"themes/butterfly/layout/archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1764826507707},{"_id":"themes/butterfly/layout/category.pug","hash":"a7e9805a781e34e38d27462e6ce2a5821c34bb9f","modified":1764826507707},{"_id":"themes/butterfly/layout/page.pug","hash":"7ce2a49c6c41847de4ccea377ade116339984434","modified":1764826507740},{"_id":"themes/butterfly/layout/index.pug","hash":"a93004cc8ec8050df603d32a6e6e02cd96fd9875","modified":1764826507740},{"_id":"themes/butterfly/layout/post.pug","hash":"65c4a49c65c3fc4d9dc88b9791a75710c698c3a1","modified":1764826507741},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"10ce05c8dbde09f53bdabe40b5388de9ccc71a31","modified":1764826507702},{"_id":"themes/butterfly/layout/tag.pug","hash":"ca5333bd262cb58c195c844b593a0eed0c721766","modified":1764826507741},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"63ad2249ad09fb3fe21bd5ff9adefb304a7ab24a","modified":1764826507702},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1764826507702},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1764826507703},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1764826507703},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"c3c38591f7c97a3dac7771e1316310ca9a98487c","modified":1764826507708},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"da95d64f44e1e6b516d1f96f57b4b0a537c29c19","modified":1764826507708},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"1d11e334b22dbbedcb0f751f9ee9789d4416605e","modified":1764826507708},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"062137cb4d078b27680da1ae28d524a9c963eebc","modified":1764826507717},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"e5e6c05a621483b3542f2884e8ba45e84b1e973a","modified":1764826507712},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"3617840416f26078117f760579fb544dce07e1bc","modified":1764826507717},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"3e65b7bf6bccccbba7e15349f0a44f15c64c5b5e","modified":1764826507717},{"_id":"themes/butterfly/scripts/common/default_config.js","hash":"de1c2234f960445507b5b4cc4e60a0048dcdbc22","modified":1764826507742},{"_id":"themes/butterfly/scripts/events/404.js","hash":"039fc75f363d79669b0b2177d929cdff6f2ef7a4","modified":1764826507743},{"_id":"themes/butterfly/scripts/common/postDesc.js","hash":"ba98361b9d469076bfb045e5ff42eaf764a38fb1","modified":1764826507743},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1764826507743},{"_id":"themes/butterfly/scripts/events/init.js","hash":"350bd58ac7d53c133981c76aae034b50bf6b24fe","modified":1764826507744},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"bac639c404588ea62e601ef0bcd368c3bd0119af","modified":1764826507744},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1764826507744},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"f96ccb349501dd2a268f1b64861600e3dc15e4e8","modified":1764826507744},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"20a6ebf63439501a4b3fc81e7a2a2ea5d103bace","modified":1764826507745},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"fcf14a7a2cd409f63d66a3c3421911ef3ce327bc","modified":1764826507746},{"_id":"themes/butterfly/scripts/helpers/getArchiveLength.js","hash":"bf77635e920eaf52bceebc95f87c7c87a7ca8038","modified":1764826507746},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"0cdf781a8c14d7b50d309e69f282ec7b178804bb","modified":1764826507746},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"25f7a5ce29fdab3b71a78788416e19276b6e2ac7","modified":1764826507747},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"f94370706fe2c8b0597a81afe2f3e9c29e919d83","modified":1764826507747},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"950b7d0966429bf0f9e6c5e1161e50e545e320b4","modified":1764826507747},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"45367c4ce827329867dbcc750ec125da9ccb2cfd","modified":1764826507748},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"2f44e1b3ccd170b256eae178299d6fa933a8d490","modified":1764826507748},{"_id":"themes/butterfly/scripts/tag/chartjs.js","hash":"195ba802d7e8406c155124a9c939a2318f82938b","modified":1764826507748},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"25eefe10189caf3910a0e5d5b2f2043ae9255531","modified":1764826507749},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"fa3d0a64f7fce4aff7928d4ddd95548978ba001c","modified":1764826507749},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"89c6c78d2db43b190055d5690741a79bab4f3e7e","modified":1764826507750},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"cf0bc17d0180231167cc6aa8a00fc64f198cb9f9","modified":1764826507750},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"1ebe936e202c1baee8f6b7862a431e43db807229","modified":1764826507749},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"795b83d4664101a762222c80f01def86331b102e","modified":1764826507750},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1764826507751},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"40bc9a065e3a1423e0e66f4911e00713ca9f5e9e","modified":1764826507751},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"176804f07567aa80f1ed95897a968a996b155dec","modified":1764826507752},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"f2f8a789967cda9559778b1936233dfb46a1f3a3","modified":1764826507751},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"3c486b149e28edd1a06843f05a5c355000991b82","modified":1764826507751},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1764826507768},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1764826507767},{"_id":"themes/butterfly/source/css/var.styl","hash":"41e5eb8c62fdf6ba12c98d026d6f26f08a4380e2","modified":1764826507767},{"_id":"themes/butterfly/source/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1764826507770},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1764826507771},{"_id":"themes/butterfly/source/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1764826507770},{"_id":"themes/butterfly/source/js/utils.js","hash":"f32e69a6e624ab224729b446f096da96ec263934","modified":1764826507773},{"_id":"themes/butterfly/source/js/main.js","hash":"76c9e76f7e10971f7bf604c1d98c4512bff43a2e","modified":1764826507771},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"0561cc5c3d252d9b9b0d04a553028e9450965b6b","modified":1764826507772},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"e93a36d3c29b5a02c7f26a23f96e1f84b063cbe8","modified":1764826507709},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"f1d3552f7cebe1e9e89804b0c0fed47d3f6969ca","modified":1764826507709},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c2156c77a011b20fafd34f03ca073397c21b099f","modified":1764826507709},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"56a3c32de1a15627ff38c67f1131cdd6ec5ac924","modified":1764826507709},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1764826507710},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"1e1a69aa2cbda2e621c741b3802093244b3cc04e","modified":1764826507710},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"83ed05ef1e39f2ee70c3fba2cf96e488d8ffec66","modified":1764826507710},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1764826507711},{"_id":"themes/butterfly/layout/includes/head/structured_data.pug","hash":"49db40e9d3edcf6323e6fe7c074ab09e41453c82","modified":1764826507711},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"44331c9db74b281b5c5c41439d3407a9076df1a1","modified":1764826507711},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f478a82ba4c15d4f6a5db38eca5c61f7054fa71d","modified":1764826507712},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"733184f88e3a586a5fcc9d193ad500556b6c8eed","modified":1764826507711},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"7d799c4694adb6e265e3f4b975d7f7f6a7021a17","modified":1764826507712},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"ef7afe0df7a3746744ac8185da7163b7406120ca","modified":1764826507714},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"e2d31e0f450ad42c47f7ee96375799342bf2f19b","modified":1764826507712},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"d4d266eced4b9167bed86bcc5addc327f78cbdcc","modified":1764826507713},{"_id":"themes/butterfly/layout/includes/mixins/indexPostUI.pug","hash":"f3389fa9ae4fa32e3c16573286583bc3023e57ad","modified":1764826507715},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"d76ce71ba106e350670c021a3dcae57547d01830","modified":1764826507713},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"9d2d539555bab495959b9df734ed5c43a9f9e5a9","modified":1764826507714},{"_id":"themes/butterfly/layout/includes/page/404.pug","hash":"15d32c511e4875066fcbe9cb84c3ada07b5a7c41","modified":1764826507715},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"efb40388e37cca0b5e7c3c66e811a42f8d32c910","modified":1764826507716},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1764826507715},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"6b0fa5f048aca8e9cbe56978301af918cf7ac34a","modified":1764826507716},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"79ad31eb72a9e14007770b18a426406a25315b38","modified":1764826507716},{"_id":"themes/butterfly/layout/includes/page/shuoshuo.pug","hash":"2cc8f09b56ade6c581398d977fe38c1ecd9ed024","modified":1764826507716},{"_id":"themes/butterfly/layout/includes/post/outdate-notice.pug","hash":"b7ce9484bc5c97ea6154f0b78fb9b8951fafedbd","modified":1764826507717},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"b96c232e5178d927987791d9ae386dd83679535a","modified":1764826507717},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"db92f25ff3fd061882f81bf74ca560ff66983a0c","modified":1764826507717},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"ed79fef5b5025415ea12eaed970f3fe7f6ef9596","modified":1764826507719},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"43014bfc63583d3ee8808d526dd165848c0ed52f","modified":1764826507727},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"88f979a0b1a19eeb0db229247833bf9c6865c3b9","modified":1764826507733},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"dc2d36c6ccf5ad1b5f115c443772764f58a87fd6","modified":1764826507733},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"236c3ce26dd76e80b04d457789475c42da5ac0c8","modified":1764826507736},{"_id":"themes/butterfly/layout/includes/third-party/umami_analytics.pug","hash":"c912959307b5e968df9b96fdef560ba8f3da19c5","modified":1764826507736},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1764826507737},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1764826507737},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1764826507737},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1764826507738},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"1aba8aa7cd767dc96879d13a13b4c8ceb9023233","modified":1764826507737},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"d8753772889b5d0f4d15639ed6af5e91e53b1d03","modified":1764826507738},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1764826507738},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"e0bb72fa0ce15964b11b8fe421cae3432394e35f","modified":1764826507739},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"1dd19a564320d248dbcee7f118a5b96c6466da65","modified":1764826507739},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1764826507739},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"f7e69cb0cb8dfe9445a15854604a6f9189338615","modified":1764826507739},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1764826507739},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"fcddd80cdeb6aa81f342cd9f0102302f6ba087a8","modified":1764826507740},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"45f620cd87b9ef2aa9d1e024e697ed6b4eecff34","modified":1764826507740},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"9426ab6c6fe84a76582dcb4e7762385c7c0a47f4","modified":1764826507753},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"dce34eea0be6e45dc719c63ae340d8803be468d0","modified":1764826507753},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"9a7d1427cdf2f9fb7031eafcc651f63ac3eac7b0","modified":1764826507752},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"a51edfd3e499e7d38c32241c40e8e4d371efca73","modified":1764826507755},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"1cb1c5fcdefc55aab674d7d84d057151f8f76577","modified":1764826507755},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"4cc02bcbaa4a1933a82a9ea57a603fe2d059fc77","modified":1764826507755},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"fbfce4d67cacd1df22fb73d89d008693f59d9d91","modified":1764826507756},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"7536c44e78115559a996d0384adec38b78d8dc25","modified":1764826507757},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1764826507757},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"7d7554573c005399bc8c2264a85896d2d51be1e1","modified":1764826507757},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"5692bcf8929f7ef12b10d860da6cb90ca55752c0","modified":1764826507756},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"ef8e8549fe7ad4b99793844a93b4a89f77f417d5","modified":1764826507758},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"543eaf9c7df7e0db841e5946ee5f9082c3c46290","modified":1764826507757},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"dcf24780ec6f1a3bf4a277d79d6287b9e65dbbe4","modified":1764826507758},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"d4e8a938ef2a1f4bf895d187e4fa529c7476e238","modified":1764826507758},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"0af7c8754f04bdd9a02a14d880774753bd2e35ee","modified":1764826507758},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"e22bc88ab369c362905b29514d585b1d6bbfc5f3","modified":1764826507758},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"ad66212554468b7067590308ed4cf40524fea662","modified":1764826507759},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"205ccc7d0ec6ce1193b46bc0c9ce0385594581fb","modified":1764826507759},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"446cb0cebe2e4d0bbf055a57caaed0125f4b78e7","modified":1764826507759},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5abe5480d83ff8b452a780a484d50a44091475bf","modified":1764826507760},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"c4cda7b0c99015df29ce00fdfddd2f7679653754","modified":1764826507760},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"1f8d715faf3b91b53426e38195c0920afb3bfa1c","modified":1764826507760},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"1a1766f8ea6a6576ec6129887e55221f540b9358","modified":1764826507760},{"_id":"themes/butterfly/source/css/_page/shuoshuo.styl","hash":"a764c44ce1f17f966b2f439762f038570af00b1b","modified":1764826507761},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"fc26e980fedde31644ebf878967f66ef9ba32be2","modified":1764826507761},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"4681a9d93a20b8de9f58cdbc794702f76f35192b","modified":1764826507761},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"f6d0cfb510a0e351ec20b043d3d3784d0f6c96a4","modified":1764826507762},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"5a8a181324a2f6b7d8240ea871971444403fa554","modified":1764826507762},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"d33d4af89231f4b0f1300bf2e9725344b4fab969","modified":1764826507762},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"f3fd3c43f16606a7b956fcb94b0d975b2d705fff","modified":1764826507763},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"30d1f809efd252ed0233d96d4374efd2b01d2292","modified":1764826507763},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1764826507763},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"77cdcf374761800e638d7d39205a0becb1052011","modified":1764826507763},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"3be8d0a75e7cc96548667cae0cb6a474279bd0b5","modified":1764826507764},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"db2e94a2dd24a2777c9a74b35f98c11d71488003","modified":1764826507764},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"e84f1de06b818557cc4c45f9958121952ae268b8","modified":1764826507764},{"_id":"themes/butterfly/source/css/_tags/series.styl","hash":"0657169849bc4bf4d93b5492ade040c8f58c1901","modified":1764826507765},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"3a88eedcb694da79e92581ce50cb1a430b1fb615","modified":1764826507765},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"e846ddaef494d46cdfa2379deacfe74fa1cc5264","modified":1764826507766},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1764826507767},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"13f37791badfb942f639cc25092ee32d43de31bf","modified":1764826507772},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"4adfe4087d8350a1188135a32a3bf76c6b305787","modified":1764826507772},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"7df4d27cf9e576c6b9c1e4f76a100a41749ca8bb","modified":1764826507719},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f0a90d8e39915a74b16ef22e851f179415cd7eaa","modified":1764826507719},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"cbfbcf34a24d21ba2b21cf9eedb76f4c3c563c5a","modified":1764826507720},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"b03ee8625149191f9d5d057bbc9824b68d8dd0c4","modified":1764826507720},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1764826507720},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1764826507720},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"be45b522286bbc64724341f23a5056ad24d3f796","modified":1764826507721},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1764826507721},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"7884883ec15792f7e54daacb3c62b851dde2b66a","modified":1764826507721},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"5b29badecbbe828112c001156023fc0566045cf6","modified":1764826507722},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1764826507722},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"24d094fd917947c0ca7492fa094328b1a183b873","modified":1764826507722},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"e8438941085def0591a72fc9b0d705dbf107f54f","modified":1764826507723},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"62466b251052cae609b6369d4cb4b6a85320757d","modified":1764826507723},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"9801f581cd1d2aaa3eed8739487b9b3ec395c354","modified":1764826507723},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f2ea5249b3e6670f6c8c77868f4f42c502e43830","modified":1764826507724},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"c81fa7d8a5cb96d1ae07bfa8c46b84a58161add1","modified":1764826507724},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"58914c58a190e3bc0aa37cb581e77e442b563501","modified":1764826507725},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"8af585e6d6f73ee57114eefad574dc6e8ea9f570","modified":1764826507724},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"332b532bafbaf369fde840883b77e5a23d050a39","modified":1764826507725},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"592b2251db6c1abeb8b0eebe3b2e6d9aa0dec445","modified":1764826507724},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1764826507725},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"9d84a681289175dec75a85f301d2fc9ce1b2bb7a","modified":1764826507726},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"53d99831f29aeb2e336ed1407d79590041f77002","modified":1764826507726},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"30a7d157890de69deab28baa47fb7bb28b040efd","modified":1764826507726},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"ea9766439b6b1936306916a8b08d2681afbc8ea9","modified":1764826507726},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"24f18b0c67803210d53abbf9c1d454c000b06eee","modified":1764826507727},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"e2bf15357485cd502414b3b20f5b1f762a2fd014","modified":1764826507727},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"af66d13204030d47537b9e31a6173e63589ce7ff","modified":1764826507729},{"_id":"themes/butterfly/layout/includes/third-party/math/chartjs.pug","hash":"732eb1118ea1a73aa5c164d639097c614f8e9953","modified":1764826507728},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"b83db9fa64d42a0bfd97efb660e09be3f166a144","modified":1764826507729},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"cb5c8b0f2ac19a732ab78e26020dd5c8c70c0642","modified":1764826507729},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"05c9c4705670497454bf9bd3ff6954c4fced158c","modified":1764826507730},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"187302dbc916852ff2fdf47061e272c061611dda","modified":1764826507730},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/common.pug","hash":"27fa75affebc6e84a487c62bceff783bde595256","modified":1764826507730},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"fa4b4194749d05f7249f365f2b89c0281057ce54","modified":1764826507731},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"72e2970b23570e308f8af5d8ba8e5e3321d01bbf","modified":1764826507731},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"a7c07dbc1e970a5b247091458e1ee9b144a3366d","modified":1764826507731},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"34edfebf0cace0852806be774910ccb0e0914650","modified":1764826507732},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"d2e12a9fc302a4efe52c90d44896fbd73e193a1f","modified":1764826507732},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d376ec17fb19fcdcf0d2ad71330190146d3af879","modified":1764826507732},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"c34c1b19b3cfe24ca11c5edfb34613507a9a00c7","modified":1764826507734},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ec6c685080634ac46ffbea1b8f10313388888f43","modified":1764826507733},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"013756ff3363344987cc00fc9bd833baf193c341","modified":1764826507734},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"f8557548d2ad8dd149c562193991c6c6cda02415","modified":1764826507734},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"70364f4a9d9f13d713533a0fe0a9798707f1c1b3","modified":1764826507734},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"5c944052280c5ed046d2cfeb54b0da8876af0ec6","modified":1764826507735},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"efef352c1d122409575386bf3894dce8e87032e2","modified":1764826507736},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"e51e896ccb13900de38dc81cf44dc789e2418a12","modified":1764826507735},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"077ec530831be1d80e93da380406b9f5abd0918a","modified":1764826507754},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"1883c91d43bff10aae55122a21e0b064b6f5c9dd","modified":1764826507754},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"de4bb5fc2dfca368b35e4c1109c92f7abc9e2245","modified":1764826507755},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"9f02598b5e4296aec6470639d4bac4c9ac46392e","modified":1764826507753},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"ef52ebf1e8e751a412f9456fdaeee7d88afd9a72","modified":1764826507754},{"_id":"themes/butterfly/source/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1764826507770},{"_id":"public/categories/index.html","hash":"a8751592be96d0bd830b331523231a8e43460d8e","modified":1764835251907},{"_id":"public/tags/index.html","hash":"328c838159a6b5a739fa26eee9e1e23e2e6227a6","modified":1764835251907},{"_id":"public/2018/01/05/writing_blog_on_multiple_PC/index.html","hash":"2bb637a683bc1b35d413c279ec7386732d87acda","modified":1764835251907},{"_id":"public/2020/02/12/AVL_Tree/index.html","hash":"d28007c5101c387bf47f09b0323016d8a0d47210","modified":1764835251907},{"_id":"public/2020/10/01/Manacher/index.html","hash":"787a17064cfb9a18f10e19248308e0ce8b97a393","modified":1764835251907},{"_id":"public/2021/05/09/ubuntu_config/index.html","hash":"b40d2b6a43c9c2b3296eed7e2785c0f5ae99d1a0","modified":1764835251907},{"_id":"public/2022/07/22/KM/index.html","hash":"b405795decbc386c8882eef6b7a4183c86af8ac7","modified":1764835251907},{"_id":"public/2022/07/24/LA0/index.html","hash":"a3d342e611bd85277e7a239f35480ab5de4650b3","modified":1764835251907},{"_id":"public/2022/07/27/LA1/index.html","hash":"a226d772cf6d7c32c77435d99684c16a38045884","modified":1764835251907},{"_id":"public/2022/07/28/LA2/index.html","hash":"8cc60270b4ea50f47c58c7876da981e591b626c2","modified":1764835251907},{"_id":"public/2022/08/08/HRBUST2022/index.html","hash":"364fbaac6431d1ed810fa59cf658d70f1636f7bf","modified":1764835251907},{"_id":"public/2023/04/06/frac_programming/index.html","hash":"e7ae73b0bb1ad6d385fb5c4362d40787c948cfaa","modified":1764835251907},{"_id":"public/2023/04/29/JSCPC2021/index.html","hash":"9a84980357d83cd94724de812c2b40280bc4fe25","modified":1764835251907},{"_id":"public/2023/04/30/gf_0/index.html","hash":"5fdc21dc54c3cca60e6f0b848aeea1ce7e8c5322","modified":1764835251907},{"_id":"public/2023/05/02/GYM104081/index.html","hash":"f57e5e1871a6d23215427c379009423de1f28340","modified":1764835251907},{"_id":"public/2023/05/08/ANT_1/index.html","hash":"674f706727d0498a5b787d6220b2f5b95d662adf","modified":1764835251907},{"_id":"public/2023/07/18/CO1/index.html","hash":"0c6a7b1378d0a4b221dc2d47cdd989961a9fe735","modified":1764835251907},{"_id":"public/categories/math/index.html","hash":"8db41942cbdd9f1b777e13e1ada5bf0e34c219e1","modified":1764835251907},{"_id":"public/categories/Algorithm-and-DataStructure/index.html","hash":"311508c75de1469ed123ecb51cd74e97c3d6c7e0","modified":1764835251907},{"_id":"public/categories/Competitive-Programming/index.html","hash":"75f437a5820de69c2f845e1e2dbc5c1d92c8aafe","modified":1764835251907},{"_id":"public/categories/Linear-Algebra/index.html","hash":"3f996431d7635a2819f3f14127294394fdde0d82","modified":1764835251907},{"_id":"public/categories/Convex-Optimization/index.html","hash":"eb129b7c56029b1a7c5a78ee7f4f19ec3d422e9d","modified":1764835251907},{"_id":"public/categories/String/index.html","hash":"e20977a67f62dd65aff03844085c74f4cce49c9f","modified":1764835251907},{"_id":"public/categories/Tutorial/index.html","hash":"8afbd31f0eb3d5003c91463154ec845af0dae951","modified":1764835251907},{"_id":"public/categories/Math/index.html","hash":"0c65c7bbb0875b6bcbb34c7f6557a9f76bf60aa5","modified":1764835251907},{"_id":"public/categories/Misc/index.html","hash":"e97504fa262e968a6021f8b91f504c6b275b98c3","modified":1764835251907},{"_id":"public/archives/index.html","hash":"4d383a09e0f87537633732428cca54b6271c72db","modified":1764835251907},{"_id":"public/archives/page/2/index.html","hash":"433dbbdbc7d4c5de84b0defcd8590b5ef66757d6","modified":1764835251907},{"_id":"public/archives/2018/index.html","hash":"9510b5bf7b3cd6c05ff6119240645a0e5eb59c16","modified":1764835251907},{"_id":"public/archives/2018/01/index.html","hash":"5115237828a4b2c3bed6e45c29e8d672618fa475","modified":1764835251907},{"_id":"public/archives/2020/index.html","hash":"08c3e34b5107692d308f8439f5710235f9373643","modified":1764835251907},{"_id":"public/archives/2020/02/index.html","hash":"f9fa6a96b3a7a374ccaeb5aeba10ca1fb91dfd42","modified":1764835251907},{"_id":"public/archives/2020/10/index.html","hash":"b073a344e71e12c7629fbea17d5e5243e368456c","modified":1764835251907},{"_id":"public/archives/2021/05/index.html","hash":"b710974e765563c03bff0108cc9d2d4c7e867ac9","modified":1764835251907},{"_id":"public/archives/2021/index.html","hash":"d9a6365ba314f5e3f77e2f349ef5c0b810999007","modified":1764835251907},{"_id":"public/archives/2022/index.html","hash":"f1c42994a08ac4c6a9ec829d57952c307ab8a2b6","modified":1764835251907},{"_id":"public/archives/2022/07/index.html","hash":"918ad6f65365295ef1f5abca679a2bf63b52f582","modified":1764835251907},{"_id":"public/archives/2022/08/index.html","hash":"45d90072e6f7fddf9d8bd98b2d2e6ddf506ca540","modified":1764835251907},{"_id":"public/archives/2023/index.html","hash":"2c6148c2be1d26af9ee5d041ec25e1e48b2de794","modified":1764835251907},{"_id":"public/archives/2023/04/index.html","hash":"264015f794aa7f16e67302665b48228ec4ca0d02","modified":1764835251907},{"_id":"public/archives/2023/05/index.html","hash":"834b108b40b3587da761664a1f06e3be50d84289","modified":1764835251907},{"_id":"public/archives/2023/07/index.html","hash":"afedf8f0a6ec9d87818ba3a3eac43e238e83f756","modified":1764835251907},{"_id":"public/tags/data-structure/index.html","hash":"e1fff3cbb55ba12d81eb64d3d5a876863d56c6ee","modified":1764835251907},{"_id":"public/tags/math/index.html","hash":"af1bdd710b651e0ca5e5573c5e520129d95e386b","modified":1764835251907},{"_id":"public/tags/contest/index.html","hash":"c4a54069c202728c99a0872cc41462c8d4be1486","modified":1764835251907},{"_id":"public/tags/XCPC/index.html","hash":"48e5038c2d642233b1d0893116cb42e770e8daed","modified":1764835251907},{"_id":"public/tags/algorithm/index.html","hash":"5eb2db162d2f12abd3e234d37c608048e13f6c01","modified":1764835251907},{"_id":"public/tags/linear-algebra/index.html","hash":"4633988af0efd30728cb69e5e3022019bd983787","modified":1764835251907},{"_id":"public/tags/Convex-Optimization/index.html","hash":"5cbc279df50b0139408f97875d863d6704845faa","modified":1764835251907},{"_id":"public/tags/manacher/index.html","hash":"2e6c7b00c5d2eb6f1fd78ea70184a9eb54853e6e","modified":1764835251907},{"_id":"public/tags/GF/index.html","hash":"81c6f06bb433883f038e8c96489fd9950ca46839","modified":1764835251907},{"_id":"public/index.html","hash":"7d5bfaca0e748f19c8d0032d9f98fca54e68f24d","modified":1764835251907},{"_id":"public/tags/ubuntu/index.html","hash":"77860a09a62c83bbf82b5824114caa2d7ae455b6","modified":1764835251907},{"_id":"public/tags/blog/index.html","hash":"53e57ce925b6525ae4510dad203ad7b920fcabfb","modified":1764835251907},{"_id":"public/page/2/index.html","hash":"9a19a9c2032582ce34a0c0e327094575bda54ca5","modified":1764835251907},{"_id":"public/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1764835251907},{"_id":"public/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1764835251907},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1764835251907},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1764835251907},{"_id":"public/css/index.css","hash":"ab3ace5b875b67b3523c08843e81e567ddfc7bd8","modified":1764835251907},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1764835251907},{"_id":"public/js/utils.js","hash":"e3b4a5e1ef72c3ebab85542da11d9addfbfce42a","modified":1764835251907},{"_id":"public/js/main.js","hash":"45f939cbc099e81d65c58867155e06f9ffc48e2c","modified":1764835251907},{"_id":"public/js/search/algolia.js","hash":"02491d2798f07f820962cafaceb07a2f8c97bc41","modified":1764835251907},{"_id":"public/js/tw_cn.js","hash":"337c417a6e37dfabc920463fa13f65cc3d02f164","modified":1764835251907},{"_id":"public/js/search/local-search.js","hash":"50ab53c2b11c7c4cc1d9240b749af124ad38bfdc","modified":1764835251907},{"_id":"public/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1764835251907}],"Category":[{"name":"math","_id":"cmir5cbx500042cle13u083gn"},{"name":"Algorithm and DataStructure","_id":"cmir5cbx700092cle70gd5sxs"},{"name":"Competitive Programming","_id":"cmir5cbx8000f2cle5rixfiot"},{"name":"Linear Algebra","_id":"cmir5cbxc000w2cled0t44xj3"},{"name":"Convex Optimization","_id":"cmir5cbxd00172cle0o0e9fkp"},{"name":"String","_id":"cmir5cbxe001f2cle6ahx6oc9"},{"name":"Math","_id":"cmir5cbxe001n2cle0zhb332y"},{"name":"Tutorial","_id":"cmir5cbxf001s2cle91ov93fz"},{"name":"Misc","_id":"cmir5cbxf001w2cle9q73fs9j"}],"Data":[],"Page":[{"title":"categories","date":"2025-12-03T16:00:00.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2025-12-04\ntype: 'categories'\n---\n","updated":"2025-12-04T06:45:05.896Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cmir5cbx100002cle4bdp5yq0","content":"","excerpt":"","more":""},{"title":"tags","date":"2025-12-03T16:00:00.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2025-12-04\ntype: 'tags'\n---\n","updated":"2025-12-04T06:44:35.057Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cmir5cbx400022cle4wkogev9","content":"","excerpt":"","more":""}],"Post":[{"title":"算法数论摘录","date":"2023-05-07T16:00:00.000Z","math":true,"_content":"\n数学太差了，很多东西都不会，只能摘录一点能理解的。\n\n# 质数\n\n## Mersenne 质数\n\n先来看一个引理：\n\n若 $n\\gt 1$，且 $a^n-1$ 为质数，则 $a=2$，$n$ 为质数。\n\n这个太显然了，证明过程就不写了。\n\n$M_n=2^n-1$ 称为第 $n$ 个 Mersenne 数。当 $p$ 为质数且 $M_p$ 为质数时，$M_p$ 称为 Mersenne 质数。\n\n## Fermat 质数\n\n先证明一个引理：\n\n若 $2^m+1$ 为质数，则 $m=2^n$。\n\n容易发现，若 $m$ 有奇因子 $q$，令 $m=qr$，则 \n\n$$\n2^{qr}+1=(2^r+1)\\sum_{i=0}^{q-1}(-1)^i2^{ri}\n$$\n\n显然不是质数。\n\n$F_n=2^{2^n}+1$ 称为第 $n$ 个 Fermat 数，$F_0$ 到 $F_4$ 均为质数，所以 Fermat 猜测所有这样的数都是质数。然而接下来的几个都不是质数，下一个质数直到 $F_{10}$ 才会出现，而这个数已经有三百多位了。\n\n## Euler 函数\n\n### Euler 定理\n\n若 $\\gcd(k,m) = 1$，则 \n\n$$k^{\\varphi(m)}\\equiv 1 \\pmod m$$\n\n证明十分巧妙：\n\n从模 $m$ 的 $\\varphi(m)$ 个剩余类中各取一个代表元，组成一个缩剩余系，简称缩系。\n\n用 $a_1,a_2,\\cdots,a_{\\varphi(m)}$ 表示一个缩系，由于 $\\gcd(k,m)=1$，则 $\\lbrace ka_i\\rbrace$ 也是一个缩系。于是\n\n$$\n\\prod_{i=1}^{\\varphi(m)} ka_i \\equiv\\prod_{i=1}^{\\varphi(m)} a_i \\pmod m\n$$\n\n根据 $\\gcd(a_i,m) = 1$，可得 $k^{\\varphi(m)}\\equiv 1 \\pmod m$。\n\n### Fermat 小定理\n\n若 $p$ 为质数，$\\forall a\\in \\mathbb{N}$，有\n\n$$\na^p \\equiv a \\pmod p\n$$\n\n使用 Euler 定理即可证明。\n\n# 同余\n\n## Wilson 定理\n\n若 $p$ 为质数，则\n\n$$\n(p-1)!\\equiv -1\\pmod p\n$$\n\n## 原根\n\n### 重要结论\n\n若 $p$ 为质数，则同余方程\n\n$$\nx^k \\equiv 1\\pmod p\n$$\n\n的解数为 $\\gcd(k, p - 1)$。\n\n### 阶\n\n设 $h$ 为整数，$\\gcd(h,n)=1$，满足 \n\n$$\nh^l \\equiv 1\\pmod n\n$$\n\n的最小正整数 $l$，称为 $h$ 模 $n$ 的阶。\n\n设 $l|p-1$，则模 $p$ 的阶为 $l$ 的互不同余的整数个数为 $\\varphi(l)$。\n\n### 原根\n\n阶为 $p-1$ 的数称为模 $p$ 的一个原根。\n\n$p$ 有 $\\varphi(p-1)$ 个原根，若 $g$ 为 $p$ 的原根，则\n\n$$\ng^0,g^1,\\cdots,g^{p-2}\\pmod p\n$$\n\n为模 $p$ 的一个缩系。\n\n### 指数\n\n任一整数 $p(p\\nmid n)$，必有一数 $a$，满足\n\n$$\nn=g^a \\pmod p,0\\le a\\lt p-1\n$$\n\n$a$ 称为 $n$ 模 $p$ 的指数，记为 $a=\\text{ind}_g n$。\n\n指数的性质与对数类似：\n\n$$\n\\text{ind}(ab) \\equiv \\text{ind}(a) + \\text{ind}(b)\\pmod {p-1} \\\\\n\\text{ind}(a^l)\\equiv l\\cdot \\text{ind}(a) \\pmod {p-1}\n$$\n\n### 构造\n\n$m$ 有原根存在的充要条件：$m=2,4,p^l,2p^l$（$p$ 为奇质数）。\n\n\n","source":"_posts/ANT_1.md","raw":"---\ntitle: 算法数论摘录\ndate: 2023-05-08\ntag: [math]\ncategory: [math]\nmath: true\n---\n\n数学太差了，很多东西都不会，只能摘录一点能理解的。\n\n# 质数\n\n## Mersenne 质数\n\n先来看一个引理：\n\n若 $n\\gt 1$，且 $a^n-1$ 为质数，则 $a=2$，$n$ 为质数。\n\n这个太显然了，证明过程就不写了。\n\n$M_n=2^n-1$ 称为第 $n$ 个 Mersenne 数。当 $p$ 为质数且 $M_p$ 为质数时，$M_p$ 称为 Mersenne 质数。\n\n## Fermat 质数\n\n先证明一个引理：\n\n若 $2^m+1$ 为质数，则 $m=2^n$。\n\n容易发现，若 $m$ 有奇因子 $q$，令 $m=qr$，则 \n\n$$\n2^{qr}+1=(2^r+1)\\sum_{i=0}^{q-1}(-1)^i2^{ri}\n$$\n\n显然不是质数。\n\n$F_n=2^{2^n}+1$ 称为第 $n$ 个 Fermat 数，$F_0$ 到 $F_4$ 均为质数，所以 Fermat 猜测所有这样的数都是质数。然而接下来的几个都不是质数，下一个质数直到 $F_{10}$ 才会出现，而这个数已经有三百多位了。\n\n## Euler 函数\n\n### Euler 定理\n\n若 $\\gcd(k,m) = 1$，则 \n\n$$k^{\\varphi(m)}\\equiv 1 \\pmod m$$\n\n证明十分巧妙：\n\n从模 $m$ 的 $\\varphi(m)$ 个剩余类中各取一个代表元，组成一个缩剩余系，简称缩系。\n\n用 $a_1,a_2,\\cdots,a_{\\varphi(m)}$ 表示一个缩系，由于 $\\gcd(k,m)=1$，则 $\\lbrace ka_i\\rbrace$ 也是一个缩系。于是\n\n$$\n\\prod_{i=1}^{\\varphi(m)} ka_i \\equiv\\prod_{i=1}^{\\varphi(m)} a_i \\pmod m\n$$\n\n根据 $\\gcd(a_i,m) = 1$，可得 $k^{\\varphi(m)}\\equiv 1 \\pmod m$。\n\n### Fermat 小定理\n\n若 $p$ 为质数，$\\forall a\\in \\mathbb{N}$，有\n\n$$\na^p \\equiv a \\pmod p\n$$\n\n使用 Euler 定理即可证明。\n\n# 同余\n\n## Wilson 定理\n\n若 $p$ 为质数，则\n\n$$\n(p-1)!\\equiv -1\\pmod p\n$$\n\n## 原根\n\n### 重要结论\n\n若 $p$ 为质数，则同余方程\n\n$$\nx^k \\equiv 1\\pmod p\n$$\n\n的解数为 $\\gcd(k, p - 1)$。\n\n### 阶\n\n设 $h$ 为整数，$\\gcd(h,n)=1$，满足 \n\n$$\nh^l \\equiv 1\\pmod n\n$$\n\n的最小正整数 $l$，称为 $h$ 模 $n$ 的阶。\n\n设 $l|p-1$，则模 $p$ 的阶为 $l$ 的互不同余的整数个数为 $\\varphi(l)$。\n\n### 原根\n\n阶为 $p-1$ 的数称为模 $p$ 的一个原根。\n\n$p$ 有 $\\varphi(p-1)$ 个原根，若 $g$ 为 $p$ 的原根，则\n\n$$\ng^0,g^1,\\cdots,g^{p-2}\\pmod p\n$$\n\n为模 $p$ 的一个缩系。\n\n### 指数\n\n任一整数 $p(p\\nmid n)$，必有一数 $a$，满足\n\n$$\nn=g^a \\pmod p,0\\le a\\lt p-1\n$$\n\n$a$ 称为 $n$ 模 $p$ 的指数，记为 $a=\\text{ind}_g n$。\n\n指数的性质与对数类似：\n\n$$\n\\text{ind}(ab) \\equiv \\text{ind}(a) + \\text{ind}(b)\\pmod {p-1} \\\\\n\\text{ind}(a^l)\\equiv l\\cdot \\text{ind}(a) \\pmod {p-1}\n$$\n\n### 构造\n\n$m$ 有原根存在的充要条件：$m=2,4,p^l,2p^l$（$p$ 为奇质数）。\n\n\n","slug":"ANT_1","published":1,"updated":"2023-05-08T02:52:55.236Z","comments":1,"layout":"post","photos":[],"_id":"cmir5cbx200012clehhvb9q1s","content":"<p>数学太差了，很多东西都不会，只能摘录一点能理解的。</p>\n<h1 id=\"质数\"><a href=\"#质数\" class=\"headerlink\" title=\"质数\"></a>质数</h1><h2 id=\"Mersenne-质数\"><a href=\"#Mersenne-质数\" class=\"headerlink\" title=\"Mersenne 质数\"></a>Mersenne 质数</h2><p>先来看一个引理：</p>\n<p>若 $n\\gt 1$，且 $a^n-1$ 为质数，则 $a&#x3D;2$，$n$ 为质数。</p>\n<p>这个太显然了，证明过程就不写了。</p>\n<p>$M_n&#x3D;2^n-1$ 称为第 $n$ 个 Mersenne 数。当 $p$ 为质数且 $M_p$ 为质数时，$M_p$ 称为 Mersenne 质数。</p>\n<h2 id=\"Fermat-质数\"><a href=\"#Fermat-质数\" class=\"headerlink\" title=\"Fermat 质数\"></a>Fermat 质数</h2><p>先证明一个引理：</p>\n<p>若 $2^m+1$ 为质数，则 $m&#x3D;2^n$。</p>\n<p>容易发现，若 $m$ 有奇因子 $q$，令 $m&#x3D;qr$，则 </p>\n<p>$$<br>2^{qr}+1&#x3D;(2^r+1)\\sum_{i&#x3D;0}^{q-1}(-1)^i2^{ri}<br>$$</p>\n<p>显然不是质数。</p>\n<p>$F_n&#x3D;2^{2^n}+1$ 称为第 $n$ 个 Fermat 数，$F_0$ 到 $F_4$ 均为质数，所以 Fermat 猜测所有这样的数都是质数。然而接下来的几个都不是质数，下一个质数直到 $F_{10}$ 才会出现，而这个数已经有三百多位了。</p>\n<h2 id=\"Euler-函数\"><a href=\"#Euler-函数\" class=\"headerlink\" title=\"Euler 函数\"></a>Euler 函数</h2><h3 id=\"Euler-定理\"><a href=\"#Euler-定理\" class=\"headerlink\" title=\"Euler 定理\"></a>Euler 定理</h3><p>若 $\\gcd(k,m) &#x3D; 1$，则 </p>\n<p>$$k^{\\varphi(m)}\\equiv 1 \\pmod m$$</p>\n<p>证明十分巧妙：</p>\n<p>从模 $m$ 的 $\\varphi(m)$ 个剩余类中各取一个代表元，组成一个缩剩余系，简称缩系。</p>\n<p>用 $a_1,a_2,\\cdots,a_{\\varphi(m)}$ 表示一个缩系，由于 $\\gcd(k,m)&#x3D;1$，则 $\\lbrace ka_i\\rbrace$ 也是一个缩系。于是</p>\n<p>$$<br>\\prod_{i&#x3D;1}^{\\varphi(m)} ka_i \\equiv\\prod_{i&#x3D;1}^{\\varphi(m)} a_i \\pmod m<br>$$</p>\n<p>根据 $\\gcd(a_i,m) &#x3D; 1$，可得 $k^{\\varphi(m)}\\equiv 1 \\pmod m$。</p>\n<h3 id=\"Fermat-小定理\"><a href=\"#Fermat-小定理\" class=\"headerlink\" title=\"Fermat 小定理\"></a>Fermat 小定理</h3><p>若 $p$ 为质数，$\\forall a\\in \\mathbb{N}$，有</p>\n<p>$$<br>a^p \\equiv a \\pmod p<br>$$</p>\n<p>使用 Euler 定理即可证明。</p>\n<h1 id=\"同余\"><a href=\"#同余\" class=\"headerlink\" title=\"同余\"></a>同余</h1><h2 id=\"Wilson-定理\"><a href=\"#Wilson-定理\" class=\"headerlink\" title=\"Wilson 定理\"></a>Wilson 定理</h2><p>若 $p$ 为质数，则</p>\n<p>$$<br>(p-1)!\\equiv -1\\pmod p<br>$$</p>\n<h2 id=\"原根\"><a href=\"#原根\" class=\"headerlink\" title=\"原根\"></a>原根</h2><h3 id=\"重要结论\"><a href=\"#重要结论\" class=\"headerlink\" title=\"重要结论\"></a>重要结论</h3><p>若 $p$ 为质数，则同余方程</p>\n<p>$$<br>x^k \\equiv 1\\pmod p<br>$$</p>\n<p>的解数为 $\\gcd(k, p - 1)$。</p>\n<h3 id=\"阶\"><a href=\"#阶\" class=\"headerlink\" title=\"阶\"></a>阶</h3><p>设 $h$ 为整数，$\\gcd(h,n)&#x3D;1$，满足 </p>\n<p>$$<br>h^l \\equiv 1\\pmod n<br>$$</p>\n<p>的最小正整数 $l$，称为 $h$ 模 $n$ 的阶。</p>\n<p>设 $l|p-1$，则模 $p$ 的阶为 $l$ 的互不同余的整数个数为 $\\varphi(l)$。</p>\n<h3 id=\"原根-1\"><a href=\"#原根-1\" class=\"headerlink\" title=\"原根\"></a>原根</h3><p>阶为 $p-1$ 的数称为模 $p$ 的一个原根。</p>\n<p>$p$ 有 $\\varphi(p-1)$ 个原根，若 $g$ 为 $p$ 的原根，则</p>\n<p>$$<br>g^0,g^1,\\cdots,g^{p-2}\\pmod p<br>$$</p>\n<p>为模 $p$ 的一个缩系。</p>\n<h3 id=\"指数\"><a href=\"#指数\" class=\"headerlink\" title=\"指数\"></a>指数</h3><p>任一整数 $p(p\\nmid n)$，必有一数 $a$，满足</p>\n<p>$$<br>n&#x3D;g^a \\pmod p,0\\le a\\lt p-1<br>$$</p>\n<p>$a$ 称为 $n$ 模 $p$ 的指数，记为 $a&#x3D;\\text{ind}_g n$。</p>\n<p>指数的性质与对数类似：</p>\n<p>$$<br>\\text{ind}(ab) \\equiv \\text{ind}(a) + \\text{ind}(b)\\pmod {p-1} \\<br>\\text{ind}(a^l)\\equiv l\\cdot \\text{ind}(a) \\pmod {p-1}<br>$$</p>\n<h3 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h3><p>$m$ 有原根存在的充要条件：$m&#x3D;2,4,p^l,2p^l$（$p$ 为奇质数）。</p>\n","excerpt":"","more":"<p>数学太差了，很多东西都不会，只能摘录一点能理解的。</p>\n<h1 id=\"质数\"><a href=\"#质数\" class=\"headerlink\" title=\"质数\"></a>质数</h1><h2 id=\"Mersenne-质数\"><a href=\"#Mersenne-质数\" class=\"headerlink\" title=\"Mersenne 质数\"></a>Mersenne 质数</h2><p>先来看一个引理：</p>\n<p>若 $n\\gt 1$，且 $a^n-1$ 为质数，则 $a&#x3D;2$，$n$ 为质数。</p>\n<p>这个太显然了，证明过程就不写了。</p>\n<p>$M_n&#x3D;2^n-1$ 称为第 $n$ 个 Mersenne 数。当 $p$ 为质数且 $M_p$ 为质数时，$M_p$ 称为 Mersenne 质数。</p>\n<h2 id=\"Fermat-质数\"><a href=\"#Fermat-质数\" class=\"headerlink\" title=\"Fermat 质数\"></a>Fermat 质数</h2><p>先证明一个引理：</p>\n<p>若 $2^m+1$ 为质数，则 $m&#x3D;2^n$。</p>\n<p>容易发现，若 $m$ 有奇因子 $q$，令 $m&#x3D;qr$，则 </p>\n<p>$$<br>2^{qr}+1&#x3D;(2^r+1)\\sum_{i&#x3D;0}^{q-1}(-1)^i2^{ri}<br>$$</p>\n<p>显然不是质数。</p>\n<p>$F_n&#x3D;2^{2^n}+1$ 称为第 $n$ 个 Fermat 数，$F_0$ 到 $F_4$ 均为质数，所以 Fermat 猜测所有这样的数都是质数。然而接下来的几个都不是质数，下一个质数直到 $F_{10}$ 才会出现，而这个数已经有三百多位了。</p>\n<h2 id=\"Euler-函数\"><a href=\"#Euler-函数\" class=\"headerlink\" title=\"Euler 函数\"></a>Euler 函数</h2><h3 id=\"Euler-定理\"><a href=\"#Euler-定理\" class=\"headerlink\" title=\"Euler 定理\"></a>Euler 定理</h3><p>若 $\\gcd(k,m) &#x3D; 1$，则 </p>\n<p>$$k^{\\varphi(m)}\\equiv 1 \\pmod m$$</p>\n<p>证明十分巧妙：</p>\n<p>从模 $m$ 的 $\\varphi(m)$ 个剩余类中各取一个代表元，组成一个缩剩余系，简称缩系。</p>\n<p>用 $a_1,a_2,\\cdots,a_{\\varphi(m)}$ 表示一个缩系，由于 $\\gcd(k,m)&#x3D;1$，则 $\\lbrace ka_i\\rbrace$ 也是一个缩系。于是</p>\n<p>$$<br>\\prod_{i&#x3D;1}^{\\varphi(m)} ka_i \\equiv\\prod_{i&#x3D;1}^{\\varphi(m)} a_i \\pmod m<br>$$</p>\n<p>根据 $\\gcd(a_i,m) &#x3D; 1$，可得 $k^{\\varphi(m)}\\equiv 1 \\pmod m$。</p>\n<h3 id=\"Fermat-小定理\"><a href=\"#Fermat-小定理\" class=\"headerlink\" title=\"Fermat 小定理\"></a>Fermat 小定理</h3><p>若 $p$ 为质数，$\\forall a\\in \\mathbb{N}$，有</p>\n<p>$$<br>a^p \\equiv a \\pmod p<br>$$</p>\n<p>使用 Euler 定理即可证明。</p>\n<h1 id=\"同余\"><a href=\"#同余\" class=\"headerlink\" title=\"同余\"></a>同余</h1><h2 id=\"Wilson-定理\"><a href=\"#Wilson-定理\" class=\"headerlink\" title=\"Wilson 定理\"></a>Wilson 定理</h2><p>若 $p$ 为质数，则</p>\n<p>$$<br>(p-1)!\\equiv -1\\pmod p<br>$$</p>\n<h2 id=\"原根\"><a href=\"#原根\" class=\"headerlink\" title=\"原根\"></a>原根</h2><h3 id=\"重要结论\"><a href=\"#重要结论\" class=\"headerlink\" title=\"重要结论\"></a>重要结论</h3><p>若 $p$ 为质数，则同余方程</p>\n<p>$$<br>x^k \\equiv 1\\pmod p<br>$$</p>\n<p>的解数为 $\\gcd(k, p - 1)$。</p>\n<h3 id=\"阶\"><a href=\"#阶\" class=\"headerlink\" title=\"阶\"></a>阶</h3><p>设 $h$ 为整数，$\\gcd(h,n)&#x3D;1$，满足 </p>\n<p>$$<br>h^l \\equiv 1\\pmod n<br>$$</p>\n<p>的最小正整数 $l$，称为 $h$ 模 $n$ 的阶。</p>\n<p>设 $l|p-1$，则模 $p$ 的阶为 $l$ 的互不同余的整数个数为 $\\varphi(l)$。</p>\n<h3 id=\"原根-1\"><a href=\"#原根-1\" class=\"headerlink\" title=\"原根\"></a>原根</h3><p>阶为 $p-1$ 的数称为模 $p$ 的一个原根。</p>\n<p>$p$ 有 $\\varphi(p-1)$ 个原根，若 $g$ 为 $p$ 的原根，则</p>\n<p>$$<br>g^0,g^1,\\cdots,g^{p-2}\\pmod p<br>$$</p>\n<p>为模 $p$ 的一个缩系。</p>\n<h3 id=\"指数\"><a href=\"#指数\" class=\"headerlink\" title=\"指数\"></a>指数</h3><p>任一整数 $p(p\\nmid n)$，必有一数 $a$，满足</p>\n<p>$$<br>n&#x3D;g^a \\pmod p,0\\le a\\lt p-1<br>$$</p>\n<p>$a$ 称为 $n$ 模 $p$ 的指数，记为 $a&#x3D;\\text{ind}_g n$。</p>\n<p>指数的性质与对数类似：</p>\n<p>$$<br>\\text{ind}(ab) \\equiv \\text{ind}(a) + \\text{ind}(b)\\pmod {p-1} \\<br>\\text{ind}(a^l)\\equiv l\\cdot \\text{ind}(a) \\pmod {p-1}<br>$$</p>\n<h3 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h3><p>$m$ 有原根存在的充要条件：$m&#x3D;2,4,p^l,2p^l$（$p$ 为奇质数）。</p>\n"},{"title":"AVL tree","date":"2020-02-11T16:00:00.000Z","math":true,"_content":"\n# 简介：\n\nAVL树是最先发明的自平衡二叉查找树。AVL树高度平衡，其任意节点左右子树的高度差不超过1。同时它也拥有普通二叉查找树的性质，即每个节点左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，且不同节点的值均不同。\n\n<!--more-->\n\n# 实现过程\n**平衡因子：**每个节点左子树和右子树的高度差。若所有节点平衡因子的绝对值均不超过1则平衡。\n\n使用一个结构体保存节点的键值、频数、以该点为根的树的树高和大小以及左右子树。当树不平衡时，可以通过旋转使树平衡。\n\n```c++\nstruct AVL_node;\ntypedef AVL_node *AVL_Tree;\nstruct AVL_node\n{\n    int value, height, freq, size;\n    AVL_Tree ls, rs;\n    AVL_node() : value(0), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n    AVL_node(int n) : value(n), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n};\n```\n\n**不平衡情况1（左-左）：**\n\n![1](https://i.loli.net/2020/02/12/BYrixbevTfP8cR4.png)\n\n在插入1之前，树是平衡的，但是9的左子树比右子树高度大。在9的左子树的左子树插入1（或2，4，5）后，树不平衡了，这种左子树更高且向左子树的左子树插入节点的情况可以通过一次右旋来使树平衡。右旋使原来不平衡的根节点的左子树成为根节点，而原来的根节点成为新的右子树，原来左子树的右子树成为原来的根节点的左子树。容易证明，旋转后依旧具有二叉查找树的性质。\n\n![2](https://i.loli.net/2020/02/12/mz46SiMWg5lTcfJ.png)\n\n```c++\ninline void rotate_ls_ls(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->ls;\n    p->ls = q->rs;\n    q->rs = p;\n    update(p);\n    update(q);\n    p = q;\n}\n```\n**不平衡情况2（右-右）：**\n\n![3](https://i.loli.net/2020/02/12/f5eClWkqbJ7XywL.png)\n\n在插入13之前，树是平衡的，但是8的右子树比左子树高度大。在8的右子树的右子树插入13（或11）后，树不平衡了，这种右子树更高且向右子树的右子树插入节点的情况可以通过一次左旋来使树平衡。左旋使原来不平衡的根节点的右子树成为根节点，而原来的根节点成为新的左子树，原来右子树的左子树成为原来的根节点的右子树。同样，旋转后依旧具有二叉查找树的性质。\n\n![4](https://i.loli.net/2020/02/12/vhUgRs8SFj41HmV.png)\n```c++\ninline void rotate_rs_rs(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->rs;\n    p->rs = q->ls;\n    q->ls = p;\n    update(p);\n    update(q);\n    p = q;\n}\n```\n**不平衡情况3：（左-右）**\n\n![5](https://i.loli.net/2020/02/12/dRS1WHXAN7MlUhg.png)\n\n这种情况是在左子树更高的树的左子树的右子树插入节点，需要先进行一次左旋，再进行一次右旋。\n\n左旋：\n\n![6](https://i.loli.net/2020/02/12/9S1xL8N2FIvhuZA.png)\n\n右旋：\n\n![7](https://i.loli.net/2020/02/12/WgVKU1dbrEno9Ra.png)\n```c++\ninline void rotate_ls_rs(AVL_Tree &p)\n{\n    rotate_rs_rs(p->ls);\n    rotate_ls_ls(p);\n}\n```\n**不平衡情况4：（右-左）**\n\n与情况3相反，先进行一次右旋，再进行一次左旋。\n\n![8](https://i.loli.net/2020/02/12/6KXb74TNLQUO1RB.png)\n\n右旋：\n\n![9](https://i.loli.net/2020/02/12/V5JZvClKTzU8qcP.png)\n\n左旋：\n\n![10](https://i.loli.net/2020/02/12/2h8ktCgqNnZR3IW.png)\n```c++\ninline void rotate_rs_ls(AVL_Tree &p)\n{\n    rotate_ls_ls(p->rs);\n    rotate_rs_rs(p);\n}\n```\n\n**获取树的大小**\n\n```c++\ninline int get_size(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->size;\n}\n```\n\n**获取树的高度**\n\n```c++\ninline int get_height(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->height;\n}\n```\n\n**更新**\n\n```c++\ninline void update(AVL_Tree &p)\n{\n    p->size = get_size(p->ls) + get_size(p->rs) + p->freq;\n    p->height = max(get_height(p->ls), get_height(p->rs)) + 1;\n}\n```\n\n**插入**\n\n```c++\nvoid AVL_insert(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n    {\n        p = new AVL_node(x);\n        return;\n    }\n    if (p->value == x)//已经存在,频数+1\n    {\n        (p->freq)++;\n        update(p);\n        return;\n    }\n    if (p->value > x)\n    {\n        AVL_insert(p->ls, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)//插到左边,左边更高\n        {\n            if (x < p->ls->value)\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        AVL_insert(p->rs, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)//插到右边,右边更高\n        {\n            if (x > p->rs->value)\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    update(p);\n}\n```\n\n**删除数据**\n\n```c++\nvoid AVL_erase(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n        return;\n    if (p->value > x)\n    {\n        AVL_erase(p->ls, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)//删左边，右边高\n        {\n            if (get_height(p->rs->rs) >= get_height(p->rs->ls))//见代码后注释\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    else if (p->value < x)\n    {\n        AVL_erase(p->rs, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)\n        {\n            if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        if (p->freq > 1)\n        {\n            (p->freq)--;\n            update(p);\n            return;\n        }\n        if (p->ls && p->rs)\n        {\n            AVL_Tree q;\n            q = p->rs;\n            while (q->ls)\n                q = q->ls;\n            p->freq = q->freq;\n            p->value = q->value;\n            q->freq = 1; //删除q\n            AVL_erase(p->rs, q->value);\n            if (get_height(p->ls) - get_height(p->rs) == 2)\n            {\n                if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                    rotate_ls_ls(p);\n                else\n                    rotate_ls_rs(p);\n            }\n        }\n        else\n        {\n            AVL_Tree q;\n            q = p;\n            if (p->ls)\n                p = p->ls;\n            else if (p->rs)\n                p = p->rs;\n            else\n                p = nullptr;\n            delete q;\n            q = nullptr;\n        }\n    }\n    if (p == nullptr)\n        return;\n    update(p);\n}\n```\n\n第11行必须用$\\ge$，否则遇到如图的情况：\n\n![11](https://i.loli.net/2020/02/12/XuxmhoWtJvaCqwp.png)\n\n删去13后，先右旋再左旋，树仍然不是平衡的：\n\n![12](https://i.loli.net/2020/02/12/U4IajS9vukohHml.png)\n\n**通过值查找位次**\n\n```c++\nint get_rank(AVL_Tree p, int x)\n{\n    if (p->value == x)\n        return get_size(p->ls) + 1;\n    if (p->value > x)\n        return get_rank(p->ls, x);\n    return get_rank(p->rs, x) + get_size(p->ls) + p->freq;\n}\n```\n\n**通过位次查找值**\n\n```c++\nint get_val(AVL_Tree p, int r)\n{\n    if (get_size(p->ls) >= r)\n        return get_val(p->ls, r);\n    if (get_size(p->ls) + p->freq >= r)\n        return p->value;\n    return get_val(p->rs, r - get_size(p->ls) - p->freq);\n}\n```\n\n**查找前驱**\n\n```c++\nint get_pre(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(-inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->ls)\n            {\n                p = p->ls;\n                while (p->rs)\n                {\n                    p = p->rs;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value < x && p->value > ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\n```\n\n**查找后继**\n\n```c++\nint get_suf(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->rs)\n            {\n                p = p->rs;\n                while (p->ls)\n                {\n                    p = p->ls;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value > x && p->value < ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\n```\n\n**中序遍历**\n\n```c++\nvoid output(AVL_Tree p)\n{\n    if(p==nullptr)\n        return;\n    output(p->ls);\n    for (int i = 1; i <= p->freq;i++)\n        printf(\"%d \", p->value);\n    output(p->rs);\n}\n```\n\nAVL树的插入、删除、查找都是$\\log$级别的复杂度，其中AVL树的查询和其它平衡树相比会更有优势，但是AVL树代码量比较大，总体速度也很一般，可以分裂合并，可持久化，但是比较难写。\n\n终于写完了，真是不容易。\n\n![v2-28825ec8201c53892205bfd8b41c97dd_hd.jpg](https://i.loli.net/2020/02/12/1scLYZaiKRt25N3.jpg)\n\n\n","source":"_posts/AVL_Tree.md","raw":"---\ntitle: AVL tree\ndate: 2020-02-12\ntag: [data structure]\ncategory: [Algorithm and DataStructure]\nmath: true\n---\n\n# 简介：\n\nAVL树是最先发明的自平衡二叉查找树。AVL树高度平衡，其任意节点左右子树的高度差不超过1。同时它也拥有普通二叉查找树的性质，即每个节点左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，且不同节点的值均不同。\n\n<!--more-->\n\n# 实现过程\n**平衡因子：**每个节点左子树和右子树的高度差。若所有节点平衡因子的绝对值均不超过1则平衡。\n\n使用一个结构体保存节点的键值、频数、以该点为根的树的树高和大小以及左右子树。当树不平衡时，可以通过旋转使树平衡。\n\n```c++\nstruct AVL_node;\ntypedef AVL_node *AVL_Tree;\nstruct AVL_node\n{\n    int value, height, freq, size;\n    AVL_Tree ls, rs;\n    AVL_node() : value(0), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n    AVL_node(int n) : value(n), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n};\n```\n\n**不平衡情况1（左-左）：**\n\n![1](https://i.loli.net/2020/02/12/BYrixbevTfP8cR4.png)\n\n在插入1之前，树是平衡的，但是9的左子树比右子树高度大。在9的左子树的左子树插入1（或2，4，5）后，树不平衡了，这种左子树更高且向左子树的左子树插入节点的情况可以通过一次右旋来使树平衡。右旋使原来不平衡的根节点的左子树成为根节点，而原来的根节点成为新的右子树，原来左子树的右子树成为原来的根节点的左子树。容易证明，旋转后依旧具有二叉查找树的性质。\n\n![2](https://i.loli.net/2020/02/12/mz46SiMWg5lTcfJ.png)\n\n```c++\ninline void rotate_ls_ls(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->ls;\n    p->ls = q->rs;\n    q->rs = p;\n    update(p);\n    update(q);\n    p = q;\n}\n```\n**不平衡情况2（右-右）：**\n\n![3](https://i.loli.net/2020/02/12/f5eClWkqbJ7XywL.png)\n\n在插入13之前，树是平衡的，但是8的右子树比左子树高度大。在8的右子树的右子树插入13（或11）后，树不平衡了，这种右子树更高且向右子树的右子树插入节点的情况可以通过一次左旋来使树平衡。左旋使原来不平衡的根节点的右子树成为根节点，而原来的根节点成为新的左子树，原来右子树的左子树成为原来的根节点的右子树。同样，旋转后依旧具有二叉查找树的性质。\n\n![4](https://i.loli.net/2020/02/12/vhUgRs8SFj41HmV.png)\n```c++\ninline void rotate_rs_rs(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->rs;\n    p->rs = q->ls;\n    q->ls = p;\n    update(p);\n    update(q);\n    p = q;\n}\n```\n**不平衡情况3：（左-右）**\n\n![5](https://i.loli.net/2020/02/12/dRS1WHXAN7MlUhg.png)\n\n这种情况是在左子树更高的树的左子树的右子树插入节点，需要先进行一次左旋，再进行一次右旋。\n\n左旋：\n\n![6](https://i.loli.net/2020/02/12/9S1xL8N2FIvhuZA.png)\n\n右旋：\n\n![7](https://i.loli.net/2020/02/12/WgVKU1dbrEno9Ra.png)\n```c++\ninline void rotate_ls_rs(AVL_Tree &p)\n{\n    rotate_rs_rs(p->ls);\n    rotate_ls_ls(p);\n}\n```\n**不平衡情况4：（右-左）**\n\n与情况3相反，先进行一次右旋，再进行一次左旋。\n\n![8](https://i.loli.net/2020/02/12/6KXb74TNLQUO1RB.png)\n\n右旋：\n\n![9](https://i.loli.net/2020/02/12/V5JZvClKTzU8qcP.png)\n\n左旋：\n\n![10](https://i.loli.net/2020/02/12/2h8ktCgqNnZR3IW.png)\n```c++\ninline void rotate_rs_ls(AVL_Tree &p)\n{\n    rotate_ls_ls(p->rs);\n    rotate_rs_rs(p);\n}\n```\n\n**获取树的大小**\n\n```c++\ninline int get_size(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->size;\n}\n```\n\n**获取树的高度**\n\n```c++\ninline int get_height(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->height;\n}\n```\n\n**更新**\n\n```c++\ninline void update(AVL_Tree &p)\n{\n    p->size = get_size(p->ls) + get_size(p->rs) + p->freq;\n    p->height = max(get_height(p->ls), get_height(p->rs)) + 1;\n}\n```\n\n**插入**\n\n```c++\nvoid AVL_insert(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n    {\n        p = new AVL_node(x);\n        return;\n    }\n    if (p->value == x)//已经存在,频数+1\n    {\n        (p->freq)++;\n        update(p);\n        return;\n    }\n    if (p->value > x)\n    {\n        AVL_insert(p->ls, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)//插到左边,左边更高\n        {\n            if (x < p->ls->value)\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        AVL_insert(p->rs, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)//插到右边,右边更高\n        {\n            if (x > p->rs->value)\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    update(p);\n}\n```\n\n**删除数据**\n\n```c++\nvoid AVL_erase(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n        return;\n    if (p->value > x)\n    {\n        AVL_erase(p->ls, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)//删左边，右边高\n        {\n            if (get_height(p->rs->rs) >= get_height(p->rs->ls))//见代码后注释\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    else if (p->value < x)\n    {\n        AVL_erase(p->rs, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)\n        {\n            if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        if (p->freq > 1)\n        {\n            (p->freq)--;\n            update(p);\n            return;\n        }\n        if (p->ls && p->rs)\n        {\n            AVL_Tree q;\n            q = p->rs;\n            while (q->ls)\n                q = q->ls;\n            p->freq = q->freq;\n            p->value = q->value;\n            q->freq = 1; //删除q\n            AVL_erase(p->rs, q->value);\n            if (get_height(p->ls) - get_height(p->rs) == 2)\n            {\n                if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                    rotate_ls_ls(p);\n                else\n                    rotate_ls_rs(p);\n            }\n        }\n        else\n        {\n            AVL_Tree q;\n            q = p;\n            if (p->ls)\n                p = p->ls;\n            else if (p->rs)\n                p = p->rs;\n            else\n                p = nullptr;\n            delete q;\n            q = nullptr;\n        }\n    }\n    if (p == nullptr)\n        return;\n    update(p);\n}\n```\n\n第11行必须用$\\ge$，否则遇到如图的情况：\n\n![11](https://i.loli.net/2020/02/12/XuxmhoWtJvaCqwp.png)\n\n删去13后，先右旋再左旋，树仍然不是平衡的：\n\n![12](https://i.loli.net/2020/02/12/U4IajS9vukohHml.png)\n\n**通过值查找位次**\n\n```c++\nint get_rank(AVL_Tree p, int x)\n{\n    if (p->value == x)\n        return get_size(p->ls) + 1;\n    if (p->value > x)\n        return get_rank(p->ls, x);\n    return get_rank(p->rs, x) + get_size(p->ls) + p->freq;\n}\n```\n\n**通过位次查找值**\n\n```c++\nint get_val(AVL_Tree p, int r)\n{\n    if (get_size(p->ls) >= r)\n        return get_val(p->ls, r);\n    if (get_size(p->ls) + p->freq >= r)\n        return p->value;\n    return get_val(p->rs, r - get_size(p->ls) - p->freq);\n}\n```\n\n**查找前驱**\n\n```c++\nint get_pre(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(-inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->ls)\n            {\n                p = p->ls;\n                while (p->rs)\n                {\n                    p = p->rs;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value < x && p->value > ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\n```\n\n**查找后继**\n\n```c++\nint get_suf(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->rs)\n            {\n                p = p->rs;\n                while (p->ls)\n                {\n                    p = p->ls;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value > x && p->value < ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\n```\n\n**中序遍历**\n\n```c++\nvoid output(AVL_Tree p)\n{\n    if(p==nullptr)\n        return;\n    output(p->ls);\n    for (int i = 1; i <= p->freq;i++)\n        printf(\"%d \", p->value);\n    output(p->rs);\n}\n```\n\nAVL树的插入、删除、查找都是$\\log$级别的复杂度，其中AVL树的查询和其它平衡树相比会更有优势，但是AVL树代码量比较大，总体速度也很一般，可以分裂合并，可持久化，但是比较难写。\n\n终于写完了，真是不容易。\n\n![v2-28825ec8201c53892205bfd8b41c97dd_hd.jpg](https://i.loli.net/2020/02/12/1scLYZaiKRt25N3.jpg)\n\n\n","slug":"AVL_Tree","published":1,"updated":"2023-02-25T05:46:11.826Z","comments":1,"layout":"post","photos":[],"_id":"cmir5cbx400032cle30rzhlpf","content":"<h1 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h1><p>AVL树是最先发明的自平衡二叉查找树。AVL树高度平衡，其任意节点左右子树的高度差不超过1。同时它也拥有普通二叉查找树的性质，即每个节点左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，且不同节点的值均不同。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h1><p><strong>平衡因子：</strong>每个节点左子树和右子树的高度差。若所有节点平衡因子的绝对值均不超过1则平衡。</p>\n<p>使用一个结构体保存节点的键值、频数、以该点为根的树的树高和大小以及左右子树。当树不平衡时，可以通过旋转使树平衡。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">AVL_node</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> AVL_node *AVL_Tree;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">AVL_node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> value, height, freq, size;</span><br><span class=\"line\">    AVL_Tree ls, rs;</span><br><span class=\"line\">    <span class=\"built_in\">AVL_node</span>() : <span class=\"built_in\">value</span>(<span class=\"number\">0</span>), <span class=\"built_in\">height</span>(<span class=\"number\">1</span>), <span class=\"built_in\">freq</span>(<span class=\"number\">1</span>), <span class=\"built_in\">size</span>(<span class=\"number\">1</span>), <span class=\"built_in\">ls</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">rs</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">AVL_node</span>(<span class=\"type\">int</span> n) : <span class=\"built_in\">value</span>(n), <span class=\"built_in\">height</span>(<span class=\"number\">1</span>), <span class=\"built_in\">freq</span>(<span class=\"number\">1</span>), <span class=\"built_in\">size</span>(<span class=\"number\">1</span>), <span class=\"built_in\">ls</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">rs</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>不平衡情况1（左-左）：</strong></p>\n<p><img src=\"https://i.loli.net/2020/02/12/BYrixbevTfP8cR4.png\" alt=\"1\"></p>\n<p>在插入1之前，树是平衡的，但是9的左子树比右子树高度大。在9的左子树的左子树插入1（或2，4，5）后，树不平衡了，这种左子树更高且向左子树的左子树插入节点的情况可以通过一次右旋来使树平衡。右旋使原来不平衡的根节点的左子树成为根节点，而原来的根节点成为新的右子树，原来左子树的右子树成为原来的根节点的左子树。容易证明，旋转后依旧具有二叉查找树的性质。</p>\n<p><img src=\"https://i.loli.net/2020/02/12/mz46SiMWg5lTcfJ.png\" alt=\"2\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">rotate_ls_ls</span><span class=\"params\">(AVL_Tree &amp;p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    AVL_Tree q;</span><br><span class=\"line\">    q = p-&gt;ls;</span><br><span class=\"line\">    p-&gt;ls = q-&gt;rs;</span><br><span class=\"line\">    q-&gt;rs = p;</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(q);</span><br><span class=\"line\">    p = q;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不平衡情况2（右-右）：</strong></p>\n<p><img src=\"https://i.loli.net/2020/02/12/f5eClWkqbJ7XywL.png\" alt=\"3\"></p>\n<p>在插入13之前，树是平衡的，但是8的右子树比左子树高度大。在8的右子树的右子树插入13（或11）后，树不平衡了，这种右子树更高且向右子树的右子树插入节点的情况可以通过一次左旋来使树平衡。左旋使原来不平衡的根节点的右子树成为根节点，而原来的根节点成为新的左子树，原来右子树的左子树成为原来的根节点的右子树。同样，旋转后依旧具有二叉查找树的性质。</p>\n<p><img src=\"https://i.loli.net/2020/02/12/vhUgRs8SFj41HmV.png\" alt=\"4\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">rotate_rs_rs</span><span class=\"params\">(AVL_Tree &amp;p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    AVL_Tree q;</span><br><span class=\"line\">    q = p-&gt;rs;</span><br><span class=\"line\">    p-&gt;rs = q-&gt;ls;</span><br><span class=\"line\">    q-&gt;ls = p;</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(q);</span><br><span class=\"line\">    p = q;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不平衡情况3：（左-右）</strong></p>\n<p><img src=\"https://i.loli.net/2020/02/12/dRS1WHXAN7MlUhg.png\" alt=\"5\"></p>\n<p>这种情况是在左子树更高的树的左子树的右子树插入节点，需要先进行一次左旋，再进行一次右旋。</p>\n<p>左旋：</p>\n<p><img src=\"https://i.loli.net/2020/02/12/9S1xL8N2FIvhuZA.png\" alt=\"6\"></p>\n<p>右旋：</p>\n<p><img src=\"https://i.loli.net/2020/02/12/WgVKU1dbrEno9Ra.png\" alt=\"7\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">rotate_ls_rs</span><span class=\"params\">(AVL_Tree &amp;p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">rotate_rs_rs</span>(p-&gt;ls);</span><br><span class=\"line\">    <span class=\"built_in\">rotate_ls_ls</span>(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不平衡情况4：（右-左）</strong></p>\n<p>与情况3相反，先进行一次右旋，再进行一次左旋。</p>\n<p><img src=\"https://i.loli.net/2020/02/12/6KXb74TNLQUO1RB.png\" alt=\"8\"></p>\n<p>右旋：</p>\n<p><img src=\"https://i.loli.net/2020/02/12/V5JZvClKTzU8qcP.png\" alt=\"9\"></p>\n<p>左旋：</p>\n<p><img src=\"https://i.loli.net/2020/02/12/2h8ktCgqNnZR3IW.png\" alt=\"10\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">rotate_rs_ls</span><span class=\"params\">(AVL_Tree &amp;p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">rotate_ls_ls</span>(p-&gt;rs);</span><br><span class=\"line\">    <span class=\"built_in\">rotate_rs_rs</span>(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>获取树的大小</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">get_size</span><span class=\"params\">(AVL_Tree p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p-&gt;size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>获取树的高度</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">get_height</span><span class=\"params\">(AVL_Tree p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p-&gt;height;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>更新</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(AVL_Tree &amp;p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    p-&gt;size = <span class=\"built_in\">get_size</span>(p-&gt;ls) + <span class=\"built_in\">get_size</span>(p-&gt;rs) + p-&gt;freq;</span><br><span class=\"line\">    p-&gt;height = <span class=\"built_in\">max</span>(<span class=\"built_in\">get_height</span>(p-&gt;ls), <span class=\"built_in\">get_height</span>(p-&gt;rs)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>插入</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AVL_insert</span><span class=\"params\">(AVL_Tree &amp;p, <span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = <span class=\"keyword\">new</span> <span class=\"built_in\">AVL_node</span>(x);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;value == x)<span class=\"comment\">//已经存在,频数+1</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        (p-&gt;freq)++;</span><br><span class=\"line\">        <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;value &gt; x)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">AVL_insert</span>(p-&gt;ls, x);</span><br><span class=\"line\">        <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;ls) - <span class=\"built_in\">get_height</span>(p-&gt;rs) == <span class=\"number\">2</span>)<span class=\"comment\">//插到左边,左边更高</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &lt; p-&gt;ls-&gt;value)</span><br><span class=\"line\">                <span class=\"built_in\">rotate_ls_ls</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">rotate_ls_rs</span>(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">AVL_insert</span>(p-&gt;rs, x);</span><br><span class=\"line\">        <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;rs) - <span class=\"built_in\">get_height</span>(p-&gt;ls) == <span class=\"number\">2</span>)<span class=\"comment\">//插到右边,右边更高</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &gt; p-&gt;rs-&gt;value)</span><br><span class=\"line\">                <span class=\"built_in\">rotate_rs_rs</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">rotate_rs_ls</span>(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>删除数据</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AVL_erase</span><span class=\"params\">(AVL_Tree &amp;p, <span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;value &gt; x)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">AVL_erase</span>(p-&gt;ls, x);</span><br><span class=\"line\">        <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;rs) - <span class=\"built_in\">get_height</span>(p-&gt;ls) == <span class=\"number\">2</span>)<span class=\"comment\">//删左边，右边高</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;rs-&gt;rs) &gt;= <span class=\"built_in\">get_height</span>(p-&gt;rs-&gt;ls))<span class=\"comment\">//见代码后注释</span></span><br><span class=\"line\">                <span class=\"built_in\">rotate_rs_rs</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">rotate_rs_ls</span>(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p-&gt;value &lt; x)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">AVL_erase</span>(p-&gt;rs, x);</span><br><span class=\"line\">        <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;ls) - <span class=\"built_in\">get_height</span>(p-&gt;rs) == <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;ls-&gt;ls) &gt;= <span class=\"built_in\">get_height</span>(p-&gt;ls-&gt;rs))</span><br><span class=\"line\">                <span class=\"built_in\">rotate_ls_ls</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">rotate_ls_rs</span>(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;freq &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            (p-&gt;freq)--;</span><br><span class=\"line\">            <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;ls &amp;&amp; p-&gt;rs)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            AVL_Tree q;</span><br><span class=\"line\">            q = p-&gt;rs;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (q-&gt;ls)</span><br><span class=\"line\">                q = q-&gt;ls;</span><br><span class=\"line\">            p-&gt;freq = q-&gt;freq;</span><br><span class=\"line\">            p-&gt;value = q-&gt;value;</span><br><span class=\"line\">            q-&gt;freq = <span class=\"number\">1</span>; <span class=\"comment\">//删除q</span></span><br><span class=\"line\">            <span class=\"built_in\">AVL_erase</span>(p-&gt;rs, q-&gt;value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;ls) - <span class=\"built_in\">get_height</span>(p-&gt;rs) == <span class=\"number\">2</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;ls-&gt;ls) &gt;= <span class=\"built_in\">get_height</span>(p-&gt;ls-&gt;rs))</span><br><span class=\"line\">                    <span class=\"built_in\">rotate_ls_ls</span>(p);</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"built_in\">rotate_ls_rs</span>(p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            AVL_Tree q;</span><br><span class=\"line\">            q = p;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;ls)</span><br><span class=\"line\">                p = p-&gt;ls;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p-&gt;rs)</span><br><span class=\"line\">                p = p-&gt;rs;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                p = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> q;</span><br><span class=\"line\">            q = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第11行必须用$\\ge$，否则遇到如图的情况：</p>\n<p><img src=\"https://i.loli.net/2020/02/12/XuxmhoWtJvaCqwp.png\" alt=\"11\"></p>\n<p>删去13后，先右旋再左旋，树仍然不是平衡的：</p>\n<p><img src=\"https://i.loli.net/2020/02/12/U4IajS9vukohHml.png\" alt=\"12\"></p>\n<p><strong>通过值查找位次</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_rank</span><span class=\"params\">(AVL_Tree p, <span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;value == x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">get_size</span>(p-&gt;ls) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;value &gt; x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">get_rank</span>(p-&gt;ls, x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">get_rank</span>(p-&gt;rs, x) + <span class=\"built_in\">get_size</span>(p-&gt;ls) + p-&gt;freq;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>通过位次查找值</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_val</span><span class=\"params\">(AVL_Tree p, <span class=\"type\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">get_size</span>(p-&gt;ls) &gt;= r)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">get_val</span>(p-&gt;ls, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">get_size</span>(p-&gt;ls) + p-&gt;freq &gt;= r)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p-&gt;value;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">get_val</span>(p-&gt;rs, r - <span class=\"built_in\">get_size</span>(p-&gt;ls) - p-&gt;freq);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查找前驱</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_pre</span><span class=\"params\">(AVL_Tree p, <span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    AVL_Tree ans = <span class=\"keyword\">new</span> <span class=\"built_in\">AVL_node</span>(-inf);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;value == x)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;ls)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                p = p-&gt;ls;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (p-&gt;rs)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    p = p-&gt;rs;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;value &lt; x &amp;&amp; p-&gt;value &gt; ans-&gt;value)</span><br><span class=\"line\">            ans = p;</span><br><span class=\"line\">        p = p-&gt;value &lt; x ? p-&gt;rs : p-&gt;ls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans-&gt;value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查找后继</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_suf</span><span class=\"params\">(AVL_Tree p, <span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    AVL_Tree ans = <span class=\"keyword\">new</span> <span class=\"built_in\">AVL_node</span>(inf);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;value == x)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;rs)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                p = p-&gt;rs;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (p-&gt;ls)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    p = p-&gt;ls;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;value &gt; x &amp;&amp; p-&gt;value &lt; ans-&gt;value)</span><br><span class=\"line\">            ans = p;</span><br><span class=\"line\">        p = p-&gt;value &lt; x ? p-&gt;rs : p-&gt;ls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans-&gt;value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>中序遍历</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">output</span><span class=\"params\">(AVL_Tree p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">output</span>(p-&gt;ls);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= p-&gt;freq;i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, p-&gt;value);</span><br><span class=\"line\">    <span class=\"built_in\">output</span>(p-&gt;rs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AVL树的插入、删除、查找都是$\\log$级别的复杂度，其中AVL树的查询和其它平衡树相比会更有优势，但是AVL树代码量比较大，总体速度也很一般，可以分裂合并，可持久化，但是比较难写。</p>\n<p>终于写完了，真是不容易。</p>\n<p><img src=\"https://i.loli.net/2020/02/12/1scLYZaiKRt25N3.jpg\" alt=\"v2-28825ec8201c53892205bfd8b41c97dd_hd.jpg\"></p>\n","excerpt":"<h1 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h1><p>AVL树是最先发明的自平衡二叉查找树。AVL树高度平衡，其任意节点左右子树的高度差不超过1。同时它也拥有普通二叉查找树的性质，即每个节点左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，且不同节点的值均不同。</p>","more":"<h1 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h1><p><strong>平衡因子：</strong>每个节点左子树和右子树的高度差。若所有节点平衡因子的绝对值均不超过1则平衡。</p>\n<p>使用一个结构体保存节点的键值、频数、以该点为根的树的树高和大小以及左右子树。当树不平衡时，可以通过旋转使树平衡。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">AVL_node</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> AVL_node *AVL_Tree;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">AVL_node</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> value, height, freq, size;</span><br><span class=\"line\">    AVL_Tree ls, rs;</span><br><span class=\"line\">    <span class=\"built_in\">AVL_node</span>() : <span class=\"built_in\">value</span>(<span class=\"number\">0</span>), <span class=\"built_in\">height</span>(<span class=\"number\">1</span>), <span class=\"built_in\">freq</span>(<span class=\"number\">1</span>), <span class=\"built_in\">size</span>(<span class=\"number\">1</span>), <span class=\"built_in\">ls</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">rs</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">AVL_node</span>(<span class=\"type\">int</span> n) : <span class=\"built_in\">value</span>(n), <span class=\"built_in\">height</span>(<span class=\"number\">1</span>), <span class=\"built_in\">freq</span>(<span class=\"number\">1</span>), <span class=\"built_in\">size</span>(<span class=\"number\">1</span>), <span class=\"built_in\">ls</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">rs</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>不平衡情况1（左-左）：</strong></p>\n<p><img src=\"https://i.loli.net/2020/02/12/BYrixbevTfP8cR4.png\" alt=\"1\"></p>\n<p>在插入1之前，树是平衡的，但是9的左子树比右子树高度大。在9的左子树的左子树插入1（或2，4，5）后，树不平衡了，这种左子树更高且向左子树的左子树插入节点的情况可以通过一次右旋来使树平衡。右旋使原来不平衡的根节点的左子树成为根节点，而原来的根节点成为新的右子树，原来左子树的右子树成为原来的根节点的左子树。容易证明，旋转后依旧具有二叉查找树的性质。</p>\n<p><img src=\"https://i.loli.net/2020/02/12/mz46SiMWg5lTcfJ.png\" alt=\"2\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">rotate_ls_ls</span><span class=\"params\">(AVL_Tree &amp;p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    AVL_Tree q;</span><br><span class=\"line\">    q = p-&gt;ls;</span><br><span class=\"line\">    p-&gt;ls = q-&gt;rs;</span><br><span class=\"line\">    q-&gt;rs = p;</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(q);</span><br><span class=\"line\">    p = q;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不平衡情况2（右-右）：</strong></p>\n<p><img src=\"https://i.loli.net/2020/02/12/f5eClWkqbJ7XywL.png\" alt=\"3\"></p>\n<p>在插入13之前，树是平衡的，但是8的右子树比左子树高度大。在8的右子树的右子树插入13（或11）后，树不平衡了，这种右子树更高且向右子树的右子树插入节点的情况可以通过一次左旋来使树平衡。左旋使原来不平衡的根节点的右子树成为根节点，而原来的根节点成为新的左子树，原来右子树的左子树成为原来的根节点的右子树。同样，旋转后依旧具有二叉查找树的性质。</p>\n<p><img src=\"https://i.loli.net/2020/02/12/vhUgRs8SFj41HmV.png\" alt=\"4\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">rotate_rs_rs</span><span class=\"params\">(AVL_Tree &amp;p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    AVL_Tree q;</span><br><span class=\"line\">    q = p-&gt;rs;</span><br><span class=\"line\">    p-&gt;rs = q-&gt;ls;</span><br><span class=\"line\">    q-&gt;ls = p;</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(q);</span><br><span class=\"line\">    p = q;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不平衡情况3：（左-右）</strong></p>\n<p><img src=\"https://i.loli.net/2020/02/12/dRS1WHXAN7MlUhg.png\" alt=\"5\"></p>\n<p>这种情况是在左子树更高的树的左子树的右子树插入节点，需要先进行一次左旋，再进行一次右旋。</p>\n<p>左旋：</p>\n<p><img src=\"https://i.loli.net/2020/02/12/9S1xL8N2FIvhuZA.png\" alt=\"6\"></p>\n<p>右旋：</p>\n<p><img src=\"https://i.loli.net/2020/02/12/WgVKU1dbrEno9Ra.png\" alt=\"7\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">rotate_ls_rs</span><span class=\"params\">(AVL_Tree &amp;p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">rotate_rs_rs</span>(p-&gt;ls);</span><br><span class=\"line\">    <span class=\"built_in\">rotate_ls_ls</span>(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不平衡情况4：（右-左）</strong></p>\n<p>与情况3相反，先进行一次右旋，再进行一次左旋。</p>\n<p><img src=\"https://i.loli.net/2020/02/12/6KXb74TNLQUO1RB.png\" alt=\"8\"></p>\n<p>右旋：</p>\n<p><img src=\"https://i.loli.net/2020/02/12/V5JZvClKTzU8qcP.png\" alt=\"9\"></p>\n<p>左旋：</p>\n<p><img src=\"https://i.loli.net/2020/02/12/2h8ktCgqNnZR3IW.png\" alt=\"10\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">rotate_rs_ls</span><span class=\"params\">(AVL_Tree &amp;p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">rotate_ls_ls</span>(p-&gt;rs);</span><br><span class=\"line\">    <span class=\"built_in\">rotate_rs_rs</span>(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>获取树的大小</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">get_size</span><span class=\"params\">(AVL_Tree p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p-&gt;size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>获取树的高度</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">get_height</span><span class=\"params\">(AVL_Tree p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p-&gt;height;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>更新</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(AVL_Tree &amp;p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    p-&gt;size = <span class=\"built_in\">get_size</span>(p-&gt;ls) + <span class=\"built_in\">get_size</span>(p-&gt;rs) + p-&gt;freq;</span><br><span class=\"line\">    p-&gt;height = <span class=\"built_in\">max</span>(<span class=\"built_in\">get_height</span>(p-&gt;ls), <span class=\"built_in\">get_height</span>(p-&gt;rs)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>插入</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AVL_insert</span><span class=\"params\">(AVL_Tree &amp;p, <span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = <span class=\"keyword\">new</span> <span class=\"built_in\">AVL_node</span>(x);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;value == x)<span class=\"comment\">//已经存在,频数+1</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        (p-&gt;freq)++;</span><br><span class=\"line\">        <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;value &gt; x)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">AVL_insert</span>(p-&gt;ls, x);</span><br><span class=\"line\">        <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;ls) - <span class=\"built_in\">get_height</span>(p-&gt;rs) == <span class=\"number\">2</span>)<span class=\"comment\">//插到左边,左边更高</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &lt; p-&gt;ls-&gt;value)</span><br><span class=\"line\">                <span class=\"built_in\">rotate_ls_ls</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">rotate_ls_rs</span>(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">AVL_insert</span>(p-&gt;rs, x);</span><br><span class=\"line\">        <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;rs) - <span class=\"built_in\">get_height</span>(p-&gt;ls) == <span class=\"number\">2</span>)<span class=\"comment\">//插到右边,右边更高</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &gt; p-&gt;rs-&gt;value)</span><br><span class=\"line\">                <span class=\"built_in\">rotate_rs_rs</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">rotate_rs_ls</span>(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>删除数据</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">AVL_erase</span><span class=\"params\">(AVL_Tree &amp;p, <span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;value &gt; x)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">AVL_erase</span>(p-&gt;ls, x);</span><br><span class=\"line\">        <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;rs) - <span class=\"built_in\">get_height</span>(p-&gt;ls) == <span class=\"number\">2</span>)<span class=\"comment\">//删左边，右边高</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;rs-&gt;rs) &gt;= <span class=\"built_in\">get_height</span>(p-&gt;rs-&gt;ls))<span class=\"comment\">//见代码后注释</span></span><br><span class=\"line\">                <span class=\"built_in\">rotate_rs_rs</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">rotate_rs_ls</span>(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p-&gt;value &lt; x)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">AVL_erase</span>(p-&gt;rs, x);</span><br><span class=\"line\">        <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;ls) - <span class=\"built_in\">get_height</span>(p-&gt;rs) == <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;ls-&gt;ls) &gt;= <span class=\"built_in\">get_height</span>(p-&gt;ls-&gt;rs))</span><br><span class=\"line\">                <span class=\"built_in\">rotate_ls_ls</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">rotate_ls_rs</span>(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;freq &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            (p-&gt;freq)--;</span><br><span class=\"line\">            <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;ls &amp;&amp; p-&gt;rs)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            AVL_Tree q;</span><br><span class=\"line\">            q = p-&gt;rs;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (q-&gt;ls)</span><br><span class=\"line\">                q = q-&gt;ls;</span><br><span class=\"line\">            p-&gt;freq = q-&gt;freq;</span><br><span class=\"line\">            p-&gt;value = q-&gt;value;</span><br><span class=\"line\">            q-&gt;freq = <span class=\"number\">1</span>; <span class=\"comment\">//删除q</span></span><br><span class=\"line\">            <span class=\"built_in\">AVL_erase</span>(p-&gt;rs, q-&gt;value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;ls) - <span class=\"built_in\">get_height</span>(p-&gt;rs) == <span class=\"number\">2</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">get_height</span>(p-&gt;ls-&gt;ls) &gt;= <span class=\"built_in\">get_height</span>(p-&gt;ls-&gt;rs))</span><br><span class=\"line\">                    <span class=\"built_in\">rotate_ls_ls</span>(p);</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"built_in\">rotate_ls_rs</span>(p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            AVL_Tree q;</span><br><span class=\"line\">            q = p;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;ls)</span><br><span class=\"line\">                p = p-&gt;ls;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p-&gt;rs)</span><br><span class=\"line\">                p = p-&gt;rs;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                p = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> q;</span><br><span class=\"line\">            q = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第11行必须用$\\ge$，否则遇到如图的情况：</p>\n<p><img src=\"https://i.loli.net/2020/02/12/XuxmhoWtJvaCqwp.png\" alt=\"11\"></p>\n<p>删去13后，先右旋再左旋，树仍然不是平衡的：</p>\n<p><img src=\"https://i.loli.net/2020/02/12/U4IajS9vukohHml.png\" alt=\"12\"></p>\n<p><strong>通过值查找位次</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_rank</span><span class=\"params\">(AVL_Tree p, <span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;value == x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">get_size</span>(p-&gt;ls) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;value &gt; x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">get_rank</span>(p-&gt;ls, x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">get_rank</span>(p-&gt;rs, x) + <span class=\"built_in\">get_size</span>(p-&gt;ls) + p-&gt;freq;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>通过位次查找值</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_val</span><span class=\"params\">(AVL_Tree p, <span class=\"type\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">get_size</span>(p-&gt;ls) &gt;= r)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">get_val</span>(p-&gt;ls, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">get_size</span>(p-&gt;ls) + p-&gt;freq &gt;= r)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p-&gt;value;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">get_val</span>(p-&gt;rs, r - <span class=\"built_in\">get_size</span>(p-&gt;ls) - p-&gt;freq);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查找前驱</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_pre</span><span class=\"params\">(AVL_Tree p, <span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    AVL_Tree ans = <span class=\"keyword\">new</span> <span class=\"built_in\">AVL_node</span>(-inf);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;value == x)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;ls)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                p = p-&gt;ls;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (p-&gt;rs)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    p = p-&gt;rs;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;value &lt; x &amp;&amp; p-&gt;value &gt; ans-&gt;value)</span><br><span class=\"line\">            ans = p;</span><br><span class=\"line\">        p = p-&gt;value &lt; x ? p-&gt;rs : p-&gt;ls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans-&gt;value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查找后继</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_suf</span><span class=\"params\">(AVL_Tree p, <span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    AVL_Tree ans = <span class=\"keyword\">new</span> <span class=\"built_in\">AVL_node</span>(inf);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;value == x)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p-&gt;rs)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                p = p-&gt;rs;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (p-&gt;ls)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    p = p-&gt;ls;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p-&gt;value &gt; x &amp;&amp; p-&gt;value &lt; ans-&gt;value)</span><br><span class=\"line\">            ans = p;</span><br><span class=\"line\">        p = p-&gt;value &lt; x ? p-&gt;rs : p-&gt;ls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans-&gt;value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>中序遍历</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">output</span><span class=\"params\">(AVL_Tree p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(p==<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">output</span>(p-&gt;ls);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= p-&gt;freq;i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, p-&gt;value);</span><br><span class=\"line\">    <span class=\"built_in\">output</span>(p-&gt;rs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AVL树的插入、删除、查找都是$\\log$级别的复杂度，其中AVL树的查询和其它平衡树相比会更有优势，但是AVL树代码量比较大，总体速度也很一般，可以分裂合并，可持久化，但是比较难写。</p>\n<p>终于写完了，真是不容易。</p>\n<p><img src=\"https://i.loli.net/2020/02/12/1scLYZaiKRt25N3.jpg\" alt=\"v2-28825ec8201c53892205bfd8b41c97dd_hd.jpg\"></p>"},{"title":"2022 HRBUST Summer Trainning","date":"2022-08-07T16:00:00.000Z","math":true,"_content":"\nMediocre problems. \n\n<!--more-->\n\n[link](https://ac.nowcoder.com/acm/contest/37895)\n\n# A\n\n统计一下连续段，然后前缀和处理即可。\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define endl '\\n'\n#define pb push_back\nvoid solve() {\n    string s;\n    cin >> s;\n    vector<ll> a;\n    int cnt = 0;\n    for (auto &&c : s) {\n        if (c == '1')\n            cnt++;\n        else if (cnt)\n            a.pb(cnt), cnt = 0;\n    }\n    if (cnt)\n        a.pb(cnt);\n    for (auto &&i : a)\n        i = i * i;\n    int n = a.size();\n    vector<ll> p0(n + 1), p1(n + 1);\n    for (int i = 0; i < n; ++i) {\n        if (i & 1) {\n            p0[i + 1] = -a[i];\n            p1[i + 1] = a[i];\n        } else {\n            p0[i + 1] = a[i];\n            p1[i + 1] = -a[i];\n        }\n        p0[i + 1] += p0[i];\n        p1[i + 1] += p1[i];\n    }\n    ll mxp0 = p0[n], mxp1 = p1[n];\n    ll ans = 0;\n    for (int i = n - 1; i >= 0; --i) {\n        ans = max({ans, mxp0 - p0[i], mxp1 - p1[i]});\n        mxp0 = max(mxp0, p0[i]);\n        mxp1 = max(mxp1, p1[i]);\n    }\n    cout << ans << endl;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# B\n\n容易发现后面几位是没用的，所以就相当于不能异或出 $0$。经典双指针。\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define endl '\\n'\n#define pb push_back\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for (auto &i : a) {\n        cin >> i;\n        i >>= k;\n    }\n    int ans = 0;\n    unordered_map<int, int> mp;\n    int l = 0, r = 0;\n    for (; l < n; ++l) {\n        while (r < n) {\n            if (!mp[a[r]]) {\n                mp[a[r]]++;\n                r++;\n            } else {\n                break;\n            }\n        }\n        ans = max(ans, r - l);\n        mp[a[l]]--;\n    }\n    cout << ans << endl;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# C\n\n比较经典的二分答案+树形dp。dp 的状态是以当前节点为根节点形成的连通块内两种可乐的 $4$ 种奇偶性的组合各自的最大值。细节比较多，懒得写了。\n\n# D\n\n暴力 BFS。懒得写了。\n\n# E\n\n大概是线段树上二分来模拟这个过程。懒得写了。\n\n# F\n\n当最大值为 $m$ 时，前面的 $n-1$ 个位置需要填入 $[0,m]$ 中的数，就相当于将 $n-1$ 个相同的球放进 $m+1$ 个不同的箱子里，允许出现空箱。\n\n不允许出现空箱的时候可以用隔板法，就是在 $n-2$ 个空隙里选 $m$ 个位置插入隔板。那么允许空箱的时候就在每个箱子里加一个虚拟的球，就转化为了之前的问题，答案就是 $\\binom{n+m-1}{m}$。\n\n预处理组合数后枚举 $m$，复杂度 $O(n+k)$。\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define endl '\\n'\n#define pb push_back\nconst ll mod = 1e9 + 7;\nconst int maxn = 2e6 + 5;\nll qpow(ll b, ll k) {\n    ll ret = 1;\n    while (k) {\n        if (k & 1)\n            ret = ret * b % mod;\n        b = b * b % mod;\n        k /= 2;\n    }\n    return ret;\n}\nll pinv(ll x) { return qpow(x, mod - 2); }\nll fact[maxn], ifact[maxn];\nvoid init_fact(int n) {\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i)\n        fact[i] = fact[i - 1] * i % mod;\n    ifact[n] = pinv(fact[n]);\n    for (int i = n - 1; i >= 0; --i)\n        ifact[i] = ifact[i + 1] * (i + 1) % mod;\n}\nll C(int n, int m) { \n    return fact[n] * ifact[n - m] % mod * ifact[m] % mod; \n}\nvoid solve() {\n    ll n, k;\n    cin >> n >> k;\n    init_fact(n + k);\n    ll ans = 0;\n    for (int i = 1; i <= k; ++i) {\n        ans += C(n + i - 1, i) * i % mod;\n        ans %= mod;\n    }\n    cout << ans << endl;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# G\n\n贪心。\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define endl '\\n'\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    int l, r;\n    cin >> l >> r;\n    int ans = 0;\n    for (auto &&i : a) {\n        if (l <= i && i <= r)\n            ans = max(ans, i);\n    }\n    cout << (ans + r) << endl;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# H\n\n令 $p_i$ 表示第 $i$ 天结束的概率，$q_i=\\prod_{j\\lt i}(1-p_j)$。\n\n先列出期望的式子：\n\n$$\nE= \\sum_{i=1}^{\\infty}p_iq_i i\n$$\n\n然后根据 $p_i$ 的周期性，每 $n$ 天分一段。令 $E_n=\\sum_{i=1}^n p_iq_i i$，$P_n=\\sum_{i=1}^n p_iq_i$：\n\n$$\nE= \\sum_{i=0}^{\\infty}q_n^i (E_n+inP_n)\\\\\n(1-q_n)E=E_n+nP_n\\sum_{i=1}^{\\infty}q_n^i \\\\\nE=\\frac{E_n}{1-q_n}+\\frac{nP_nq_n}{(1-q_n)^2}\n$$\n\n这样就可以 $O(n)$ 求出来了。\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define endl '\\n'\n#define pb push_back\nconst ll mod = 1e9 + 7;\nconst int maxn = 1e5 + 5;\nll qpow(ll b, ll k) {\n    ll ret = 1;\n    while (k) {\n        if (k & 1)\n            ret = ret * b % mod;\n        b = b * b % mod;\n        k /= 2;\n    }\n    return ret;\n}\nll pinv(ll x) { return qpow(x, mod - 2); }\nll a[maxn];\nvoid solve() {\n    ll n;\n    cin >> n;\n    ll inv100 = pinv(100);\n    for (int i = 1; i <= n; ++i) {\n        cin >> a[i];\n        a[i] = a[i] * inv100 % mod;\n    }\n    ll q = 1, p = 0, E = 0;\n    for (int i = 1; i <= n; ++i) {\n        p = (p + q * a[i] % mod) % mod;\n        E = (E + q * a[i] % mod * i % mod) % mod;\n        q = q * (1 + mod - a[i]) % mod;\n    }\n    ll tmp = pinv((1 + mod - q) % mod);\n    ll ans = E * tmp % mod + n * p % mod * q % mod * tmp % mod * tmp % mod;\n    cout << ans % mod << endl;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n感觉这种难度的题放在校赛或者个人训练赛还是很合适的。","source":"_posts/HRBUST2022.md","raw":"---\ntitle: 2022 HRBUST Summer Trainning\ndate: 2022-08-08\ntag: [contest]\ncategory: [Competitive Programming]\nmath: true\n---\n\nMediocre problems. \n\n<!--more-->\n\n[link](https://ac.nowcoder.com/acm/contest/37895)\n\n# A\n\n统计一下连续段，然后前缀和处理即可。\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define endl '\\n'\n#define pb push_back\nvoid solve() {\n    string s;\n    cin >> s;\n    vector<ll> a;\n    int cnt = 0;\n    for (auto &&c : s) {\n        if (c == '1')\n            cnt++;\n        else if (cnt)\n            a.pb(cnt), cnt = 0;\n    }\n    if (cnt)\n        a.pb(cnt);\n    for (auto &&i : a)\n        i = i * i;\n    int n = a.size();\n    vector<ll> p0(n + 1), p1(n + 1);\n    for (int i = 0; i < n; ++i) {\n        if (i & 1) {\n            p0[i + 1] = -a[i];\n            p1[i + 1] = a[i];\n        } else {\n            p0[i + 1] = a[i];\n            p1[i + 1] = -a[i];\n        }\n        p0[i + 1] += p0[i];\n        p1[i + 1] += p1[i];\n    }\n    ll mxp0 = p0[n], mxp1 = p1[n];\n    ll ans = 0;\n    for (int i = n - 1; i >= 0; --i) {\n        ans = max({ans, mxp0 - p0[i], mxp1 - p1[i]});\n        mxp0 = max(mxp0, p0[i]);\n        mxp1 = max(mxp1, p1[i]);\n    }\n    cout << ans << endl;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# B\n\n容易发现后面几位是没用的，所以就相当于不能异或出 $0$。经典双指针。\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define endl '\\n'\n#define pb push_back\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for (auto &i : a) {\n        cin >> i;\n        i >>= k;\n    }\n    int ans = 0;\n    unordered_map<int, int> mp;\n    int l = 0, r = 0;\n    for (; l < n; ++l) {\n        while (r < n) {\n            if (!mp[a[r]]) {\n                mp[a[r]]++;\n                r++;\n            } else {\n                break;\n            }\n        }\n        ans = max(ans, r - l);\n        mp[a[l]]--;\n    }\n    cout << ans << endl;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# C\n\n比较经典的二分答案+树形dp。dp 的状态是以当前节点为根节点形成的连通块内两种可乐的 $4$ 种奇偶性的组合各自的最大值。细节比较多，懒得写了。\n\n# D\n\n暴力 BFS。懒得写了。\n\n# E\n\n大概是线段树上二分来模拟这个过程。懒得写了。\n\n# F\n\n当最大值为 $m$ 时，前面的 $n-1$ 个位置需要填入 $[0,m]$ 中的数，就相当于将 $n-1$ 个相同的球放进 $m+1$ 个不同的箱子里，允许出现空箱。\n\n不允许出现空箱的时候可以用隔板法，就是在 $n-2$ 个空隙里选 $m$ 个位置插入隔板。那么允许空箱的时候就在每个箱子里加一个虚拟的球，就转化为了之前的问题，答案就是 $\\binom{n+m-1}{m}$。\n\n预处理组合数后枚举 $m$，复杂度 $O(n+k)$。\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define endl '\\n'\n#define pb push_back\nconst ll mod = 1e9 + 7;\nconst int maxn = 2e6 + 5;\nll qpow(ll b, ll k) {\n    ll ret = 1;\n    while (k) {\n        if (k & 1)\n            ret = ret * b % mod;\n        b = b * b % mod;\n        k /= 2;\n    }\n    return ret;\n}\nll pinv(ll x) { return qpow(x, mod - 2); }\nll fact[maxn], ifact[maxn];\nvoid init_fact(int n) {\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i)\n        fact[i] = fact[i - 1] * i % mod;\n    ifact[n] = pinv(fact[n]);\n    for (int i = n - 1; i >= 0; --i)\n        ifact[i] = ifact[i + 1] * (i + 1) % mod;\n}\nll C(int n, int m) { \n    return fact[n] * ifact[n - m] % mod * ifact[m] % mod; \n}\nvoid solve() {\n    ll n, k;\n    cin >> n >> k;\n    init_fact(n + k);\n    ll ans = 0;\n    for (int i = 1; i <= k; ++i) {\n        ans += C(n + i - 1, i) * i % mod;\n        ans %= mod;\n    }\n    cout << ans << endl;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# G\n\n贪心。\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define endl '\\n'\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    int l, r;\n    cin >> l >> r;\n    int ans = 0;\n    for (auto &&i : a) {\n        if (l <= i && i <= r)\n            ans = max(ans, i);\n    }\n    cout << (ans + r) << endl;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n# H\n\n令 $p_i$ 表示第 $i$ 天结束的概率，$q_i=\\prod_{j\\lt i}(1-p_j)$。\n\n先列出期望的式子：\n\n$$\nE= \\sum_{i=1}^{\\infty}p_iq_i i\n$$\n\n然后根据 $p_i$ 的周期性，每 $n$ 天分一段。令 $E_n=\\sum_{i=1}^n p_iq_i i$，$P_n=\\sum_{i=1}^n p_iq_i$：\n\n$$\nE= \\sum_{i=0}^{\\infty}q_n^i (E_n+inP_n)\\\\\n(1-q_n)E=E_n+nP_n\\sum_{i=1}^{\\infty}q_n^i \\\\\nE=\\frac{E_n}{1-q_n}+\\frac{nP_nq_n}{(1-q_n)^2}\n$$\n\n这样就可以 $O(n)$ 求出来了。\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define endl '\\n'\n#define pb push_back\nconst ll mod = 1e9 + 7;\nconst int maxn = 1e5 + 5;\nll qpow(ll b, ll k) {\n    ll ret = 1;\n    while (k) {\n        if (k & 1)\n            ret = ret * b % mod;\n        b = b * b % mod;\n        k /= 2;\n    }\n    return ret;\n}\nll pinv(ll x) { return qpow(x, mod - 2); }\nll a[maxn];\nvoid solve() {\n    ll n;\n    cin >> n;\n    ll inv100 = pinv(100);\n    for (int i = 1; i <= n; ++i) {\n        cin >> a[i];\n        a[i] = a[i] * inv100 % mod;\n    }\n    ll q = 1, p = 0, E = 0;\n    for (int i = 1; i <= n; ++i) {\n        p = (p + q * a[i] % mod) % mod;\n        E = (E + q * a[i] % mod * i % mod) % mod;\n        q = q * (1 + mod - a[i]) % mod;\n    }\n    ll tmp = pinv((1 + mod - q) % mod);\n    ll ans = E * tmp % mod + n * p % mod * q % mod * tmp % mod * tmp % mod;\n    cout << ans % mod << endl;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T = 1;\n    // cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}\n```\n\n感觉这种难度的题放在校赛或者个人训练赛还是很合适的。","slug":"HRBUST2022","published":1,"updated":"2023-02-25T05:46:11.827Z","comments":1,"layout":"post","photos":[],"_id":"cmir5cbx600062cle080kfzdd","content":"<p>Mediocre problems. </p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://ac.nowcoder.com/acm/contest/37895\">link</a></p>\n<h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h1><p>统计一下连续段，然后前缀和处理即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> endl <span class=\"string\">&#x27;\\n&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin &gt;&gt; s;</span><br><span class=\"line\">    vector&lt;ll&gt; a;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;c : s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cnt)</span><br><span class=\"line\">            a.<span class=\"built_in\">pb</span>(cnt), cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cnt)</span><br><span class=\"line\">        a.<span class=\"built_in\">pb</span>(cnt);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;i : a)</span><br><span class=\"line\">        i = i * i;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = a.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">p0</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span>, <span class=\"title\">p1</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            p0[i + <span class=\"number\">1</span>] = -a[i];</span><br><span class=\"line\">            p1[i + <span class=\"number\">1</span>] = a[i];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            p0[i + <span class=\"number\">1</span>] = a[i];</span><br><span class=\"line\">            p1[i + <span class=\"number\">1</span>] = -a[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p0[i + <span class=\"number\">1</span>] += p0[i];</span><br><span class=\"line\">        p1[i + <span class=\"number\">1</span>] += p1[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll mxp0 = p0[n], mxp1 = p1[n];</span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(&#123;ans, mxp0 - p0[i], mxp1 - p1[i]&#125;);</span><br><span class=\"line\">        mxp0 = <span class=\"built_in\">max</span>(mxp0, p0[i]);</span><br><span class=\"line\">        mxp1 = <span class=\"built_in\">max</span>(mxp1, p1[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>), cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin &gt;&gt; T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h1><p>容易发现后面几位是没用的，所以就相当于不能异或出 $0$。经典双指针。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> endl <span class=\"string\">&#x27;\\n&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, k;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;i : a) &#123;</span><br><span class=\"line\">        cin &gt;&gt; i;</span><br><span class=\"line\">        i &gt;&gt;= k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">    <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; l &lt; n; ++l) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (r &lt; n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!mp[a[r]]) &#123;</span><br><span class=\"line\">                mp[a[r]]++;</span><br><span class=\"line\">                r++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, r - l);</span><br><span class=\"line\">        mp[a[l]]--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>), cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin &gt;&gt; T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h1><p>比较经典的二分答案+树形dp。dp 的状态是以当前节点为根节点形成的连通块内两种可乐的 $4$ 种奇偶性的组合各自的最大值。细节比较多，懒得写了。</p>\n<h1 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h1><p>暴力 BFS。懒得写了。</p>\n<h1 id=\"E\"><a href=\"#E\" class=\"headerlink\" title=\"E\"></a>E</h1><p>大概是线段树上二分来模拟这个过程。懒得写了。</p>\n<h1 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h1><p>当最大值为 $m$ 时，前面的 $n-1$ 个位置需要填入 $[0,m]$ 中的数，就相当于将 $n-1$ 个相同的球放进 $m+1$ 个不同的箱子里，允许出现空箱。</p>\n<p>不允许出现空箱的时候可以用隔板法，就是在 $n-2$ 个空隙里选 $m$ 个位置插入隔板。那么允许空箱的时候就在每个箱子里加一个虚拟的球，就转化为了之前的问题，答案就是 $\\binom{n+m-1}{m}$。</p>\n<p>预处理组合数后枚举 $m$，复杂度 $O(n+k)$。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> endl <span class=\"string\">&#x27;\\n&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"type\">const</span> ll mod = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">2e6</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qpow</span><span class=\"params\">(ll b, ll k)</span> </span>&#123;</span><br><span class=\"line\">    ll ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">            ret = ret * b % mod;</span><br><span class=\"line\">        b = b * b % mod;</span><br><span class=\"line\">        k /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">pinv</span><span class=\"params\">(ll x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">qpow</span>(x, mod - <span class=\"number\">2</span>); &#125;</span><br><span class=\"line\">ll fact[maxn], ifact[maxn];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init_fact</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    fact[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i)</span><br><span class=\"line\">        fact[i] = fact[i - <span class=\"number\">1</span>] * i % mod;</span><br><span class=\"line\">    ifact[n] = <span class=\"built_in\">pinv</span>(fact[n]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">        ifact[i] = ifact[i + <span class=\"number\">1</span>] * (i + <span class=\"number\">1</span>) % mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">C</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> m)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> fact[n] * ifact[n - m] % mod * ifact[m] % mod; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ll n, k;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"built_in\">init_fact</span>(n + k);</span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= k; ++i) &#123;</span><br><span class=\"line\">        ans += <span class=\"built_in\">C</span>(n + i - <span class=\"number\">1</span>, i) * i % mod;</span><br><span class=\"line\">        ans %= mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>), cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin &gt;&gt; T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h1><p>贪心。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> endl <span class=\"string\">&#x27;\\n&#x27;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">        cin &gt;&gt; a[i];</span><br><span class=\"line\">    <span class=\"type\">int</span> l, r;</span><br><span class=\"line\">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;i : a) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt;= i &amp;&amp; i &lt;= r)</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; (ans + r) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>), cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin &gt;&gt; T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"H\"><a href=\"#H\" class=\"headerlink\" title=\"H\"></a>H</h1><p>令 $p_i$ 表示第 $i$ 天结束的概率，$q_i&#x3D;\\prod_{j\\lt i}(1-p_j)$。</p>\n<p>先列出期望的式子：</p>\n<p>$$<br>E&#x3D; \\sum_{i&#x3D;1}^{\\infty}p_iq_i i<br>$$</p>\n<p>然后根据 $p_i$ 的周期性，每 $n$ 天分一段。令 $E_n&#x3D;\\sum_{i&#x3D;1}^n p_iq_i i$，$P_n&#x3D;\\sum_{i&#x3D;1}^n p_iq_i$：</p>\n<p>$$<br>E&#x3D; \\sum_{i&#x3D;0}^{\\infty}q_n^i (E_n+inP_n)\\<br>(1-q_n)E&#x3D;E_n+nP_n\\sum_{i&#x3D;1}^{\\infty}q_n^i \\<br>E&#x3D;\\frac{E_n}{1-q_n}+\\frac{nP_nq_n}{(1-q_n)^2}<br>$$</p>\n<p>这样就可以 $O(n)$ 求出来了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> endl <span class=\"string\">&#x27;\\n&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"type\">const</span> ll mod = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qpow</span><span class=\"params\">(ll b, ll k)</span> </span>&#123;</span><br><span class=\"line\">    ll ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">            ret = ret * b % mod;</span><br><span class=\"line\">        b = b * b % mod;</span><br><span class=\"line\">        k /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">pinv</span><span class=\"params\">(ll x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">qpow</span>(x, mod - <span class=\"number\">2</span>); &#125;</span><br><span class=\"line\">ll a[maxn];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ll n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    ll inv100 = <span class=\"built_in\">pinv</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i];</span><br><span class=\"line\">        a[i] = a[i] * inv100 % mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll q = <span class=\"number\">1</span>, p = <span class=\"number\">0</span>, E = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        p = (p + q * a[i] % mod) % mod;</span><br><span class=\"line\">        E = (E + q * a[i] % mod * i % mod) % mod;</span><br><span class=\"line\">        q = q * (<span class=\"number\">1</span> + mod - a[i]) % mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll tmp = <span class=\"built_in\">pinv</span>((<span class=\"number\">1</span> + mod - q) % mod);</span><br><span class=\"line\">    ll ans = E * tmp % mod + n * p % mod * q % mod * tmp % mod * tmp % mod;</span><br><span class=\"line\">    cout &lt;&lt; ans % mod &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>), cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin &gt;&gt; T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>感觉这种难度的题放在校赛或者个人训练赛还是很合适的。</p>\n","excerpt":"<p>Mediocre problems. </p>","more":"<p><a href=\"https://ac.nowcoder.com/acm/contest/37895\">link</a></p>\n<h1 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h1><p>统计一下连续段，然后前缀和处理即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> endl <span class=\"string\">&#x27;\\n&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin &gt;&gt; s;</span><br><span class=\"line\">    vector&lt;ll&gt; a;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;c : s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cnt)</span><br><span class=\"line\">            a.<span class=\"built_in\">pb</span>(cnt), cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cnt)</span><br><span class=\"line\">        a.<span class=\"built_in\">pb</span>(cnt);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;i : a)</span><br><span class=\"line\">        i = i * i;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = a.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">p0</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span>, <span class=\"title\">p1</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &amp; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            p0[i + <span class=\"number\">1</span>] = -a[i];</span><br><span class=\"line\">            p1[i + <span class=\"number\">1</span>] = a[i];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            p0[i + <span class=\"number\">1</span>] = a[i];</span><br><span class=\"line\">            p1[i + <span class=\"number\">1</span>] = -a[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p0[i + <span class=\"number\">1</span>] += p0[i];</span><br><span class=\"line\">        p1[i + <span class=\"number\">1</span>] += p1[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll mxp0 = p0[n], mxp1 = p1[n];</span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(&#123;ans, mxp0 - p0[i], mxp1 - p1[i]&#125;);</span><br><span class=\"line\">        mxp0 = <span class=\"built_in\">max</span>(mxp0, p0[i]);</span><br><span class=\"line\">        mxp1 = <span class=\"built_in\">max</span>(mxp1, p1[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>), cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin &gt;&gt; T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h1><p>容易发现后面几位是没用的，所以就相当于不能异或出 $0$。经典双指针。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> endl <span class=\"string\">&#x27;\\n&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, k;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;i : a) &#123;</span><br><span class=\"line\">        cin &gt;&gt; i;</span><br><span class=\"line\">        i &gt;&gt;= k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">    <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; l &lt; n; ++l) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (r &lt; n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!mp[a[r]]) &#123;</span><br><span class=\"line\">                mp[a[r]]++;</span><br><span class=\"line\">                r++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, r - l);</span><br><span class=\"line\">        mp[a[l]]--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>), cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin &gt;&gt; T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h1><p>比较经典的二分答案+树形dp。dp 的状态是以当前节点为根节点形成的连通块内两种可乐的 $4$ 种奇偶性的组合各自的最大值。细节比较多，懒得写了。</p>\n<h1 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h1><p>暴力 BFS。懒得写了。</p>\n<h1 id=\"E\"><a href=\"#E\" class=\"headerlink\" title=\"E\"></a>E</h1><p>大概是线段树上二分来模拟这个过程。懒得写了。</p>\n<h1 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h1><p>当最大值为 $m$ 时，前面的 $n-1$ 个位置需要填入 $[0,m]$ 中的数，就相当于将 $n-1$ 个相同的球放进 $m+1$ 个不同的箱子里，允许出现空箱。</p>\n<p>不允许出现空箱的时候可以用隔板法，就是在 $n-2$ 个空隙里选 $m$ 个位置插入隔板。那么允许空箱的时候就在每个箱子里加一个虚拟的球，就转化为了之前的问题，答案就是 $\\binom{n+m-1}{m}$。</p>\n<p>预处理组合数后枚举 $m$，复杂度 $O(n+k)$。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> endl <span class=\"string\">&#x27;\\n&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"type\">const</span> ll mod = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">2e6</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qpow</span><span class=\"params\">(ll b, ll k)</span> </span>&#123;</span><br><span class=\"line\">    ll ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">            ret = ret * b % mod;</span><br><span class=\"line\">        b = b * b % mod;</span><br><span class=\"line\">        k /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">pinv</span><span class=\"params\">(ll x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">qpow</span>(x, mod - <span class=\"number\">2</span>); &#125;</span><br><span class=\"line\">ll fact[maxn], ifact[maxn];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init_fact</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    fact[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i)</span><br><span class=\"line\">        fact[i] = fact[i - <span class=\"number\">1</span>] * i % mod;</span><br><span class=\"line\">    ifact[n] = <span class=\"built_in\">pinv</span>(fact[n]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">        ifact[i] = ifact[i + <span class=\"number\">1</span>] * (i + <span class=\"number\">1</span>) % mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">C</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> m)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> fact[n] * ifact[n - m] % mod * ifact[m] % mod; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ll n, k;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"built_in\">init_fact</span>(n + k);</span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= k; ++i) &#123;</span><br><span class=\"line\">        ans += <span class=\"built_in\">C</span>(n + i - <span class=\"number\">1</span>, i) * i % mod;</span><br><span class=\"line\">        ans %= mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>), cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin &gt;&gt; T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h1><p>贪心。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> endl <span class=\"string\">&#x27;\\n&#x27;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">        cin &gt;&gt; a[i];</span><br><span class=\"line\">    <span class=\"type\">int</span> l, r;</span><br><span class=\"line\">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;i : a) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt;= i &amp;&amp; i &lt;= r)</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; (ans + r) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>), cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin &gt;&gt; T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"H\"><a href=\"#H\" class=\"headerlink\" title=\"H\"></a>H</h1><p>令 $p_i$ 表示第 $i$ 天结束的概率，$q_i&#x3D;\\prod_{j\\lt i}(1-p_j)$。</p>\n<p>先列出期望的式子：</p>\n<p>$$<br>E&#x3D; \\sum_{i&#x3D;1}^{\\infty}p_iq_i i<br>$$</p>\n<p>然后根据 $p_i$ 的周期性，每 $n$ 天分一段。令 $E_n&#x3D;\\sum_{i&#x3D;1}^n p_iq_i i$，$P_n&#x3D;\\sum_{i&#x3D;1}^n p_iq_i$：</p>\n<p>$$<br>E&#x3D; \\sum_{i&#x3D;0}^{\\infty}q_n^i (E_n+inP_n)\\<br>(1-q_n)E&#x3D;E_n+nP_n\\sum_{i&#x3D;1}^{\\infty}q_n^i \\<br>E&#x3D;\\frac{E_n}{1-q_n}+\\frac{nP_nq_n}{(1-q_n)^2}<br>$$</p>\n<p>这样就可以 $O(n)$ 求出来了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> endl <span class=\"string\">&#x27;\\n&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"type\">const</span> ll mod = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">qpow</span><span class=\"params\">(ll b, ll k)</span> </span>&#123;</span><br><span class=\"line\">    ll ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">            ret = ret * b % mod;</span><br><span class=\"line\">        b = b * b % mod;</span><br><span class=\"line\">        k /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">pinv</span><span class=\"params\">(ll x)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">qpow</span>(x, mod - <span class=\"number\">2</span>); &#125;</span><br><span class=\"line\">ll a[maxn];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ll n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    ll inv100 = <span class=\"built_in\">pinv</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i];</span><br><span class=\"line\">        a[i] = a[i] * inv100 % mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll q = <span class=\"number\">1</span>, p = <span class=\"number\">0</span>, E = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        p = (p + q * a[i] % mod) % mod;</span><br><span class=\"line\">        E = (E + q * a[i] % mod * i % mod) % mod;</span><br><span class=\"line\">        q = q * (<span class=\"number\">1</span> + mod - a[i]) % mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll tmp = <span class=\"built_in\">pinv</span>((<span class=\"number\">1</span> + mod - q) % mod);</span><br><span class=\"line\">    ll ans = E * tmp % mod + n * p % mod * q % mod * tmp % mod * tmp % mod;</span><br><span class=\"line\">    cout &lt;&lt; ans % mod &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>), cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin &gt;&gt; T;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--)</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>感觉这种难度的题放在校赛或者个人训练赛还是很合适的。</p>"},{"title":"GYM104081","date":"2023-05-01T16:00:00.000Z","math":true,"_content":"\n[2022年中国大学生程序设计竞赛女生专场](https://codeforces.com/gym/104081)\n\n# 签到题和 L 题\n\n过了 ACEGHL。别的都比较简单，L 稍微说两句。\n\nL 如果不考虑距离限制就无脑启发式合并。有了距离限制之后就需要在启发式合并的时候额外维护需要删去的点的集合，这个如果没想清楚可能会导致实现起来很麻烦。注意 DFS 经过树上节点的顺序，可以发现只需要将相同深度的点放在一起，每次删的时候只会删同一深度的点，就容易实现了。\n\n``` cpp\n#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::string;\nusing ll = long long;\nusing uint = unsigned int;\nusing ull = unsigned long long;\nusing pii = std::pair<int, int>;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 1e5 + 5;\nconst double pi = acos(-1);\n\nvector<int> g[maxn];\nint color[maxn];\nint K;\nint dep[maxn], sz[maxn], big[maxn];\nstd::map<int, int> node[maxn];\nint ans[maxn];\nvector<int> vis[maxn];\n\nvoid dfs0(int u, int f) {\n    dep[u] = dep[f] + 1;\n    sz[u] = 1;\n    for (auto v : g[u]) {\n        if (v == f) continue;\n        dfs0(v, u);\n        sz[u] += sz[v];\n        if (sz[v] > sz[big[u]])\n            big[u] = v;\n    }\n}\n\nvoid dfs(int u, int f) {\n    vis[dep[u]].push_back(u);\n    if (sz[u] == 1) {\n        node[u][color[u]] = 1;\n        ans[u] = 1;\n        return;\n    }\n    dfs(big[u], u);\n    node[u].swap(node[big[u]]);\n    node[u][color[u]]++;\n    for (auto v : g[u]) {\n        if (v == big[u] || v == f)\n            continue;\n        dfs(v, u);\n        for (auto& [col, cnt] : node[v]) {\n            node[u][col] += cnt;\n        }\n    }\n    for (auto v : vis[dep[u] + K + 1]) {\n        node[u][color[v]]--;\n        if (node[u][color[v]] == 0) {\n            node[u].erase(color[v]);\n        }\n    }\n    vis[dep[u] + K + 1].clear();\n    ans[u] = node[u].size();\n}\n\nvoid solve() {\n    int n;\n    cin >> n >> K;\n    for (int i = 1; i <= n; ++i) {\n        cin >> color[i];\n    }\n    for (int i = 1, u, v; i < n; ++i) {\n        cin >> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs0(1, 0);\n    dfs(1, 0);\n    int q;\n    cin >> q;\n    while (q--) {\n        int x;\n        cin >> x;\n        cout << ans[x] << '\\n';\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T = 1;\n    // cin >> T;\n    for (int t = 1; t <= T; ++t) {\n        solve();\n    }\n    return 0;\n}\n```\n\n下面是补题。试着补一下 BFIJK，D 太恶心了就不管了。\n\n# I\n\n当时也想过 dp，但是没完全想清楚。\n\n令 $dp[i][0/1]$ 表示长度为 $i$ 的前缀用两种字符串交替表达的最小次数。然后对于每个起点 $i$，枚举所有终点 $j$，如果 $s[i\\cdots j]$ 是一个存在的串，就去更新 $dp[j][0/1]$。事先只要用字典树维护一下那些串就好了，dp 的过程是 $O(n^2)$ 的。\n\n``` cpp\n#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::string;\nusing ll = long long;\nusing uint = unsigned int;\nusing ull = unsigned long long;\nusing pii = std::pair<int, int>;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 1e5 + 5;\n\nstruct Trie {\n    static constexpr int ALPHABET = 26;\n    struct Node {\n        bool end;\n        std::array<int, ALPHABET> next;\n        Node(): end{}, next{} {}\n    };\n\n    std::vector<Node> trie;\n\n    Trie() {\n        init();\n    }\n\n    void init() {\n        trie.assign(1, Node());\n    }\n\n    int newNode() {\n        trie.emplace_back();\n        return trie.size() - 1;\n    }\n\n    int insert(const vector<int>& a) {\n        int cur = 0;\n        for (auto& x : a) {\n            if (trie[cur].next[x] == 0) {\n                trie[cur].next[x] = newNode();\n            }\n            cur = trie[cur].next[x];\n        }\n        trie[cur].end = true;\n        return cur;\n    }\n\n    int insert(const string& s, char offset = 'a') {\n        vector<int> a(s.size());\n        for (size_t i = 0; i < s.size(); ++i) {\n            a[i] = s[i] - offset;\n        }\n        return insert(a);\n    }\n\n    int next(int p, int x) {\n        return trie[p].next[x];\n    }\n\n    int next(int p, char c, char offset = 'a') {\n        return next(p, c - 'a');\n    }\n\n    bool end(int p) {\n        return trie[p].end;\n    }\n\n    int size() {\n        return trie.size();\n    }\n};\n\nvoid solve() {\n    int n, m;\n    cin >> n;\n    Trie a, b;\n    for (int i = 1; i <= n; ++i) {\n        string s;\n        cin >> s;\n        a.insert(s);\n    }\n    cin >> m;\n    for (int i = 1; i <= m; ++i) {\n        string s;\n        cin >> s;\n        b.insert(s);\n    }\n    string s;\n    cin >> s;\n    int len = s.length();\n    vector<int> dp1(len + 1, inf), dp2(len + 1, inf);\n    dp1[0] = dp2[0] = 0;\n    for (int i = 1; i <= len; ++i) {\n        int pos = 0;\n        for (int j = i; j <= len; ++j) {\n            pos = a.next(pos, s[j - 1]);\n            if (pos == 0)\n                break;\n            if (a.end(pos))\n                dp1[j] = std::min(dp1[j], dp2[i - 1] + 1);\n        }\n        pos = 0;\n        for (int j = i; j <= len; ++j) {\n            pos = b.next(pos, s[j - 1]);\n            if (pos == 0)\n                break;\n            if (b.end(pos))\n                dp2[j] = std::min(dp2[j], dp1[i - 1] + 1);\n        }\n    }\n    int ans = std::min(dp1[len], dp2[len]);\n    cout << (ans == inf ? -1 : ans) << endl;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T = 1;\n    // cin >> T;\n    for (int trie = 1; trie <= T; ++trie) {\n        solve();\n    }\n    return 0;\n}\n```\n\n# F\n\n首先要把九个数分成三组，每一组是由两个数经过三种运算得到的。\n\n注意到 $(A| B)\\oplus(A\\&B)=A\\oplus B$，确定了其中两个就可以算出第三个。\n\n确定分组后，由于 $(A| B)+(A\\&B)=A+B$，可以推出每个数的值。\n\n因此可以直接搜索，就是有点麻烦。\n\n题解给出了另一种做法：\n\n随机化，第一个数固定放第一组，然后随机取一个，就可以确定第一组。第一组的成功率是 $\\frac{2}{8}$。同样的方法取第二组，成功率是 $\\frac{2}{5}$，总成功率就是 $\\frac{1}{10}$。\n\n然后考虑分完组之后，最大的肯定是 $A|B$，$A\\&B$ 可以进一步通过随机去找，那么总的成功率就是 $\\frac{1}{80}$。\n\n这个做法感觉比搜索好写，并且写起来挺有趣的。\n\n``` cpp\n#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::string;\nusing ll = long long;\nusing uint = unsigned int;\nusing ull = unsigned long long;\nusing pii = std::pair<int, int>;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 1e5 + 5;\n\nstd::random_device rd;\nstd::mt19937 rng(rd());\n\nvoid solve() {\n    vector<ll> a(9);\n    for (ll& i : a)\n        cin >> i;\n    for (int it = 1; it <= 2000; ++it) {\n        std::shuffle(a.begin() + 1, a.end(), rng);\n        ll x1 = (a[0] ^ a[1]);\n        int id1 = 2;\n        for (; id1 < 9; ++id1) {\n            if (a[id1] == x1) \n                break;\n        }\n        if (id1 == 9)\n            continue;\n        std::swap(a[2], a[id1]);\n        ll x2 = (a[3] ^ a[4]);\n        int id2 = 5;\n        for (; id2 < 9; ++id2) {\n            if (a[id2] == x2) \n                break;\n        }\n        if (id2 == 9)\n            continue;\n        std::swap(a[5], a[id2]);\n        if ((a[6] ^ a[7]) != a[8])\n            continue;\n        for (int i = 0; i < 9; i += 3) {\n            for (int j = 1; j <= 2; ++j) {\n                if (a[i] < a[i + j])\n                    std::swap(a[i], a[i + j]);\n            }\n        }\n        ll AB = a[0] + a[1];\n        ll BC = a[3] + a[4];\n        ll AC = a[6] + a[7];\n        ll sum = AB + AC + BC;\n        if (sum & 1)\n            continue;\n        sum /= 2;\n        ll A = sum - BC, B = sum - AC, C = sum - AB;\n        if ((A | B) != a[0] || (A & B) != a[1])\n            continue;\n        if ((B | C) != a[3] || (B & C) != a[4])\n            continue;\n        if ((A | C) != a[6] || (A & C) != a[7])\n            continue;\n        cout << A << \" \" << B << \" \" << C << '\\n';\n        break;\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T = 1;\n    cin >> T;\n    for (int t = 1; t <= T; ++t) {\n        solve();\n    }\n    return 0;\n}\n```\n\n# B\n\n肯定想着虚树那一套方法，考虑用 set 维护前驱后继，然后可以发现除了最外面的一圈以外，其他数都是被覆盖过两次，根一次都没有，所以加上最外面一圈再除以二加上根即可。时间复杂度 。\n\n# J\n\n# K\n\n区间和容易写成差分，二分答案后，就只是要判断  多少个小于 。发现值域很小，直接fft即可。注意到每个数都大于等于 ，所以负的都无用， 可以提前预处理。时间复杂度 。","source":"_posts/GYM104081.md","raw":"---\ntitle: GYM104081\ndate: 2023-05-02\ntag: [XCPC]\ncategory: [Competitive Programming]\nmath: true\n---\n\n[2022年中国大学生程序设计竞赛女生专场](https://codeforces.com/gym/104081)\n\n# 签到题和 L 题\n\n过了 ACEGHL。别的都比较简单，L 稍微说两句。\n\nL 如果不考虑距离限制就无脑启发式合并。有了距离限制之后就需要在启发式合并的时候额外维护需要删去的点的集合，这个如果没想清楚可能会导致实现起来很麻烦。注意 DFS 经过树上节点的顺序，可以发现只需要将相同深度的点放在一起，每次删的时候只会删同一深度的点，就容易实现了。\n\n``` cpp\n#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::string;\nusing ll = long long;\nusing uint = unsigned int;\nusing ull = unsigned long long;\nusing pii = std::pair<int, int>;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 1e5 + 5;\nconst double pi = acos(-1);\n\nvector<int> g[maxn];\nint color[maxn];\nint K;\nint dep[maxn], sz[maxn], big[maxn];\nstd::map<int, int> node[maxn];\nint ans[maxn];\nvector<int> vis[maxn];\n\nvoid dfs0(int u, int f) {\n    dep[u] = dep[f] + 1;\n    sz[u] = 1;\n    for (auto v : g[u]) {\n        if (v == f) continue;\n        dfs0(v, u);\n        sz[u] += sz[v];\n        if (sz[v] > sz[big[u]])\n            big[u] = v;\n    }\n}\n\nvoid dfs(int u, int f) {\n    vis[dep[u]].push_back(u);\n    if (sz[u] == 1) {\n        node[u][color[u]] = 1;\n        ans[u] = 1;\n        return;\n    }\n    dfs(big[u], u);\n    node[u].swap(node[big[u]]);\n    node[u][color[u]]++;\n    for (auto v : g[u]) {\n        if (v == big[u] || v == f)\n            continue;\n        dfs(v, u);\n        for (auto& [col, cnt] : node[v]) {\n            node[u][col] += cnt;\n        }\n    }\n    for (auto v : vis[dep[u] + K + 1]) {\n        node[u][color[v]]--;\n        if (node[u][color[v]] == 0) {\n            node[u].erase(color[v]);\n        }\n    }\n    vis[dep[u] + K + 1].clear();\n    ans[u] = node[u].size();\n}\n\nvoid solve() {\n    int n;\n    cin >> n >> K;\n    for (int i = 1; i <= n; ++i) {\n        cin >> color[i];\n    }\n    for (int i = 1, u, v; i < n; ++i) {\n        cin >> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs0(1, 0);\n    dfs(1, 0);\n    int q;\n    cin >> q;\n    while (q--) {\n        int x;\n        cin >> x;\n        cout << ans[x] << '\\n';\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T = 1;\n    // cin >> T;\n    for (int t = 1; t <= T; ++t) {\n        solve();\n    }\n    return 0;\n}\n```\n\n下面是补题。试着补一下 BFIJK，D 太恶心了就不管了。\n\n# I\n\n当时也想过 dp，但是没完全想清楚。\n\n令 $dp[i][0/1]$ 表示长度为 $i$ 的前缀用两种字符串交替表达的最小次数。然后对于每个起点 $i$，枚举所有终点 $j$，如果 $s[i\\cdots j]$ 是一个存在的串，就去更新 $dp[j][0/1]$。事先只要用字典树维护一下那些串就好了，dp 的过程是 $O(n^2)$ 的。\n\n``` cpp\n#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::string;\nusing ll = long long;\nusing uint = unsigned int;\nusing ull = unsigned long long;\nusing pii = std::pair<int, int>;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 1e5 + 5;\n\nstruct Trie {\n    static constexpr int ALPHABET = 26;\n    struct Node {\n        bool end;\n        std::array<int, ALPHABET> next;\n        Node(): end{}, next{} {}\n    };\n\n    std::vector<Node> trie;\n\n    Trie() {\n        init();\n    }\n\n    void init() {\n        trie.assign(1, Node());\n    }\n\n    int newNode() {\n        trie.emplace_back();\n        return trie.size() - 1;\n    }\n\n    int insert(const vector<int>& a) {\n        int cur = 0;\n        for (auto& x : a) {\n            if (trie[cur].next[x] == 0) {\n                trie[cur].next[x] = newNode();\n            }\n            cur = trie[cur].next[x];\n        }\n        trie[cur].end = true;\n        return cur;\n    }\n\n    int insert(const string& s, char offset = 'a') {\n        vector<int> a(s.size());\n        for (size_t i = 0; i < s.size(); ++i) {\n            a[i] = s[i] - offset;\n        }\n        return insert(a);\n    }\n\n    int next(int p, int x) {\n        return trie[p].next[x];\n    }\n\n    int next(int p, char c, char offset = 'a') {\n        return next(p, c - 'a');\n    }\n\n    bool end(int p) {\n        return trie[p].end;\n    }\n\n    int size() {\n        return trie.size();\n    }\n};\n\nvoid solve() {\n    int n, m;\n    cin >> n;\n    Trie a, b;\n    for (int i = 1; i <= n; ++i) {\n        string s;\n        cin >> s;\n        a.insert(s);\n    }\n    cin >> m;\n    for (int i = 1; i <= m; ++i) {\n        string s;\n        cin >> s;\n        b.insert(s);\n    }\n    string s;\n    cin >> s;\n    int len = s.length();\n    vector<int> dp1(len + 1, inf), dp2(len + 1, inf);\n    dp1[0] = dp2[0] = 0;\n    for (int i = 1; i <= len; ++i) {\n        int pos = 0;\n        for (int j = i; j <= len; ++j) {\n            pos = a.next(pos, s[j - 1]);\n            if (pos == 0)\n                break;\n            if (a.end(pos))\n                dp1[j] = std::min(dp1[j], dp2[i - 1] + 1);\n        }\n        pos = 0;\n        for (int j = i; j <= len; ++j) {\n            pos = b.next(pos, s[j - 1]);\n            if (pos == 0)\n                break;\n            if (b.end(pos))\n                dp2[j] = std::min(dp2[j], dp1[i - 1] + 1);\n        }\n    }\n    int ans = std::min(dp1[len], dp2[len]);\n    cout << (ans == inf ? -1 : ans) << endl;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T = 1;\n    // cin >> T;\n    for (int trie = 1; trie <= T; ++trie) {\n        solve();\n    }\n    return 0;\n}\n```\n\n# F\n\n首先要把九个数分成三组，每一组是由两个数经过三种运算得到的。\n\n注意到 $(A| B)\\oplus(A\\&B)=A\\oplus B$，确定了其中两个就可以算出第三个。\n\n确定分组后，由于 $(A| B)+(A\\&B)=A+B$，可以推出每个数的值。\n\n因此可以直接搜索，就是有点麻烦。\n\n题解给出了另一种做法：\n\n随机化，第一个数固定放第一组，然后随机取一个，就可以确定第一组。第一组的成功率是 $\\frac{2}{8}$。同样的方法取第二组，成功率是 $\\frac{2}{5}$，总成功率就是 $\\frac{1}{10}$。\n\n然后考虑分完组之后，最大的肯定是 $A|B$，$A\\&B$ 可以进一步通过随机去找，那么总的成功率就是 $\\frac{1}{80}$。\n\n这个做法感觉比搜索好写，并且写起来挺有趣的。\n\n``` cpp\n#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::string;\nusing ll = long long;\nusing uint = unsigned int;\nusing ull = unsigned long long;\nusing pii = std::pair<int, int>;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 1e5 + 5;\n\nstd::random_device rd;\nstd::mt19937 rng(rd());\n\nvoid solve() {\n    vector<ll> a(9);\n    for (ll& i : a)\n        cin >> i;\n    for (int it = 1; it <= 2000; ++it) {\n        std::shuffle(a.begin() + 1, a.end(), rng);\n        ll x1 = (a[0] ^ a[1]);\n        int id1 = 2;\n        for (; id1 < 9; ++id1) {\n            if (a[id1] == x1) \n                break;\n        }\n        if (id1 == 9)\n            continue;\n        std::swap(a[2], a[id1]);\n        ll x2 = (a[3] ^ a[4]);\n        int id2 = 5;\n        for (; id2 < 9; ++id2) {\n            if (a[id2] == x2) \n                break;\n        }\n        if (id2 == 9)\n            continue;\n        std::swap(a[5], a[id2]);\n        if ((a[6] ^ a[7]) != a[8])\n            continue;\n        for (int i = 0; i < 9; i += 3) {\n            for (int j = 1; j <= 2; ++j) {\n                if (a[i] < a[i + j])\n                    std::swap(a[i], a[i + j]);\n            }\n        }\n        ll AB = a[0] + a[1];\n        ll BC = a[3] + a[4];\n        ll AC = a[6] + a[7];\n        ll sum = AB + AC + BC;\n        if (sum & 1)\n            continue;\n        sum /= 2;\n        ll A = sum - BC, B = sum - AC, C = sum - AB;\n        if ((A | B) != a[0] || (A & B) != a[1])\n            continue;\n        if ((B | C) != a[3] || (B & C) != a[4])\n            continue;\n        if ((A | C) != a[6] || (A & C) != a[7])\n            continue;\n        cout << A << \" \" << B << \" \" << C << '\\n';\n        break;\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T = 1;\n    cin >> T;\n    for (int t = 1; t <= T; ++t) {\n        solve();\n    }\n    return 0;\n}\n```\n\n# B\n\n肯定想着虚树那一套方法，考虑用 set 维护前驱后继，然后可以发现除了最外面的一圈以外，其他数都是被覆盖过两次，根一次都没有，所以加上最外面一圈再除以二加上根即可。时间复杂度 。\n\n# J\n\n# K\n\n区间和容易写成差分，二分答案后，就只是要判断  多少个小于 。发现值域很小，直接fft即可。注意到每个数都大于等于 ，所以负的都无用， 可以提前预处理。时间复杂度 。","slug":"GYM104081","published":1,"updated":"2023-05-03T03:42:00.575Z","comments":1,"layout":"post","photos":[],"_id":"cmir5cbx600072cleffaz24zu","content":"<p><a href=\"https://codeforces.com/gym/104081\">2022年中国大学生程序设计竞赛女生专场</a></p>\n<h1 id=\"签到题和-L-题\"><a href=\"#签到题和-L-题\" class=\"headerlink\" title=\"签到题和 L 题\"></a>签到题和 L 题</h1><p>过了 ACEGHL。别的都比较简单，L 稍微说两句。</p>\n<p>L 如果不考虑距离限制就无脑启发式合并。有了距离限制之后就需要在启发式合并的时候额外维护需要删去的点的集合，这个如果没想清楚可能会导致实现起来很麻烦。注意 DFS 经过树上节点的顺序，可以发现只需要将相同深度的点放在一起，每次删的时候只会删同一深度的点，就容易实现了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cin;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cout;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::endl;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::vector;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::string;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> uint = <span class=\"type\">unsigned</span> <span class=\"type\">int</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ull = <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> pii = std::pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> inf = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span> pi = <span class=\"built_in\">acos</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; g[maxn];</span><br><span class=\"line\"><span class=\"type\">int</span> color[maxn];</span><br><span class=\"line\"><span class=\"type\">int</span> K;</span><br><span class=\"line\"><span class=\"type\">int</span> dep[maxn], sz[maxn], big[maxn];</span><br><span class=\"line\">std::map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; node[maxn];</span><br><span class=\"line\"><span class=\"type\">int</span> ans[maxn];</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; vis[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs0</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> f)</span> </span>&#123;</span><br><span class=\"line\">    dep[u] = dep[f] + <span class=\"number\">1</span>;</span><br><span class=\"line\">    sz[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v : g[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v == f) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs0</span>(v, u);</span><br><span class=\"line\">        sz[u] += sz[v];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sz[v] &gt; sz[big[u]])</span><br><span class=\"line\">            big[u] = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> f)</span> </span>&#123;</span><br><span class=\"line\">    vis[dep[u]].<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sz[u] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        node[u][color[u]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ans[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(big[u], u);</span><br><span class=\"line\">    node[u].<span class=\"built_in\">swap</span>(node[big[u]]);</span><br><span class=\"line\">    node[u][color[u]]++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v : g[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v == big[u] || v == f)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(v, u);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; [col, cnt] : node[v]) &#123;</span><br><span class=\"line\">            node[u][col] += cnt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v : vis[dep[u] + K + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        node[u][color[v]]--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node[u][color[v]] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            node[u].<span class=\"built_in\">erase</span>(color[v]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vis[dep[u] + K + <span class=\"number\">1</span>].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    ans[u] = node[u].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; color[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>, u, v; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">        g[u].<span class=\"built_in\">push_back</span>(v);</span><br><span class=\"line\">        g[v].<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs0</span>(<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> q;</span><br><span class=\"line\">    cin &gt;&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (q--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x;</span><br><span class=\"line\">        cin &gt;&gt; x;</span><br><span class=\"line\">        cout &lt;&lt; ans[x] &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin &gt;&gt; T;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> t = <span class=\"number\">1</span>; t &lt;= T; ++t) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是补题。试着补一下 BFIJK，D 太恶心了就不管了。</p>\n<h1 id=\"I\"><a href=\"#I\" class=\"headerlink\" title=\"I\"></a>I</h1><p>当时也想过 dp，但是没完全想清楚。</p>\n<p>令 $dp[i][0&#x2F;1]$ 表示长度为 $i$ 的前缀用两种字符串交替表达的最小次数。然后对于每个起点 $i$，枚举所有终点 $j$，如果 $s[i\\cdots j]$ 是一个存在的串，就去更新 $dp[j][0&#x2F;1]$。事先只要用字典树维护一下那些串就好了，dp 的过程是 $O(n^2)$ 的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cin;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cout;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::endl;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::vector;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::string;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> uint = <span class=\"type\">unsigned</span> <span class=\"type\">int</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ull = <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> pii = std::pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> inf = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Trie</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> ALPHABET = <span class=\"number\">26</span>;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> end;</span><br><span class=\"line\">        std::array&lt;<span class=\"type\">int</span>, ALPHABET&gt; next;</span><br><span class=\"line\">        <span class=\"built_in\">Node</span>(): end&#123;&#125;, next&#123;&#125; &#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::vector&lt;Node&gt; trie;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Trie</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        trie.<span class=\"built_in\">assign</span>(<span class=\"number\">1</span>, <span class=\"built_in\">Node</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">newNode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        trie.<span class=\"built_in\">emplace_back</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> trie.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; x : a) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (trie[cur].next[x] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                trie[cur].next[x] = <span class=\"built_in\">newNode</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = trie[cur].next[x];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        trie[cur].end = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; s, <span class=\"type\">char</span> offset = <span class=\"string\">&#x27;a&#x27;</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(s.size())</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            a[i] = s[i] - offset;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">insert</span>(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">next</span><span class=\"params\">(<span class=\"type\">int</span> p, <span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> trie[p].next[x];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">next</span><span class=\"params\">(<span class=\"type\">int</span> p, <span class=\"type\">char</span> c, <span class=\"type\">char</span> offset = <span class=\"string\">&#x27;a&#x27;</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(p, c - <span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">end</span><span class=\"params\">(<span class=\"type\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> trie[p].end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> trie.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    Trie a, b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        string s;</span><br><span class=\"line\">        cin &gt;&gt; s;</span><br><span class=\"line\">        a.<span class=\"built_in\">insert</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cin &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; ++i) &#123;</span><br><span class=\"line\">        string s;</span><br><span class=\"line\">        cin &gt;&gt; s;</span><br><span class=\"line\">        b.<span class=\"built_in\">insert</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin &gt;&gt; s;</span><br><span class=\"line\">    <span class=\"type\">int</span> len = s.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp1</span><span class=\"params\">(len + <span class=\"number\">1</span>, inf)</span>, <span class=\"title\">dp2</span><span class=\"params\">(len + <span class=\"number\">1</span>, inf)</span></span>;</span><br><span class=\"line\">    dp1[<span class=\"number\">0</span>] = dp2[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= len; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= len; ++j) &#123;</span><br><span class=\"line\">            pos = a.<span class=\"built_in\">next</span>(pos, s[j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.<span class=\"built_in\">end</span>(pos))</span><br><span class=\"line\">                dp1[j] = std::<span class=\"built_in\">min</span>(dp1[j], dp2[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= len; ++j) &#123;</span><br><span class=\"line\">            pos = b.<span class=\"built_in\">next</span>(pos, s[j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b.<span class=\"built_in\">end</span>(pos))</span><br><span class=\"line\">                dp2[j] = std::<span class=\"built_in\">min</span>(dp2[j], dp1[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = std::<span class=\"built_in\">min</span>(dp1[len], dp2[len]);</span><br><span class=\"line\">    cout &lt;&lt; (ans == inf ? <span class=\"number\">-1</span> : ans) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin &gt;&gt; T;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> trie = <span class=\"number\">1</span>; trie &lt;= T; ++trie) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h1><p>首先要把九个数分成三组，每一组是由两个数经过三种运算得到的。</p>\n<p>注意到 $(A| B)\\oplus(A&amp;B)&#x3D;A\\oplus B$，确定了其中两个就可以算出第三个。</p>\n<p>确定分组后，由于 $(A| B)+(A&amp;B)&#x3D;A+B$，可以推出每个数的值。</p>\n<p>因此可以直接搜索，就是有点麻烦。</p>\n<p>题解给出了另一种做法：</p>\n<p>随机化，第一个数固定放第一组，然后随机取一个，就可以确定第一组。第一组的成功率是 $\\frac{2}{8}$。同样的方法取第二组，成功率是 $\\frac{2}{5}$，总成功率就是 $\\frac{1}{10}$。</p>\n<p>然后考虑分完组之后，最大的肯定是 $A|B$，$A&amp;B$ 可以进一步通过随机去找，那么总的成功率就是 $\\frac{1}{80}$。</p>\n<p>这个做法感觉比搜索好写，并且写起来挺有趣的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cin;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cout;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::endl;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::vector;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::string;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> uint = <span class=\"type\">unsigned</span> <span class=\"type\">int</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ull = <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> pii = std::pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> inf = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">std::random_device rd;</span><br><span class=\"line\"><span class=\"function\">std::mt19937 <span class=\"title\">rng</span><span class=\"params\">(rd())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">9</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ll&amp; i : a)</span><br><span class=\"line\">        cin &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> it = <span class=\"number\">1</span>; it &lt;= <span class=\"number\">2000</span>; ++it) &#123;</span><br><span class=\"line\">        std::<span class=\"built_in\">shuffle</span>(a.<span class=\"built_in\">begin</span>() + <span class=\"number\">1</span>, a.<span class=\"built_in\">end</span>(), rng);</span><br><span class=\"line\">        ll x1 = (a[<span class=\"number\">0</span>] ^ a[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"type\">int</span> id1 = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; id1 &lt; <span class=\"number\">9</span>; ++id1) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[id1] == x1) </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (id1 == <span class=\"number\">9</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        std::<span class=\"built_in\">swap</span>(a[<span class=\"number\">2</span>], a[id1]);</span><br><span class=\"line\">        ll x2 = (a[<span class=\"number\">3</span>] ^ a[<span class=\"number\">4</span>]);</span><br><span class=\"line\">        <span class=\"type\">int</span> id2 = <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; id2 &lt; <span class=\"number\">9</span>; ++id2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[id2] == x2) </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (id2 == <span class=\"number\">9</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        std::<span class=\"built_in\">swap</span>(a[<span class=\"number\">5</span>], a[id2]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((a[<span class=\"number\">6</span>] ^ a[<span class=\"number\">7</span>]) != a[<span class=\"number\">8</span>])</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i += <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">2</span>; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a[i] &lt; a[i + j])</span><br><span class=\"line\">                    std::<span class=\"built_in\">swap</span>(a[i], a[i + j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ll AB = a[<span class=\"number\">0</span>] + a[<span class=\"number\">1</span>];</span><br><span class=\"line\">        ll BC = a[<span class=\"number\">3</span>] + a[<span class=\"number\">4</span>];</span><br><span class=\"line\">        ll AC = a[<span class=\"number\">6</span>] + a[<span class=\"number\">7</span>];</span><br><span class=\"line\">        ll sum = AB + AC + BC;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        sum /= <span class=\"number\">2</span>;</span><br><span class=\"line\">        ll A = sum - BC, B = sum - AC, C = sum - AB;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((A | B) != a[<span class=\"number\">0</span>] || (A &amp; B) != a[<span class=\"number\">1</span>])</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((B | C) != a[<span class=\"number\">3</span>] || (B &amp; C) != a[<span class=\"number\">4</span>])</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((A | C) != a[<span class=\"number\">6</span>] || (A &amp; C) != a[<span class=\"number\">7</span>])</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        cout &lt;&lt; A &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; B &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; C &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> t = <span class=\"number\">1</span>; t &lt;= T; ++t) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h1><p>肯定想着虚树那一套方法，考虑用 set 维护前驱后继，然后可以发现除了最外面的一圈以外，其他数都是被覆盖过两次，根一次都没有，所以加上最外面一圈再除以二加上根即可。时间复杂度 。</p>\n<h1 id=\"J\"><a href=\"#J\" class=\"headerlink\" title=\"J\"></a>J</h1><h1 id=\"K\"><a href=\"#K\" class=\"headerlink\" title=\"K\"></a>K</h1><p>区间和容易写成差分，二分答案后，就只是要判断  多少个小于 。发现值域很小，直接fft即可。注意到每个数都大于等于 ，所以负的都无用， 可以提前预处理。时间复杂度 。</p>\n","excerpt":"","more":"<p><a href=\"https://codeforces.com/gym/104081\">2022年中国大学生程序设计竞赛女生专场</a></p>\n<h1 id=\"签到题和-L-题\"><a href=\"#签到题和-L-题\" class=\"headerlink\" title=\"签到题和 L 题\"></a>签到题和 L 题</h1><p>过了 ACEGHL。别的都比较简单，L 稍微说两句。</p>\n<p>L 如果不考虑距离限制就无脑启发式合并。有了距离限制之后就需要在启发式合并的时候额外维护需要删去的点的集合，这个如果没想清楚可能会导致实现起来很麻烦。注意 DFS 经过树上节点的顺序，可以发现只需要将相同深度的点放在一起，每次删的时候只会删同一深度的点，就容易实现了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cin;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cout;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::endl;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::vector;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::string;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> uint = <span class=\"type\">unsigned</span> <span class=\"type\">int</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ull = <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> pii = std::pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> inf = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span> pi = <span class=\"built_in\">acos</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; g[maxn];</span><br><span class=\"line\"><span class=\"type\">int</span> color[maxn];</span><br><span class=\"line\"><span class=\"type\">int</span> K;</span><br><span class=\"line\"><span class=\"type\">int</span> dep[maxn], sz[maxn], big[maxn];</span><br><span class=\"line\">std::map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; node[maxn];</span><br><span class=\"line\"><span class=\"type\">int</span> ans[maxn];</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; vis[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs0</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> f)</span> </span>&#123;</span><br><span class=\"line\">    dep[u] = dep[f] + <span class=\"number\">1</span>;</span><br><span class=\"line\">    sz[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v : g[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v == f) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs0</span>(v, u);</span><br><span class=\"line\">        sz[u] += sz[v];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sz[v] &gt; sz[big[u]])</span><br><span class=\"line\">            big[u] = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> f)</span> </span>&#123;</span><br><span class=\"line\">    vis[dep[u]].<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sz[u] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        node[u][color[u]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ans[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(big[u], u);</span><br><span class=\"line\">    node[u].<span class=\"built_in\">swap</span>(node[big[u]]);</span><br><span class=\"line\">    node[u][color[u]]++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v : g[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v == big[u] || v == f)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(v, u);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; [col, cnt] : node[v]) &#123;</span><br><span class=\"line\">            node[u][col] += cnt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> v : vis[dep[u] + K + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        node[u][color[v]]--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node[u][color[v]] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            node[u].<span class=\"built_in\">erase</span>(color[v]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vis[dep[u] + K + <span class=\"number\">1</span>].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    ans[u] = node[u].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; color[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>, u, v; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">        g[u].<span class=\"built_in\">push_back</span>(v);</span><br><span class=\"line\">        g[v].<span class=\"built_in\">push_back</span>(u);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs0</span>(<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> q;</span><br><span class=\"line\">    cin &gt;&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (q--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x;</span><br><span class=\"line\">        cin &gt;&gt; x;</span><br><span class=\"line\">        cout &lt;&lt; ans[x] &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin &gt;&gt; T;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> t = <span class=\"number\">1</span>; t &lt;= T; ++t) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是补题。试着补一下 BFIJK，D 太恶心了就不管了。</p>\n<h1 id=\"I\"><a href=\"#I\" class=\"headerlink\" title=\"I\"></a>I</h1><p>当时也想过 dp，但是没完全想清楚。</p>\n<p>令 $dp[i][0&#x2F;1]$ 表示长度为 $i$ 的前缀用两种字符串交替表达的最小次数。然后对于每个起点 $i$，枚举所有终点 $j$，如果 $s[i\\cdots j]$ 是一个存在的串，就去更新 $dp[j][0&#x2F;1]$。事先只要用字典树维护一下那些串就好了，dp 的过程是 $O(n^2)$ 的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cin;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cout;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::endl;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::vector;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::string;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> uint = <span class=\"type\">unsigned</span> <span class=\"type\">int</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ull = <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> pii = std::pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> inf = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Trie</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> ALPHABET = <span class=\"number\">26</span>;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> end;</span><br><span class=\"line\">        std::array&lt;<span class=\"type\">int</span>, ALPHABET&gt; next;</span><br><span class=\"line\">        <span class=\"built_in\">Node</span>(): end&#123;&#125;, next&#123;&#125; &#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::vector&lt;Node&gt; trie;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Trie</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        trie.<span class=\"built_in\">assign</span>(<span class=\"number\">1</span>, <span class=\"built_in\">Node</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">newNode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        trie.<span class=\"built_in\">emplace_back</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> trie.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; x : a) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (trie[cur].next[x] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                trie[cur].next[x] = <span class=\"built_in\">newNode</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = trie[cur].next[x];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        trie[cur].end = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; s, <span class=\"type\">char</span> offset = <span class=\"string\">&#x27;a&#x27;</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(s.size())</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            a[i] = s[i] - offset;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">insert</span>(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">next</span><span class=\"params\">(<span class=\"type\">int</span> p, <span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> trie[p].next[x];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">next</span><span class=\"params\">(<span class=\"type\">int</span> p, <span class=\"type\">char</span> c, <span class=\"type\">char</span> offset = <span class=\"string\">&#x27;a&#x27;</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">next</span>(p, c - <span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">end</span><span class=\"params\">(<span class=\"type\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> trie[p].end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> trie.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    Trie a, b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        string s;</span><br><span class=\"line\">        cin &gt;&gt; s;</span><br><span class=\"line\">        a.<span class=\"built_in\">insert</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cin &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; ++i) &#123;</span><br><span class=\"line\">        string s;</span><br><span class=\"line\">        cin &gt;&gt; s;</span><br><span class=\"line\">        b.<span class=\"built_in\">insert</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    cin &gt;&gt; s;</span><br><span class=\"line\">    <span class=\"type\">int</span> len = s.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp1</span><span class=\"params\">(len + <span class=\"number\">1</span>, inf)</span>, <span class=\"title\">dp2</span><span class=\"params\">(len + <span class=\"number\">1</span>, inf)</span></span>;</span><br><span class=\"line\">    dp1[<span class=\"number\">0</span>] = dp2[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= len; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= len; ++j) &#123;</span><br><span class=\"line\">            pos = a.<span class=\"built_in\">next</span>(pos, s[j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.<span class=\"built_in\">end</span>(pos))</span><br><span class=\"line\">                dp1[j] = std::<span class=\"built_in\">min</span>(dp1[j], dp2[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt;= len; ++j) &#123;</span><br><span class=\"line\">            pos = b.<span class=\"built_in\">next</span>(pos, s[j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b.<span class=\"built_in\">end</span>(pos))</span><br><span class=\"line\">                dp2[j] = std::<span class=\"built_in\">min</span>(dp2[j], dp1[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = std::<span class=\"built_in\">min</span>(dp1[len], dp2[len]);</span><br><span class=\"line\">    cout &lt;&lt; (ans == inf ? <span class=\"number\">-1</span> : ans) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cin &gt;&gt; T;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> trie = <span class=\"number\">1</span>; trie &lt;= T; ++trie) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h1><p>首先要把九个数分成三组，每一组是由两个数经过三种运算得到的。</p>\n<p>注意到 $(A| B)\\oplus(A&amp;B)&#x3D;A\\oplus B$，确定了其中两个就可以算出第三个。</p>\n<p>确定分组后，由于 $(A| B)+(A&amp;B)&#x3D;A+B$，可以推出每个数的值。</p>\n<p>因此可以直接搜索，就是有点麻烦。</p>\n<p>题解给出了另一种做法：</p>\n<p>随机化，第一个数固定放第一组，然后随机取一个，就可以确定第一组。第一组的成功率是 $\\frac{2}{8}$。同样的方法取第二组，成功率是 $\\frac{2}{5}$，总成功率就是 $\\frac{1}{10}$。</p>\n<p>然后考虑分完组之后，最大的肯定是 $A|B$，$A&amp;B$ 可以进一步通过随机去找，那么总的成功率就是 $\\frac{1}{80}$。</p>\n<p>这个做法感觉比搜索好写，并且写起来挺有趣的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cin;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cout;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::endl;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::vector;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::string;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> uint = <span class=\"type\">unsigned</span> <span class=\"type\">int</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ull = <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> pii = std::pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> inf = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">std::random_device rd;</span><br><span class=\"line\"><span class=\"function\">std::mt19937 <span class=\"title\">rng</span><span class=\"params\">(rd())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">9</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ll&amp; i : a)</span><br><span class=\"line\">        cin &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> it = <span class=\"number\">1</span>; it &lt;= <span class=\"number\">2000</span>; ++it) &#123;</span><br><span class=\"line\">        std::<span class=\"built_in\">shuffle</span>(a.<span class=\"built_in\">begin</span>() + <span class=\"number\">1</span>, a.<span class=\"built_in\">end</span>(), rng);</span><br><span class=\"line\">        ll x1 = (a[<span class=\"number\">0</span>] ^ a[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"type\">int</span> id1 = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; id1 &lt; <span class=\"number\">9</span>; ++id1) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[id1] == x1) </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (id1 == <span class=\"number\">9</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        std::<span class=\"built_in\">swap</span>(a[<span class=\"number\">2</span>], a[id1]);</span><br><span class=\"line\">        ll x2 = (a[<span class=\"number\">3</span>] ^ a[<span class=\"number\">4</span>]);</span><br><span class=\"line\">        <span class=\"type\">int</span> id2 = <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; id2 &lt; <span class=\"number\">9</span>; ++id2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[id2] == x2) </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (id2 == <span class=\"number\">9</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        std::<span class=\"built_in\">swap</span>(a[<span class=\"number\">5</span>], a[id2]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((a[<span class=\"number\">6</span>] ^ a[<span class=\"number\">7</span>]) != a[<span class=\"number\">8</span>])</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">9</span>; i += <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">2</span>; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a[i] &lt; a[i + j])</span><br><span class=\"line\">                    std::<span class=\"built_in\">swap</span>(a[i], a[i + j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ll AB = a[<span class=\"number\">0</span>] + a[<span class=\"number\">1</span>];</span><br><span class=\"line\">        ll BC = a[<span class=\"number\">3</span>] + a[<span class=\"number\">4</span>];</span><br><span class=\"line\">        ll AC = a[<span class=\"number\">6</span>] + a[<span class=\"number\">7</span>];</span><br><span class=\"line\">        ll sum = AB + AC + BC;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        sum /= <span class=\"number\">2</span>;</span><br><span class=\"line\">        ll A = sum - BC, B = sum - AC, C = sum - AB;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((A | B) != a[<span class=\"number\">0</span>] || (A &amp; B) != a[<span class=\"number\">1</span>])</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((B | C) != a[<span class=\"number\">3</span>] || (B &amp; C) != a[<span class=\"number\">4</span>])</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((A | C) != a[<span class=\"number\">6</span>] || (A &amp; C) != a[<span class=\"number\">7</span>])</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        cout &lt;&lt; A &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; B &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; C &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> t = <span class=\"number\">1</span>; t &lt;= T; ++t) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h1><p>肯定想着虚树那一套方法，考虑用 set 维护前驱后继，然后可以发现除了最外面的一圈以外，其他数都是被覆盖过两次，根一次都没有，所以加上最外面一圈再除以二加上根即可。时间复杂度 。</p>\n<h1 id=\"J\"><a href=\"#J\" class=\"headerlink\" title=\"J\"></a>J</h1><h1 id=\"K\"><a href=\"#K\" class=\"headerlink\" title=\"K\"></a>K</h1><p>区间和容易写成差分，二分答案后，就只是要判断  多少个小于 。发现值域很小，直接fft即可。注意到每个数都大于等于 ，所以负的都无用， 可以提前预处理。时间复杂度 。</p>\n"},{"title":"Kuhn–Munkres Algorithm","date":"2022-07-21T16:00:00.000Z","math":true,"_content":"\n二分图匹配问题与 KM 算法\n\n<!--more-->\n\n二分图匹配的概念很容易理解：假设现在有一个二分图 $G=(V,E)$，对于它的一个子图 $M=(V_M,E_M)$，如果边集 $E_M$ 的所有边均没有共同的顶点，$M$ 就是 $G$ 的一个匹配。\n\n对于一个匹配 $M$，其边数 $|E_M|$ 就是匹配数。二分图的最大匹配问题就是让你找出一个匹配数最大的匹配。\n\n## 增广路\n\n在找最大匹配之前，先尝试解决一个简单的问题：如果当前找到的匹配有优化的空间（存在更大的匹配），如何优化当前解？\n\n如果这个问题可以比较简便的解决，那么就能够一步步得到最大匹配了。\n\n我们定义**交错路径**为这样的一种路径：从一个未匹配点出发，交替经过非匹配边与匹配边形成的路径。\n\n定义**增广路**为终点也是非匹配边的**交错路径**。\n\n容易发现，只要把增广路里的匹配边变成非匹配边，非匹配边变成匹配边，那么就增加了一个匹配。这就是增广的过程。\n\n**Berge's lemma**：匹配 $M$ 为图 $G=(V, E)$ 的最大匹配当且仅当 $G$ 中不存在 $M$-增广路。\n\n必要性是显而易见的，用反证法很容易证明。\n\n不太严谨地证明一下充分性：反证法，若不存在增广路且有一个更大的匹配 $M_1$，那么取两个匹配的边集的对称差，里面就是一些链和偶数长度的环。显然位于 $M_1$ 中的点的数量更多，所以可以找到一个从 $M_1$ 中的点出发的交错路，这就是增广路了。\n\n## Hungarian Algorithm\n\n有了增广路定理的基础后，匈牙利算法的原理就更容易理解了。逐一枚举二分图左部的顶点，每次寻找一条增广路，只要找到增广路就进行增广，并更新匹配结果；否则意味着能与这个点匹配的右部的点已经被耗尽了，之前占用这些右部的点的左部的点也转不到别的地方去，所以这个点已经彻底没用了，直接枚举下一个即可。\n\n参考代码以[UOJ#78. 二分图最大匹配](https://uoj.ac/problem/78)为例：\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 500 + 5;\nvector<int> g[maxn];\nint matchL[maxn], matchR[maxn], vis[maxn];\nint L, R, k;\nbool augment(int u) {\n    for (auto &v : g[u]) {\n        if (vis[v])\n            continue;\n        vis[v] = true;\n        if (!matchR[v] || augment(matchR[v])) {\n            matchR[v] = u;\n            matchL[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\nint Hungarian() {\n    int cnt = 0;\n    for (int u = 1; u <= L; ++u) {\n        memset(vis, 0, sizeof(vis));\n        if (augment(u))\n            ++cnt;\n    }\n    return cnt;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> L >> R >> k;\n    for (int i = 1, u, v; i <= k; ++i) {\n        cin >> u >> v;\n        g[u].push_back(v);\n    }\n    cout << Hungarian() << endl;\n    for (int i = 1; i <= L; ++i) {\n        cout << matchL[i] << \" \";\n    }\n    return 0;\n}\n```\n\n显而易见，匈牙利算法的时间复杂度是 $O(|V||E|)$。\n\n## Hopcroft–Karp Algorithm\n\n二分图的最大匹配问题容易转化为最大流问题，所以也可以用网络流算法解决。由于二分图的特殊性，用 Dinic 算法求最大匹配的时间复杂度仅为 $O(\\sqrt{|V|}|E|)$。Dinic 算法的一大特点是多路增广，其实匈牙利算法也可以用多路增广优化到同样的复杂度，这就是 Hopcroft–Karp 算法。\n\n具体内容心情好了再写。\n\n## Kuhn–Munkres Algorithm\n\n未完待续\n\n","source":"_posts/KM.md","raw":"---\ntitle: Kuhn–Munkres Algorithm\ndate: 2022-07-22\ntag: [algorithm]\ncategory: [Algorithm and DataStructure]\nmath: true\n---\n\n二分图匹配问题与 KM 算法\n\n<!--more-->\n\n二分图匹配的概念很容易理解：假设现在有一个二分图 $G=(V,E)$，对于它的一个子图 $M=(V_M,E_M)$，如果边集 $E_M$ 的所有边均没有共同的顶点，$M$ 就是 $G$ 的一个匹配。\n\n对于一个匹配 $M$，其边数 $|E_M|$ 就是匹配数。二分图的最大匹配问题就是让你找出一个匹配数最大的匹配。\n\n## 增广路\n\n在找最大匹配之前，先尝试解决一个简单的问题：如果当前找到的匹配有优化的空间（存在更大的匹配），如何优化当前解？\n\n如果这个问题可以比较简便的解决，那么就能够一步步得到最大匹配了。\n\n我们定义**交错路径**为这样的一种路径：从一个未匹配点出发，交替经过非匹配边与匹配边形成的路径。\n\n定义**增广路**为终点也是非匹配边的**交错路径**。\n\n容易发现，只要把增广路里的匹配边变成非匹配边，非匹配边变成匹配边，那么就增加了一个匹配。这就是增广的过程。\n\n**Berge's lemma**：匹配 $M$ 为图 $G=(V, E)$ 的最大匹配当且仅当 $G$ 中不存在 $M$-增广路。\n\n必要性是显而易见的，用反证法很容易证明。\n\n不太严谨地证明一下充分性：反证法，若不存在增广路且有一个更大的匹配 $M_1$，那么取两个匹配的边集的对称差，里面就是一些链和偶数长度的环。显然位于 $M_1$ 中的点的数量更多，所以可以找到一个从 $M_1$ 中的点出发的交错路，这就是增广路了。\n\n## Hungarian Algorithm\n\n有了增广路定理的基础后，匈牙利算法的原理就更容易理解了。逐一枚举二分图左部的顶点，每次寻找一条增广路，只要找到增广路就进行增广，并更新匹配结果；否则意味着能与这个点匹配的右部的点已经被耗尽了，之前占用这些右部的点的左部的点也转不到别的地方去，所以这个点已经彻底没用了，直接枚举下一个即可。\n\n参考代码以[UOJ#78. 二分图最大匹配](https://uoj.ac/problem/78)为例：\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 500 + 5;\nvector<int> g[maxn];\nint matchL[maxn], matchR[maxn], vis[maxn];\nint L, R, k;\nbool augment(int u) {\n    for (auto &v : g[u]) {\n        if (vis[v])\n            continue;\n        vis[v] = true;\n        if (!matchR[v] || augment(matchR[v])) {\n            matchR[v] = u;\n            matchL[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\nint Hungarian() {\n    int cnt = 0;\n    for (int u = 1; u <= L; ++u) {\n        memset(vis, 0, sizeof(vis));\n        if (augment(u))\n            ++cnt;\n    }\n    return cnt;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> L >> R >> k;\n    for (int i = 1, u, v; i <= k; ++i) {\n        cin >> u >> v;\n        g[u].push_back(v);\n    }\n    cout << Hungarian() << endl;\n    for (int i = 1; i <= L; ++i) {\n        cout << matchL[i] << \" \";\n    }\n    return 0;\n}\n```\n\n显而易见，匈牙利算法的时间复杂度是 $O(|V||E|)$。\n\n## Hopcroft–Karp Algorithm\n\n二分图的最大匹配问题容易转化为最大流问题，所以也可以用网络流算法解决。由于二分图的特殊性，用 Dinic 算法求最大匹配的时间复杂度仅为 $O(\\sqrt{|V|}|E|)$。Dinic 算法的一大特点是多路增广，其实匈牙利算法也可以用多路增广优化到同样的复杂度，这就是 Hopcroft–Karp 算法。\n\n具体内容心情好了再写。\n\n## Kuhn–Munkres Algorithm\n\n未完待续\n\n","slug":"KM","published":1,"updated":"2023-02-25T05:46:11.826Z","comments":1,"layout":"post","photos":[],"_id":"cmir5cbx700082clehg2e7hbh","content":"<p>二分图匹配问题与 KM 算法</p>\n<span id=\"more\"></span>\n\n<p>二分图匹配的概念很容易理解：假设现在有一个二分图 $G&#x3D;(V,E)$，对于它的一个子图 $M&#x3D;(V_M,E_M)$，如果边集 $E_M$ 的所有边均没有共同的顶点，$M$ 就是 $G$ 的一个匹配。</p>\n<p>对于一个匹配 $M$，其边数 $|E_M|$ 就是匹配数。二分图的最大匹配问题就是让你找出一个匹配数最大的匹配。</p>\n<h2 id=\"增广路\"><a href=\"#增广路\" class=\"headerlink\" title=\"增广路\"></a>增广路</h2><p>在找最大匹配之前，先尝试解决一个简单的问题：如果当前找到的匹配有优化的空间（存在更大的匹配），如何优化当前解？</p>\n<p>如果这个问题可以比较简便的解决，那么就能够一步步得到最大匹配了。</p>\n<p>我们定义<strong>交错路径</strong>为这样的一种路径：从一个未匹配点出发，交替经过非匹配边与匹配边形成的路径。</p>\n<p>定义<strong>增广路</strong>为终点也是非匹配边的<strong>交错路径</strong>。</p>\n<p>容易发现，只要把增广路里的匹配边变成非匹配边，非匹配边变成匹配边，那么就增加了一个匹配。这就是增广的过程。</p>\n<p><strong>Berge’s lemma</strong>：匹配 $M$ 为图 $G&#x3D;(V, E)$ 的最大匹配当且仅当 $G$ 中不存在 $M$-增广路。</p>\n<p>必要性是显而易见的，用反证法很容易证明。</p>\n<p>不太严谨地证明一下充分性：反证法，若不存在增广路且有一个更大的匹配 $M_1$，那么取两个匹配的边集的对称差，里面就是一些链和偶数长度的环。显然位于 $M_1$ 中的点的数量更多，所以可以找到一个从 $M_1$ 中的点出发的交错路，这就是增广路了。</p>\n<h2 id=\"Hungarian-Algorithm\"><a href=\"#Hungarian-Algorithm\" class=\"headerlink\" title=\"Hungarian Algorithm\"></a>Hungarian Algorithm</h2><p>有了增广路定理的基础后，匈牙利算法的原理就更容易理解了。逐一枚举二分图左部的顶点，每次寻找一条增广路，只要找到增广路就进行增广，并更新匹配结果；否则意味着能与这个点匹配的右部的点已经被耗尽了，之前占用这些右部的点的左部的点也转不到别的地方去，所以这个点已经彻底没用了，直接枚举下一个即可。</p>\n<p>参考代码以<a href=\"https://uoj.ac/problem/78\">UOJ#78. 二分图最大匹配</a>为例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">500</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; g[maxn];</span><br><span class=\"line\"><span class=\"type\">int</span> matchL[maxn], matchR[maxn], vis[maxn];</span><br><span class=\"line\"><span class=\"type\">int</span> L, R, k;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">augment</span><span class=\"params\">(<span class=\"type\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;v : g[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (vis[v])</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        vis[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!matchR[v] || <span class=\"built_in\">augment</span>(matchR[v])) &#123;</span><br><span class=\"line\">            matchR[v] = u;</span><br><span class=\"line\">            matchL[u] = v;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Hungarian</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> u = <span class=\"number\">1</span>; u &lt;= L; ++u) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">augment</span>(u))</span><br><span class=\"line\">            ++cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    cin &gt;&gt; L &gt;&gt; R &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>, u, v; i &lt;= k; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">        g[u].<span class=\"built_in\">push_back</span>(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">Hungarian</span>() &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= L; ++i) &#123;</span><br><span class=\"line\">        cout &lt;&lt; matchL[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显而易见，匈牙利算法的时间复杂度是 $O(|V||E|)$。</p>\n<h2 id=\"Hopcroft–Karp-Algorithm\"><a href=\"#Hopcroft–Karp-Algorithm\" class=\"headerlink\" title=\"Hopcroft–Karp Algorithm\"></a>Hopcroft–Karp Algorithm</h2><p>二分图的最大匹配问题容易转化为最大流问题，所以也可以用网络流算法解决。由于二分图的特殊性，用 Dinic 算法求最大匹配的时间复杂度仅为 $O(\\sqrt{|V|}|E|)$。Dinic 算法的一大特点是多路增广，其实匈牙利算法也可以用多路增广优化到同样的复杂度，这就是 Hopcroft–Karp 算法。</p>\n<p>具体内容心情好了再写。</p>\n<h2 id=\"Kuhn–Munkres-Algorithm\"><a href=\"#Kuhn–Munkres-Algorithm\" class=\"headerlink\" title=\"Kuhn–Munkres Algorithm\"></a>Kuhn–Munkres Algorithm</h2><p>未完待续</p>\n","excerpt":"<p>二分图匹配问题与 KM 算法</p>","more":"<p>二分图匹配的概念很容易理解：假设现在有一个二分图 $G&#x3D;(V,E)$，对于它的一个子图 $M&#x3D;(V_M,E_M)$，如果边集 $E_M$ 的所有边均没有共同的顶点，$M$ 就是 $G$ 的一个匹配。</p>\n<p>对于一个匹配 $M$，其边数 $|E_M|$ 就是匹配数。二分图的最大匹配问题就是让你找出一个匹配数最大的匹配。</p>\n<h2 id=\"增广路\"><a href=\"#增广路\" class=\"headerlink\" title=\"增广路\"></a>增广路</h2><p>在找最大匹配之前，先尝试解决一个简单的问题：如果当前找到的匹配有优化的空间（存在更大的匹配），如何优化当前解？</p>\n<p>如果这个问题可以比较简便的解决，那么就能够一步步得到最大匹配了。</p>\n<p>我们定义<strong>交错路径</strong>为这样的一种路径：从一个未匹配点出发，交替经过非匹配边与匹配边形成的路径。</p>\n<p>定义<strong>增广路</strong>为终点也是非匹配边的<strong>交错路径</strong>。</p>\n<p>容易发现，只要把增广路里的匹配边变成非匹配边，非匹配边变成匹配边，那么就增加了一个匹配。这就是增广的过程。</p>\n<p><strong>Berge’s lemma</strong>：匹配 $M$ 为图 $G&#x3D;(V, E)$ 的最大匹配当且仅当 $G$ 中不存在 $M$-增广路。</p>\n<p>必要性是显而易见的，用反证法很容易证明。</p>\n<p>不太严谨地证明一下充分性：反证法，若不存在增广路且有一个更大的匹配 $M_1$，那么取两个匹配的边集的对称差，里面就是一些链和偶数长度的环。显然位于 $M_1$ 中的点的数量更多，所以可以找到一个从 $M_1$ 中的点出发的交错路，这就是增广路了。</p>\n<h2 id=\"Hungarian-Algorithm\"><a href=\"#Hungarian-Algorithm\" class=\"headerlink\" title=\"Hungarian Algorithm\"></a>Hungarian Algorithm</h2><p>有了增广路定理的基础后，匈牙利算法的原理就更容易理解了。逐一枚举二分图左部的顶点，每次寻找一条增广路，只要找到增广路就进行增广，并更新匹配结果；否则意味着能与这个点匹配的右部的点已经被耗尽了，之前占用这些右部的点的左部的点也转不到别的地方去，所以这个点已经彻底没用了，直接枚举下一个即可。</p>\n<p>参考代码以<a href=\"https://uoj.ac/problem/78\">UOJ#78. 二分图最大匹配</a>为例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">500</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; g[maxn];</span><br><span class=\"line\"><span class=\"type\">int</span> matchL[maxn], matchR[maxn], vis[maxn];</span><br><span class=\"line\"><span class=\"type\">int</span> L, R, k;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">augment</span><span class=\"params\">(<span class=\"type\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;v : g[u]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (vis[v])</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        vis[v] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!matchR[v] || <span class=\"built_in\">augment</span>(matchR[v])) &#123;</span><br><span class=\"line\">            matchR[v] = u;</span><br><span class=\"line\">            matchL[u] = v;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Hungarian</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> u = <span class=\"number\">1</span>; u &lt;= L; ++u) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">augment</span>(u))</span><br><span class=\"line\">            ++cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    cin &gt;&gt; L &gt;&gt; R &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>, u, v; i &lt;= k; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">        g[u].<span class=\"built_in\">push_back</span>(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">Hungarian</span>() &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= L; ++i) &#123;</span><br><span class=\"line\">        cout &lt;&lt; matchL[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显而易见，匈牙利算法的时间复杂度是 $O(|V||E|)$。</p>\n<h2 id=\"Hopcroft–Karp-Algorithm\"><a href=\"#Hopcroft–Karp-Algorithm\" class=\"headerlink\" title=\"Hopcroft–Karp Algorithm\"></a>Hopcroft–Karp Algorithm</h2><p>二分图的最大匹配问题容易转化为最大流问题，所以也可以用网络流算法解决。由于二分图的特殊性，用 Dinic 算法求最大匹配的时间复杂度仅为 $O(\\sqrt{|V|}|E|)$。Dinic 算法的一大特点是多路增广，其实匈牙利算法也可以用多路增广优化到同样的复杂度，这就是 Hopcroft–Karp 算法。</p>\n<p>具体内容心情好了再写。</p>\n<h2 id=\"Kuhn–Munkres-Algorithm\"><a href=\"#Kuhn–Munkres-Algorithm\" class=\"headerlink\" title=\"Kuhn–Munkres Algorithm\"></a>Kuhn–Munkres Algorithm</h2><p>未完待续</p>"},{"title":"The Missing Part of Your Linear Algebra Course","date":"2022-07-23T16:00:00.000Z","math":true,"_content":"\n线性代数基础概念梳理\n\n<!--more-->\n\n在看正文之前，先试着忘记课堂上学到的线性代数的知识，然后从头开始，通过一个自然的流程来认识线性代数。\n\n## 线性方程组\n\n不去管那些奇怪的矩阵与行列式的概念，我们先从熟悉的线性方程和线性方程组入手。\n\n**线性方程**：形如 $a_1x_1+a_2x_2+\\cdots+a_nx_n=b$ 的方程，变量的幂次均为 $1$。\n\n**线性方程组**：一个或多个包含相同变量的线性方程。\n\n线性方程组的**解**是一组数 $(s_1,s_2,\\cdots,s_n)$，用这些数来代替所有变量，能够使等式成立。\n\n线性方程组的**解集**是所有可能的解的集合。\n\n如果两个线性方程组的解集相同，那么这两个线性方程组就是等价的。\n\n上面的这些概念都非常简单，就不多做解释了。线性代数最基础的部分就是对线性方程组的研究。在求解线性方程组的时候，有两个非常重要的问题：\n\n- 方程组是否有解？\n- 如果有解，解是否唯一？\n\n后续有很多概念都是从这两个问题引出的，所以先列出这两个问题，或许有助于理解那些概念。\n\n## 矩阵\n\n### 定义\n\n我们在做中学数学题的时候常常需要求解线性方程组。一般来说，在方程很多或者变量很多的时候，计算起来就会非常麻烦。所以，在面对复杂的线性方程组的时候，最好有一种较为简便的方法，再配上一套明确的流程，就大大有助于问题的求解。\n\n矩阵就是这样一个可以简化问题的东西。对于一个线性方程组，可以用矩阵来表示一个它的主要信息。\n\n举个最简单的例子，有这么一个线性方程组：\n\n$$\n\\begin{array}{r}\n11x_1+45x_2=14\\\\\n19x_1+198x_2=10\n\\end{array}\n$$\n\n如果只把每个变量的系数取出来列到一个方阵里，就称为**系数矩阵**：\n\n$$\n\\left[ \\begin{array}{ccc}\n11 & 45\\\\\n19 & 198 \n\\end{array} \\right]\n$$\n\n而**增广矩阵**就是在系数矩阵的右边加上原方程组中常数的一列：\n\n$$\n\\left[ \\begin{array}{ccc}\n11 & 45 & 14\\\\\n19 & 198 & 10\n\\end{array} \\right]\n$$\n\n我们用**维度**来描述矩阵的大小，比如上面的增广矩阵有两行三列，就是一个 $2\\times 3$ 矩阵。\n\n矩阵的定义就是这么简单。接下来要做的，就是从一般的线性方程组的解法出发，将其推广到矩阵上。\n\n### 初等行变换\n\n求解线性方程组的一个常见的思路是消元。比如对于上面的方程组，一般的做法是把第其中一个方程两边乘上一个常数，然后加到另一个方程的两边，这样就把一个变量消掉了。\n\n我们可以总结一下这样的过程，发现我们求解线性方程组的时候一般会进行这三种变换：\n\n- 把一个方程所有的项乘上一个常数\n- 把一个方程变为它和另一个方程的倍数的和\n- 交换两个方程的位置\n\n第三种变换看似奇怪，但它是绝对正确的。一方面来说，在列线性方程组的时候，交换两个方程的位置的确不会产生任何影响；另一方面来说，第三种变换可以看作前两种共同作用的结果（想象一下不用额外空间交换两个变量的过程）：\n\n$$\nA=a,B=b\\\\\n\\downarrow \\\\\nA=A-B=a-b\\\\\n\\downarrow \\\\\nB=A+B=a\\\\\n\\downarrow \\\\\nA=B-A=b\\\\\n\\downarrow \\\\\nA=b,B=a\n$$\n\n\n将这三种变换对应到增广矩阵里，就被称为矩阵的三种**初等行变换**：\n\n- 把一行的所有元素乘上一个非零常数（倍乘变换）\n- 把某一行的倍数加到另一行上（倍加变换）\n- 交换两行（对换变换）\n\n显而易见的一点是，行变换是可逆的。行变换可以施加到任意的矩阵，只要一个矩阵可以通过初等行变换变成另一个矩阵，我们就称这两个矩阵是**行等价**的。如果两个线性方程组的增广矩阵是行等价的，那么它们具有相同的解集。\n\n结合线性方程组的性质，我们可以自然的得出，矩阵可以与标量相乘，相同维度的矩阵也可以相加减。\n\n### 行化简\n\n我们在求解线性方程组的时候，一般会先把某个方程的变量消到只剩一个，然后求出这个变量的解，将其代入到其余的方程中，再求出下一个变量的解，以此类推。\n\n利用三种初等行变换，也可以在矩阵中模拟这个过程，这就是行化简的想法。通过行化简，可以把矩阵变成**阶梯型**。所谓阶梯型矩阵，就是满足下列三个条件的矩阵：\n\n- 每一非零行都在零行之上\n- 每行的先导元素均在上一行的先导元素之右\n- 每个先导元素的下面的元素都是零\n\n显然，阶梯型矩阵对应的线性方程组非常容易求解，只要从下往上消元就行了。如果更进一步，得到每个变量的解，对应的就是**简化阶梯型**矩阵：\n\n如果一个阶梯型矩阵每一非零行的先导元素都是 $1$，且每个先导元素都是这一列的唯一非零元素，就称其为简化阶梯型。\n\n通过不同的化简方式，矩阵可以化为不同的阶梯型矩阵，但简化阶梯型矩阵是**唯一**的。\n\n## 向量\n\n下面我们从特殊情况出发，换一个视角看待问题。\n\n### 定义\n\n只含一列的矩阵称为列向量，简称向量。\n\n例如\n\n$$\n\\boldsymbol{v} =\\left[ \\begin{array}{ccc}\nx \\\\\ny \n\\end{array} \\right]\n$$\n\n这里 $\\boldsymbol{v}$ 就是一个含有两个元素的向量。\n\n注意向量是一个特殊的矩阵，因此它也具有矩阵的性质：\n\n- 向量中的元素是有序的，只有对应位置的元素相等，两个向量才相等\n- 向量可以和标量相乘\n- 两个维度相等的向量可以加减\n\n### 线性组合\n\n定义**向量空间** $\\mathbb{R}^n$ 表示所有 $n$ 维向量。\n\n对于向量空间 $\\mathbb{R}^n$ 中的向量，$c_1,c_2,\\cdots,c_p$ 是标量，则向量 $y=\\sum_{i=1}^{p}c_i \\boldsymbol{v_i}$ 称为向量 $\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}$ 以 $c_1,c_2,\\cdots,c_p$ 为权的**线性组合**。\n\n若 $\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}$ 是 $\\mathbb{R}^n$ 中的向量，则它们的所有线性组合用 $\\text{Span}\\{\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}\\}$ 表示，称为 $\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}$ 生成的 $\\mathbb{R}^n$ 的子集（子空间）。\n\n做了这么多的铺垫，终于可以引出线性代数的一个基本思想：将向量的线性组合看作矩阵与向量的积。\n\n这种说法可能不太好理解，所以再举一个例子。比如有一个线性方程组：\n\n$$\n\\left\\{ \\begin{array}{clc}\na_{11}x_1+a_{12}x_2+\\cdots +a_{1n}x_n = b_1\\\\\na_{21}x_1+a_{22}x_2+\\cdots +a_{2n}x_n = b_2\\\\\n\\vdots \\\\\na_{m1}x_1+a_{m2}x_2+\\cdots +a_{mn}x_n = b_m\n\\end{array} \\right.\n$$\n\n定义向量\n\n$$\n\\boldsymbol{a_i} =\\left[ \\begin{array}{ccc}\na_{i1} \\\\\na_{i2} \\\\\n\\vdots \\\\\na_{im}\n\\end{array} \\right]\n$$\n\n$$\n\\boldsymbol{b} =\\left[ \\begin{array}{ccc}\nb_{1} \\\\\nb_{2} \\\\\n\\vdots \\\\\nb_{m}\n\\end{array} \\right]\n$$\n\n判断一个向量是否是若干个向量的线性组合，就相当于求解以权值作为变量的线性方程组。根据之前的定义，$\\lbrace \\boldsymbol{a_i}\\rbrace$ 就是原来有的这些向量，$\\boldsymbol{b}$ 就是用来判断的向量，变量 $x_i$ 对应了 $a_i$ 组合的权值。\n\n所以这个方程组也可以写成向量方程的形式（向量的线性组合），即\n\n$$\n\\boldsymbol{a_1}x_1+\\boldsymbol{a_2}x_2+\\cdots+\\boldsymbol{a_n}x_n=\\boldsymbol{b}\n$$\n\n也可以认为所有 $x_i$ 形成了一个 $n$ 维向量 $\\boldsymbol{x}$，就列出了一个矩阵方程（矩阵与向量的积）：\n\n$$A\\boldsymbol{x}=\\boldsymbol{b}$$\n\n它和上面的向量方程是等价的，具有相同的解集。\n\n当然，它们和增广矩阵为 $[\\boldsymbol{a_1}\\;\\boldsymbol{a_2}\\;\\cdots\\;\\boldsymbol{a_n}\\;\\boldsymbol{b}]$ 的线性方程组也具有相同的解集。\n\n根据上面的定义，我们可以直接得出矩阵方程 $A\\boldsymbol{x}=\\boldsymbol{b}$ 有解当且仅当 $\\boldsymbol{b}$ 是 $A$ 的各列的线性组合。\n\n### 线性相关\n\n定义**齐次方程组**为线性方程组 $A\\boldsymbol{x}=\\boldsymbol{0}$。\n\n显而易见，$\\boldsymbol{x}=\\boldsymbol{0}$ 是该矩阵方程的一个解。这就是齐次方程组的**平凡解**。\n\n如果向量组 $A$ 的向量方程 $A\\boldsymbol{x}=\\boldsymbol{0}$ 没有非平凡解，就称 $A$ 中的向量是**线性无关**的。\n\n也就是说，如果 $A$ 中的向量不能通过线性组合表示出零向量，它们就是线性无关的。反之，则可以通过移项得到：至少有一个向量可以被若干个其它的向量线性表示出，因此它们是线性相关的。\n\n显然，如果 $A$ 中含有零向量，或者向量个数超过向量的维数，就必定是线性相关的。\n\n## 线性变换\n\n对于矩阵方程 $A\\boldsymbol{x}=\\boldsymbol{b}$，我们可以从另一个角度去看。我们一开始有一个向量 $\\boldsymbol{x}$，受到了矩阵 $A$ 的作用后，变成了向量 $\\boldsymbol{b}$。这就像是对它作用了一个函数一样，这样的映射就是矩阵变换。\n\n在上面的例子里，$T$ 是这个映射的规则，假设定义域为 $\\mathbb{R}^{n}$，余定义域（相当于值域）为 $\\mathbb{R}^m$，则表示为：\n\n$$\nT:\\mathbb{R}^n\\to\\mathbb{R}^m\n$$\n\n线性变换的定义是满足向量的加法运算与标量的乘法运算，即对于定义域中一切 $\\boldsymbol{u},\\boldsymbol{v}$，满足：\n\n$$\nT(\\boldsymbol{u}+\\boldsymbol{v})=T(\\boldsymbol{u})+T(\\boldsymbol{v})\\\\\nT(c\\boldsymbol{u})=cT(\\boldsymbol{u})\n$$\n\n可以证明，$\\mathbb{R}^n\\to\\mathbb{R}^m$ 的所有线性变换实际上都是矩阵变换。\n\n线性变换有很多神奇的用途，以后有空再写。\n\n## 后记\n\n本文是在阅读了《线性代数及其应用》后，为了巩固与日后复习而写的。\n\n线性代数这门课我是大一上学期学的，由于教材质量低下，与其说是学线性代数，不如说是学做线性代数习题的方法。课程结束后，那些死记硬背的奇怪概念很快的忘记了，对于线性代数的本质也完全没有理解。现在再看到线性代数的题目时，对于用到的结论更是感觉非常诡异。所以我决定推倒重来，沿着一个自然的学习路线重新学习线性代数，希望可以真正的理解它的内涵。\n\n>将所见到的剑招忘得半点不剩，才能得其神髓，临敌时以意驭剑，千变万化，无穷无尽。倘若尚有一两招剑法忘不干净，心有拘囿，剑法便不能纯。——《倚天屠龙记》\n\n","source":"_posts/LA0.md","raw":"---\ntitle: The Missing Part of Your Linear Algebra Course\ndate: 2022-07-24\ntag: [linear algebra]\ncategory: [Linear Algebra]\nmath: true\n---\n\n线性代数基础概念梳理\n\n<!--more-->\n\n在看正文之前，先试着忘记课堂上学到的线性代数的知识，然后从头开始，通过一个自然的流程来认识线性代数。\n\n## 线性方程组\n\n不去管那些奇怪的矩阵与行列式的概念，我们先从熟悉的线性方程和线性方程组入手。\n\n**线性方程**：形如 $a_1x_1+a_2x_2+\\cdots+a_nx_n=b$ 的方程，变量的幂次均为 $1$。\n\n**线性方程组**：一个或多个包含相同变量的线性方程。\n\n线性方程组的**解**是一组数 $(s_1,s_2,\\cdots,s_n)$，用这些数来代替所有变量，能够使等式成立。\n\n线性方程组的**解集**是所有可能的解的集合。\n\n如果两个线性方程组的解集相同，那么这两个线性方程组就是等价的。\n\n上面的这些概念都非常简单，就不多做解释了。线性代数最基础的部分就是对线性方程组的研究。在求解线性方程组的时候，有两个非常重要的问题：\n\n- 方程组是否有解？\n- 如果有解，解是否唯一？\n\n后续有很多概念都是从这两个问题引出的，所以先列出这两个问题，或许有助于理解那些概念。\n\n## 矩阵\n\n### 定义\n\n我们在做中学数学题的时候常常需要求解线性方程组。一般来说，在方程很多或者变量很多的时候，计算起来就会非常麻烦。所以，在面对复杂的线性方程组的时候，最好有一种较为简便的方法，再配上一套明确的流程，就大大有助于问题的求解。\n\n矩阵就是这样一个可以简化问题的东西。对于一个线性方程组，可以用矩阵来表示一个它的主要信息。\n\n举个最简单的例子，有这么一个线性方程组：\n\n$$\n\\begin{array}{r}\n11x_1+45x_2=14\\\\\n19x_1+198x_2=10\n\\end{array}\n$$\n\n如果只把每个变量的系数取出来列到一个方阵里，就称为**系数矩阵**：\n\n$$\n\\left[ \\begin{array}{ccc}\n11 & 45\\\\\n19 & 198 \n\\end{array} \\right]\n$$\n\n而**增广矩阵**就是在系数矩阵的右边加上原方程组中常数的一列：\n\n$$\n\\left[ \\begin{array}{ccc}\n11 & 45 & 14\\\\\n19 & 198 & 10\n\\end{array} \\right]\n$$\n\n我们用**维度**来描述矩阵的大小，比如上面的增广矩阵有两行三列，就是一个 $2\\times 3$ 矩阵。\n\n矩阵的定义就是这么简单。接下来要做的，就是从一般的线性方程组的解法出发，将其推广到矩阵上。\n\n### 初等行变换\n\n求解线性方程组的一个常见的思路是消元。比如对于上面的方程组，一般的做法是把第其中一个方程两边乘上一个常数，然后加到另一个方程的两边，这样就把一个变量消掉了。\n\n我们可以总结一下这样的过程，发现我们求解线性方程组的时候一般会进行这三种变换：\n\n- 把一个方程所有的项乘上一个常数\n- 把一个方程变为它和另一个方程的倍数的和\n- 交换两个方程的位置\n\n第三种变换看似奇怪，但它是绝对正确的。一方面来说，在列线性方程组的时候，交换两个方程的位置的确不会产生任何影响；另一方面来说，第三种变换可以看作前两种共同作用的结果（想象一下不用额外空间交换两个变量的过程）：\n\n$$\nA=a,B=b\\\\\n\\downarrow \\\\\nA=A-B=a-b\\\\\n\\downarrow \\\\\nB=A+B=a\\\\\n\\downarrow \\\\\nA=B-A=b\\\\\n\\downarrow \\\\\nA=b,B=a\n$$\n\n\n将这三种变换对应到增广矩阵里，就被称为矩阵的三种**初等行变换**：\n\n- 把一行的所有元素乘上一个非零常数（倍乘变换）\n- 把某一行的倍数加到另一行上（倍加变换）\n- 交换两行（对换变换）\n\n显而易见的一点是，行变换是可逆的。行变换可以施加到任意的矩阵，只要一个矩阵可以通过初等行变换变成另一个矩阵，我们就称这两个矩阵是**行等价**的。如果两个线性方程组的增广矩阵是行等价的，那么它们具有相同的解集。\n\n结合线性方程组的性质，我们可以自然的得出，矩阵可以与标量相乘，相同维度的矩阵也可以相加减。\n\n### 行化简\n\n我们在求解线性方程组的时候，一般会先把某个方程的变量消到只剩一个，然后求出这个变量的解，将其代入到其余的方程中，再求出下一个变量的解，以此类推。\n\n利用三种初等行变换，也可以在矩阵中模拟这个过程，这就是行化简的想法。通过行化简，可以把矩阵变成**阶梯型**。所谓阶梯型矩阵，就是满足下列三个条件的矩阵：\n\n- 每一非零行都在零行之上\n- 每行的先导元素均在上一行的先导元素之右\n- 每个先导元素的下面的元素都是零\n\n显然，阶梯型矩阵对应的线性方程组非常容易求解，只要从下往上消元就行了。如果更进一步，得到每个变量的解，对应的就是**简化阶梯型**矩阵：\n\n如果一个阶梯型矩阵每一非零行的先导元素都是 $1$，且每个先导元素都是这一列的唯一非零元素，就称其为简化阶梯型。\n\n通过不同的化简方式，矩阵可以化为不同的阶梯型矩阵，但简化阶梯型矩阵是**唯一**的。\n\n## 向量\n\n下面我们从特殊情况出发，换一个视角看待问题。\n\n### 定义\n\n只含一列的矩阵称为列向量，简称向量。\n\n例如\n\n$$\n\\boldsymbol{v} =\\left[ \\begin{array}{ccc}\nx \\\\\ny \n\\end{array} \\right]\n$$\n\n这里 $\\boldsymbol{v}$ 就是一个含有两个元素的向量。\n\n注意向量是一个特殊的矩阵，因此它也具有矩阵的性质：\n\n- 向量中的元素是有序的，只有对应位置的元素相等，两个向量才相等\n- 向量可以和标量相乘\n- 两个维度相等的向量可以加减\n\n### 线性组合\n\n定义**向量空间** $\\mathbb{R}^n$ 表示所有 $n$ 维向量。\n\n对于向量空间 $\\mathbb{R}^n$ 中的向量，$c_1,c_2,\\cdots,c_p$ 是标量，则向量 $y=\\sum_{i=1}^{p}c_i \\boldsymbol{v_i}$ 称为向量 $\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}$ 以 $c_1,c_2,\\cdots,c_p$ 为权的**线性组合**。\n\n若 $\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}$ 是 $\\mathbb{R}^n$ 中的向量，则它们的所有线性组合用 $\\text{Span}\\{\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}\\}$ 表示，称为 $\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}$ 生成的 $\\mathbb{R}^n$ 的子集（子空间）。\n\n做了这么多的铺垫，终于可以引出线性代数的一个基本思想：将向量的线性组合看作矩阵与向量的积。\n\n这种说法可能不太好理解，所以再举一个例子。比如有一个线性方程组：\n\n$$\n\\left\\{ \\begin{array}{clc}\na_{11}x_1+a_{12}x_2+\\cdots +a_{1n}x_n = b_1\\\\\na_{21}x_1+a_{22}x_2+\\cdots +a_{2n}x_n = b_2\\\\\n\\vdots \\\\\na_{m1}x_1+a_{m2}x_2+\\cdots +a_{mn}x_n = b_m\n\\end{array} \\right.\n$$\n\n定义向量\n\n$$\n\\boldsymbol{a_i} =\\left[ \\begin{array}{ccc}\na_{i1} \\\\\na_{i2} \\\\\n\\vdots \\\\\na_{im}\n\\end{array} \\right]\n$$\n\n$$\n\\boldsymbol{b} =\\left[ \\begin{array}{ccc}\nb_{1} \\\\\nb_{2} \\\\\n\\vdots \\\\\nb_{m}\n\\end{array} \\right]\n$$\n\n判断一个向量是否是若干个向量的线性组合，就相当于求解以权值作为变量的线性方程组。根据之前的定义，$\\lbrace \\boldsymbol{a_i}\\rbrace$ 就是原来有的这些向量，$\\boldsymbol{b}$ 就是用来判断的向量，变量 $x_i$ 对应了 $a_i$ 组合的权值。\n\n所以这个方程组也可以写成向量方程的形式（向量的线性组合），即\n\n$$\n\\boldsymbol{a_1}x_1+\\boldsymbol{a_2}x_2+\\cdots+\\boldsymbol{a_n}x_n=\\boldsymbol{b}\n$$\n\n也可以认为所有 $x_i$ 形成了一个 $n$ 维向量 $\\boldsymbol{x}$，就列出了一个矩阵方程（矩阵与向量的积）：\n\n$$A\\boldsymbol{x}=\\boldsymbol{b}$$\n\n它和上面的向量方程是等价的，具有相同的解集。\n\n当然，它们和增广矩阵为 $[\\boldsymbol{a_1}\\;\\boldsymbol{a_2}\\;\\cdots\\;\\boldsymbol{a_n}\\;\\boldsymbol{b}]$ 的线性方程组也具有相同的解集。\n\n根据上面的定义，我们可以直接得出矩阵方程 $A\\boldsymbol{x}=\\boldsymbol{b}$ 有解当且仅当 $\\boldsymbol{b}$ 是 $A$ 的各列的线性组合。\n\n### 线性相关\n\n定义**齐次方程组**为线性方程组 $A\\boldsymbol{x}=\\boldsymbol{0}$。\n\n显而易见，$\\boldsymbol{x}=\\boldsymbol{0}$ 是该矩阵方程的一个解。这就是齐次方程组的**平凡解**。\n\n如果向量组 $A$ 的向量方程 $A\\boldsymbol{x}=\\boldsymbol{0}$ 没有非平凡解，就称 $A$ 中的向量是**线性无关**的。\n\n也就是说，如果 $A$ 中的向量不能通过线性组合表示出零向量，它们就是线性无关的。反之，则可以通过移项得到：至少有一个向量可以被若干个其它的向量线性表示出，因此它们是线性相关的。\n\n显然，如果 $A$ 中含有零向量，或者向量个数超过向量的维数，就必定是线性相关的。\n\n## 线性变换\n\n对于矩阵方程 $A\\boldsymbol{x}=\\boldsymbol{b}$，我们可以从另一个角度去看。我们一开始有一个向量 $\\boldsymbol{x}$，受到了矩阵 $A$ 的作用后，变成了向量 $\\boldsymbol{b}$。这就像是对它作用了一个函数一样，这样的映射就是矩阵变换。\n\n在上面的例子里，$T$ 是这个映射的规则，假设定义域为 $\\mathbb{R}^{n}$，余定义域（相当于值域）为 $\\mathbb{R}^m$，则表示为：\n\n$$\nT:\\mathbb{R}^n\\to\\mathbb{R}^m\n$$\n\n线性变换的定义是满足向量的加法运算与标量的乘法运算，即对于定义域中一切 $\\boldsymbol{u},\\boldsymbol{v}$，满足：\n\n$$\nT(\\boldsymbol{u}+\\boldsymbol{v})=T(\\boldsymbol{u})+T(\\boldsymbol{v})\\\\\nT(c\\boldsymbol{u})=cT(\\boldsymbol{u})\n$$\n\n可以证明，$\\mathbb{R}^n\\to\\mathbb{R}^m$ 的所有线性变换实际上都是矩阵变换。\n\n线性变换有很多神奇的用途，以后有空再写。\n\n## 后记\n\n本文是在阅读了《线性代数及其应用》后，为了巩固与日后复习而写的。\n\n线性代数这门课我是大一上学期学的，由于教材质量低下，与其说是学线性代数，不如说是学做线性代数习题的方法。课程结束后，那些死记硬背的奇怪概念很快的忘记了，对于线性代数的本质也完全没有理解。现在再看到线性代数的题目时，对于用到的结论更是感觉非常诡异。所以我决定推倒重来，沿着一个自然的学习路线重新学习线性代数，希望可以真正的理解它的内涵。\n\n>将所见到的剑招忘得半点不剩，才能得其神髓，临敌时以意驭剑，千变万化，无穷无尽。倘若尚有一两招剑法忘不干净，心有拘囿，剑法便不能纯。——《倚天屠龙记》\n\n","slug":"LA0","published":1,"updated":"2023-02-25T05:46:11.829Z","comments":1,"layout":"post","photos":[],"_id":"cmir5cbx8000c2cleg5kagkqt","content":"<p>线性代数基础概念梳理</p>\n<span id=\"more\"></span>\n\n<p>在看正文之前，先试着忘记课堂上学到的线性代数的知识，然后从头开始，通过一个自然的流程来认识线性代数。</p>\n<h2 id=\"线性方程组\"><a href=\"#线性方程组\" class=\"headerlink\" title=\"线性方程组\"></a>线性方程组</h2><p>不去管那些奇怪的矩阵与行列式的概念，我们先从熟悉的线性方程和线性方程组入手。</p>\n<p><strong>线性方程</strong>：形如 $a_1x_1+a_2x_2+\\cdots+a_nx_n&#x3D;b$ 的方程，变量的幂次均为 $1$。</p>\n<p><strong>线性方程组</strong>：一个或多个包含相同变量的线性方程。</p>\n<p>线性方程组的<strong>解</strong>是一组数 $(s_1,s_2,\\cdots,s_n)$，用这些数来代替所有变量，能够使等式成立。</p>\n<p>线性方程组的<strong>解集</strong>是所有可能的解的集合。</p>\n<p>如果两个线性方程组的解集相同，那么这两个线性方程组就是等价的。</p>\n<p>上面的这些概念都非常简单，就不多做解释了。线性代数最基础的部分就是对线性方程组的研究。在求解线性方程组的时候，有两个非常重要的问题：</p>\n<ul>\n<li>方程组是否有解？</li>\n<li>如果有解，解是否唯一？</li>\n</ul>\n<p>后续有很多概念都是从这两个问题引出的，所以先列出这两个问题，或许有助于理解那些概念。</p>\n<h2 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>我们在做中学数学题的时候常常需要求解线性方程组。一般来说，在方程很多或者变量很多的时候，计算起来就会非常麻烦。所以，在面对复杂的线性方程组的时候，最好有一种较为简便的方法，再配上一套明确的流程，就大大有助于问题的求解。</p>\n<p>矩阵就是这样一个可以简化问题的东西。对于一个线性方程组，可以用矩阵来表示一个它的主要信息。</p>\n<p>举个最简单的例子，有这么一个线性方程组：</p>\n<p>$$<br>\\begin{array}{r}<br>11x_1+45x_2&#x3D;14\\<br>19x_1+198x_2&#x3D;10<br>\\end{array}<br>$$</p>\n<p>如果只把每个变量的系数取出来列到一个方阵里，就称为<strong>系数矩阵</strong>：</p>\n<p>$$<br>\\left[ \\begin{array}{ccc}<br>11 &amp; 45\\<br>19 &amp; 198<br>\\end{array} \\right]<br>$$</p>\n<p>而<strong>增广矩阵</strong>就是在系数矩阵的右边加上原方程组中常数的一列：</p>\n<p>$$<br>\\left[ \\begin{array}{ccc}<br>11 &amp; 45 &amp; 14\\<br>19 &amp; 198 &amp; 10<br>\\end{array} \\right]<br>$$</p>\n<p>我们用<strong>维度</strong>来描述矩阵的大小，比如上面的增广矩阵有两行三列，就是一个 $2\\times 3$ 矩阵。</p>\n<p>矩阵的定义就是这么简单。接下来要做的，就是从一般的线性方程组的解法出发，将其推广到矩阵上。</p>\n<h3 id=\"初等行变换\"><a href=\"#初等行变换\" class=\"headerlink\" title=\"初等行变换\"></a>初等行变换</h3><p>求解线性方程组的一个常见的思路是消元。比如对于上面的方程组，一般的做法是把第其中一个方程两边乘上一个常数，然后加到另一个方程的两边，这样就把一个变量消掉了。</p>\n<p>我们可以总结一下这样的过程，发现我们求解线性方程组的时候一般会进行这三种变换：</p>\n<ul>\n<li>把一个方程所有的项乘上一个常数</li>\n<li>把一个方程变为它和另一个方程的倍数的和</li>\n<li>交换两个方程的位置</li>\n</ul>\n<p>第三种变换看似奇怪，但它是绝对正确的。一方面来说，在列线性方程组的时候，交换两个方程的位置的确不会产生任何影响；另一方面来说，第三种变换可以看作前两种共同作用的结果（想象一下不用额外空间交换两个变量的过程）：</p>\n<p>$$<br>A&#x3D;a,B&#x3D;b\\<br>\\downarrow \\<br>A&#x3D;A-B&#x3D;a-b\\<br>\\downarrow \\<br>B&#x3D;A+B&#x3D;a\\<br>\\downarrow \\<br>A&#x3D;B-A&#x3D;b\\<br>\\downarrow \\<br>A&#x3D;b,B&#x3D;a<br>$$</p>\n<p>将这三种变换对应到增广矩阵里，就被称为矩阵的三种<strong>初等行变换</strong>：</p>\n<ul>\n<li>把一行的所有元素乘上一个非零常数（倍乘变换）</li>\n<li>把某一行的倍数加到另一行上（倍加变换）</li>\n<li>交换两行（对换变换）</li>\n</ul>\n<p>显而易见的一点是，行变换是可逆的。行变换可以施加到任意的矩阵，只要一个矩阵可以通过初等行变换变成另一个矩阵，我们就称这两个矩阵是<strong>行等价</strong>的。如果两个线性方程组的增广矩阵是行等价的，那么它们具有相同的解集。</p>\n<p>结合线性方程组的性质，我们可以自然的得出，矩阵可以与标量相乘，相同维度的矩阵也可以相加减。</p>\n<h3 id=\"行化简\"><a href=\"#行化简\" class=\"headerlink\" title=\"行化简\"></a>行化简</h3><p>我们在求解线性方程组的时候，一般会先把某个方程的变量消到只剩一个，然后求出这个变量的解，将其代入到其余的方程中，再求出下一个变量的解，以此类推。</p>\n<p>利用三种初等行变换，也可以在矩阵中模拟这个过程，这就是行化简的想法。通过行化简，可以把矩阵变成<strong>阶梯型</strong>。所谓阶梯型矩阵，就是满足下列三个条件的矩阵：</p>\n<ul>\n<li>每一非零行都在零行之上</li>\n<li>每行的先导元素均在上一行的先导元素之右</li>\n<li>每个先导元素的下面的元素都是零</li>\n</ul>\n<p>显然，阶梯型矩阵对应的线性方程组非常容易求解，只要从下往上消元就行了。如果更进一步，得到每个变量的解，对应的就是<strong>简化阶梯型</strong>矩阵：</p>\n<p>如果一个阶梯型矩阵每一非零行的先导元素都是 $1$，且每个先导元素都是这一列的唯一非零元素，就称其为简化阶梯型。</p>\n<p>通过不同的化简方式，矩阵可以化为不同的阶梯型矩阵，但简化阶梯型矩阵是<strong>唯一</strong>的。</p>\n<h2 id=\"向量\"><a href=\"#向量\" class=\"headerlink\" title=\"向量\"></a>向量</h2><p>下面我们从特殊情况出发，换一个视角看待问题。</p>\n<h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>只含一列的矩阵称为列向量，简称向量。</p>\n<p>例如</p>\n<p>$$<br>\\boldsymbol{v} &#x3D;\\left[ \\begin{array}{ccc}<br>x \\<br>y<br>\\end{array} \\right]<br>$$</p>\n<p>这里 $\\boldsymbol{v}$ 就是一个含有两个元素的向量。</p>\n<p>注意向量是一个特殊的矩阵，因此它也具有矩阵的性质：</p>\n<ul>\n<li>向量中的元素是有序的，只有对应位置的元素相等，两个向量才相等</li>\n<li>向量可以和标量相乘</li>\n<li>两个维度相等的向量可以加减</li>\n</ul>\n<h3 id=\"线性组合\"><a href=\"#线性组合\" class=\"headerlink\" title=\"线性组合\"></a>线性组合</h3><p>定义<strong>向量空间</strong> $\\mathbb{R}^n$ 表示所有 $n$ 维向量。</p>\n<p>对于向量空间 $\\mathbb{R}^n$ 中的向量，$c_1,c_2,\\cdots,c_p$ 是标量，则向量 $y&#x3D;\\sum_{i&#x3D;1}^{p}c_i \\boldsymbol{v_i}$ 称为向量 $\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}$ 以 $c_1,c_2,\\cdots,c_p$ 为权的<strong>线性组合</strong>。</p>\n<p>若 $\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}$ 是 $\\mathbb{R}^n$ 中的向量，则它们的所有线性组合用 $\\text{Span}{\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}}$ 表示，称为 $\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}$ 生成的 $\\mathbb{R}^n$ 的子集（子空间）。</p>\n<p>做了这么多的铺垫，终于可以引出线性代数的一个基本思想：将向量的线性组合看作矩阵与向量的积。</p>\n<p>这种说法可能不太好理解，所以再举一个例子。比如有一个线性方程组：</p>\n<p>$$<br>\\left{ \\begin{array}{clc}<br>a_{11}x_1+a_{12}x_2+\\cdots +a_{1n}x_n &#x3D; b_1\\<br>a_{21}x_1+a_{22}x_2+\\cdots +a_{2n}x_n &#x3D; b_2\\<br>\\vdots \\<br>a_{m1}x_1+a_{m2}x_2+\\cdots +a_{mn}x_n &#x3D; b_m<br>\\end{array} \\right.<br>$$</p>\n<p>定义向量</p>\n<p>$$<br>\\boldsymbol{a_i} &#x3D;\\left[ \\begin{array}{ccc}<br>a_{i1} \\<br>a_{i2} \\<br>\\vdots \\<br>a_{im}<br>\\end{array} \\right]<br>$$</p>\n<p>$$<br>\\boldsymbol{b} &#x3D;\\left[ \\begin{array}{ccc}<br>b_{1} \\<br>b_{2} \\<br>\\vdots \\<br>b_{m}<br>\\end{array} \\right]<br>$$</p>\n<p>判断一个向量是否是若干个向量的线性组合，就相当于求解以权值作为变量的线性方程组。根据之前的定义，$\\lbrace \\boldsymbol{a_i}\\rbrace$ 就是原来有的这些向量，$\\boldsymbol{b}$ 就是用来判断的向量，变量 $x_i$ 对应了 $a_i$ 组合的权值。</p>\n<p>所以这个方程组也可以写成向量方程的形式（向量的线性组合），即</p>\n<p>$$<br>\\boldsymbol{a_1}x_1+\\boldsymbol{a_2}x_2+\\cdots+\\boldsymbol{a_n}x_n&#x3D;\\boldsymbol{b}<br>$$</p>\n<p>也可以认为所有 $x_i$ 形成了一个 $n$ 维向量 $\\boldsymbol{x}$，就列出了一个矩阵方程（矩阵与向量的积）：</p>\n<p>$$A\\boldsymbol{x}&#x3D;\\boldsymbol{b}$$</p>\n<p>它和上面的向量方程是等价的，具有相同的解集。</p>\n<p>当然，它们和增广矩阵为 $[\\boldsymbol{a_1};\\boldsymbol{a_2};\\cdots;\\boldsymbol{a_n};\\boldsymbol{b}]$ 的线性方程组也具有相同的解集。</p>\n<p>根据上面的定义，我们可以直接得出矩阵方程 $A\\boldsymbol{x}&#x3D;\\boldsymbol{b}$ 有解当且仅当 $\\boldsymbol{b}$ 是 $A$ 的各列的线性组合。</p>\n<h3 id=\"线性相关\"><a href=\"#线性相关\" class=\"headerlink\" title=\"线性相关\"></a>线性相关</h3><p>定义<strong>齐次方程组</strong>为线性方程组 $A\\boldsymbol{x}&#x3D;\\boldsymbol{0}$。</p>\n<p>显而易见，$\\boldsymbol{x}&#x3D;\\boldsymbol{0}$ 是该矩阵方程的一个解。这就是齐次方程组的<strong>平凡解</strong>。</p>\n<p>如果向量组 $A$ 的向量方程 $A\\boldsymbol{x}&#x3D;\\boldsymbol{0}$ 没有非平凡解，就称 $A$ 中的向量是<strong>线性无关</strong>的。</p>\n<p>也就是说，如果 $A$ 中的向量不能通过线性组合表示出零向量，它们就是线性无关的。反之，则可以通过移项得到：至少有一个向量可以被若干个其它的向量线性表示出，因此它们是线性相关的。</p>\n<p>显然，如果 $A$ 中含有零向量，或者向量个数超过向量的维数，就必定是线性相关的。</p>\n<h2 id=\"线性变换\"><a href=\"#线性变换\" class=\"headerlink\" title=\"线性变换\"></a>线性变换</h2><p>对于矩阵方程 $A\\boldsymbol{x}&#x3D;\\boldsymbol{b}$，我们可以从另一个角度去看。我们一开始有一个向量 $\\boldsymbol{x}$，受到了矩阵 $A$ 的作用后，变成了向量 $\\boldsymbol{b}$。这就像是对它作用了一个函数一样，这样的映射就是矩阵变换。</p>\n<p>在上面的例子里，$T$ 是这个映射的规则，假设定义域为 $\\mathbb{R}^{n}$，余定义域（相当于值域）为 $\\mathbb{R}^m$，则表示为：</p>\n<p>$$<br>T:\\mathbb{R}^n\\to\\mathbb{R}^m<br>$$</p>\n<p>线性变换的定义是满足向量的加法运算与标量的乘法运算，即对于定义域中一切 $\\boldsymbol{u},\\boldsymbol{v}$，满足：</p>\n<p>$$<br>T(\\boldsymbol{u}+\\boldsymbol{v})&#x3D;T(\\boldsymbol{u})+T(\\boldsymbol{v})\\<br>T(c\\boldsymbol{u})&#x3D;cT(\\boldsymbol{u})<br>$$</p>\n<p>可以证明，$\\mathbb{R}^n\\to\\mathbb{R}^m$ 的所有线性变换实际上都是矩阵变换。</p>\n<p>线性变换有很多神奇的用途，以后有空再写。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>本文是在阅读了《线性代数及其应用》后，为了巩固与日后复习而写的。</p>\n<p>线性代数这门课我是大一上学期学的，由于教材质量低下，与其说是学线性代数，不如说是学做线性代数习题的方法。课程结束后，那些死记硬背的奇怪概念很快的忘记了，对于线性代数的本质也完全没有理解。现在再看到线性代数的题目时，对于用到的结论更是感觉非常诡异。所以我决定推倒重来，沿着一个自然的学习路线重新学习线性代数，希望可以真正的理解它的内涵。</p>\n<blockquote>\n<p>将所见到的剑招忘得半点不剩，才能得其神髓，临敌时以意驭剑，千变万化，无穷无尽。倘若尚有一两招剑法忘不干净，心有拘囿，剑法便不能纯。——《倚天屠龙记》</p>\n</blockquote>\n","excerpt":"<p>线性代数基础概念梳理</p>","more":"<p>在看正文之前，先试着忘记课堂上学到的线性代数的知识，然后从头开始，通过一个自然的流程来认识线性代数。</p>\n<h2 id=\"线性方程组\"><a href=\"#线性方程组\" class=\"headerlink\" title=\"线性方程组\"></a>线性方程组</h2><p>不去管那些奇怪的矩阵与行列式的概念，我们先从熟悉的线性方程和线性方程组入手。</p>\n<p><strong>线性方程</strong>：形如 $a_1x_1+a_2x_2+\\cdots+a_nx_n&#x3D;b$ 的方程，变量的幂次均为 $1$。</p>\n<p><strong>线性方程组</strong>：一个或多个包含相同变量的线性方程。</p>\n<p>线性方程组的<strong>解</strong>是一组数 $(s_1,s_2,\\cdots,s_n)$，用这些数来代替所有变量，能够使等式成立。</p>\n<p>线性方程组的<strong>解集</strong>是所有可能的解的集合。</p>\n<p>如果两个线性方程组的解集相同，那么这两个线性方程组就是等价的。</p>\n<p>上面的这些概念都非常简单，就不多做解释了。线性代数最基础的部分就是对线性方程组的研究。在求解线性方程组的时候，有两个非常重要的问题：</p>\n<ul>\n<li>方程组是否有解？</li>\n<li>如果有解，解是否唯一？</li>\n</ul>\n<p>后续有很多概念都是从这两个问题引出的，所以先列出这两个问题，或许有助于理解那些概念。</p>\n<h2 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>我们在做中学数学题的时候常常需要求解线性方程组。一般来说，在方程很多或者变量很多的时候，计算起来就会非常麻烦。所以，在面对复杂的线性方程组的时候，最好有一种较为简便的方法，再配上一套明确的流程，就大大有助于问题的求解。</p>\n<p>矩阵就是这样一个可以简化问题的东西。对于一个线性方程组，可以用矩阵来表示一个它的主要信息。</p>\n<p>举个最简单的例子，有这么一个线性方程组：</p>\n<p>$$<br>\\begin{array}{r}<br>11x_1+45x_2&#x3D;14\\<br>19x_1+198x_2&#x3D;10<br>\\end{array}<br>$$</p>\n<p>如果只把每个变量的系数取出来列到一个方阵里，就称为<strong>系数矩阵</strong>：</p>\n<p>$$<br>\\left[ \\begin{array}{ccc}<br>11 &amp; 45\\<br>19 &amp; 198<br>\\end{array} \\right]<br>$$</p>\n<p>而<strong>增广矩阵</strong>就是在系数矩阵的右边加上原方程组中常数的一列：</p>\n<p>$$<br>\\left[ \\begin{array}{ccc}<br>11 &amp; 45 &amp; 14\\<br>19 &amp; 198 &amp; 10<br>\\end{array} \\right]<br>$$</p>\n<p>我们用<strong>维度</strong>来描述矩阵的大小，比如上面的增广矩阵有两行三列，就是一个 $2\\times 3$ 矩阵。</p>\n<p>矩阵的定义就是这么简单。接下来要做的，就是从一般的线性方程组的解法出发，将其推广到矩阵上。</p>\n<h3 id=\"初等行变换\"><a href=\"#初等行变换\" class=\"headerlink\" title=\"初等行变换\"></a>初等行变换</h3><p>求解线性方程组的一个常见的思路是消元。比如对于上面的方程组，一般的做法是把第其中一个方程两边乘上一个常数，然后加到另一个方程的两边，这样就把一个变量消掉了。</p>\n<p>我们可以总结一下这样的过程，发现我们求解线性方程组的时候一般会进行这三种变换：</p>\n<ul>\n<li>把一个方程所有的项乘上一个常数</li>\n<li>把一个方程变为它和另一个方程的倍数的和</li>\n<li>交换两个方程的位置</li>\n</ul>\n<p>第三种变换看似奇怪，但它是绝对正确的。一方面来说，在列线性方程组的时候，交换两个方程的位置的确不会产生任何影响；另一方面来说，第三种变换可以看作前两种共同作用的结果（想象一下不用额外空间交换两个变量的过程）：</p>\n<p>$$<br>A&#x3D;a,B&#x3D;b\\<br>\\downarrow \\<br>A&#x3D;A-B&#x3D;a-b\\<br>\\downarrow \\<br>B&#x3D;A+B&#x3D;a\\<br>\\downarrow \\<br>A&#x3D;B-A&#x3D;b\\<br>\\downarrow \\<br>A&#x3D;b,B&#x3D;a<br>$$</p>\n<p>将这三种变换对应到增广矩阵里，就被称为矩阵的三种<strong>初等行变换</strong>：</p>\n<ul>\n<li>把一行的所有元素乘上一个非零常数（倍乘变换）</li>\n<li>把某一行的倍数加到另一行上（倍加变换）</li>\n<li>交换两行（对换变换）</li>\n</ul>\n<p>显而易见的一点是，行变换是可逆的。行变换可以施加到任意的矩阵，只要一个矩阵可以通过初等行变换变成另一个矩阵，我们就称这两个矩阵是<strong>行等价</strong>的。如果两个线性方程组的增广矩阵是行等价的，那么它们具有相同的解集。</p>\n<p>结合线性方程组的性质，我们可以自然的得出，矩阵可以与标量相乘，相同维度的矩阵也可以相加减。</p>\n<h3 id=\"行化简\"><a href=\"#行化简\" class=\"headerlink\" title=\"行化简\"></a>行化简</h3><p>我们在求解线性方程组的时候，一般会先把某个方程的变量消到只剩一个，然后求出这个变量的解，将其代入到其余的方程中，再求出下一个变量的解，以此类推。</p>\n<p>利用三种初等行变换，也可以在矩阵中模拟这个过程，这就是行化简的想法。通过行化简，可以把矩阵变成<strong>阶梯型</strong>。所谓阶梯型矩阵，就是满足下列三个条件的矩阵：</p>\n<ul>\n<li>每一非零行都在零行之上</li>\n<li>每行的先导元素均在上一行的先导元素之右</li>\n<li>每个先导元素的下面的元素都是零</li>\n</ul>\n<p>显然，阶梯型矩阵对应的线性方程组非常容易求解，只要从下往上消元就行了。如果更进一步，得到每个变量的解，对应的就是<strong>简化阶梯型</strong>矩阵：</p>\n<p>如果一个阶梯型矩阵每一非零行的先导元素都是 $1$，且每个先导元素都是这一列的唯一非零元素，就称其为简化阶梯型。</p>\n<p>通过不同的化简方式，矩阵可以化为不同的阶梯型矩阵，但简化阶梯型矩阵是<strong>唯一</strong>的。</p>\n<h2 id=\"向量\"><a href=\"#向量\" class=\"headerlink\" title=\"向量\"></a>向量</h2><p>下面我们从特殊情况出发，换一个视角看待问题。</p>\n<h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>只含一列的矩阵称为列向量，简称向量。</p>\n<p>例如</p>\n<p>$$<br>\\boldsymbol{v} &#x3D;\\left[ \\begin{array}{ccc}<br>x \\<br>y<br>\\end{array} \\right]<br>$$</p>\n<p>这里 $\\boldsymbol{v}$ 就是一个含有两个元素的向量。</p>\n<p>注意向量是一个特殊的矩阵，因此它也具有矩阵的性质：</p>\n<ul>\n<li>向量中的元素是有序的，只有对应位置的元素相等，两个向量才相等</li>\n<li>向量可以和标量相乘</li>\n<li>两个维度相等的向量可以加减</li>\n</ul>\n<h3 id=\"线性组合\"><a href=\"#线性组合\" class=\"headerlink\" title=\"线性组合\"></a>线性组合</h3><p>定义<strong>向量空间</strong> $\\mathbb{R}^n$ 表示所有 $n$ 维向量。</p>\n<p>对于向量空间 $\\mathbb{R}^n$ 中的向量，$c_1,c_2,\\cdots,c_p$ 是标量，则向量 $y&#x3D;\\sum_{i&#x3D;1}^{p}c_i \\boldsymbol{v_i}$ 称为向量 $\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}$ 以 $c_1,c_2,\\cdots,c_p$ 为权的<strong>线性组合</strong>。</p>\n<p>若 $\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}$ 是 $\\mathbb{R}^n$ 中的向量，则它们的所有线性组合用 $\\text{Span}{\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}}$ 表示，称为 $\\boldsymbol{v_1},\\boldsymbol{v_2},\\cdots,\\boldsymbol{v_p}$ 生成的 $\\mathbb{R}^n$ 的子集（子空间）。</p>\n<p>做了这么多的铺垫，终于可以引出线性代数的一个基本思想：将向量的线性组合看作矩阵与向量的积。</p>\n<p>这种说法可能不太好理解，所以再举一个例子。比如有一个线性方程组：</p>\n<p>$$<br>\\left{ \\begin{array}{clc}<br>a_{11}x_1+a_{12}x_2+\\cdots +a_{1n}x_n &#x3D; b_1\\<br>a_{21}x_1+a_{22}x_2+\\cdots +a_{2n}x_n &#x3D; b_2\\<br>\\vdots \\<br>a_{m1}x_1+a_{m2}x_2+\\cdots +a_{mn}x_n &#x3D; b_m<br>\\end{array} \\right.<br>$$</p>\n<p>定义向量</p>\n<p>$$<br>\\boldsymbol{a_i} &#x3D;\\left[ \\begin{array}{ccc}<br>a_{i1} \\<br>a_{i2} \\<br>\\vdots \\<br>a_{im}<br>\\end{array} \\right]<br>$$</p>\n<p>$$<br>\\boldsymbol{b} &#x3D;\\left[ \\begin{array}{ccc}<br>b_{1} \\<br>b_{2} \\<br>\\vdots \\<br>b_{m}<br>\\end{array} \\right]<br>$$</p>\n<p>判断一个向量是否是若干个向量的线性组合，就相当于求解以权值作为变量的线性方程组。根据之前的定义，$\\lbrace \\boldsymbol{a_i}\\rbrace$ 就是原来有的这些向量，$\\boldsymbol{b}$ 就是用来判断的向量，变量 $x_i$ 对应了 $a_i$ 组合的权值。</p>\n<p>所以这个方程组也可以写成向量方程的形式（向量的线性组合），即</p>\n<p>$$<br>\\boldsymbol{a_1}x_1+\\boldsymbol{a_2}x_2+\\cdots+\\boldsymbol{a_n}x_n&#x3D;\\boldsymbol{b}<br>$$</p>\n<p>也可以认为所有 $x_i$ 形成了一个 $n$ 维向量 $\\boldsymbol{x}$，就列出了一个矩阵方程（矩阵与向量的积）：</p>\n<p>$$A\\boldsymbol{x}&#x3D;\\boldsymbol{b}$$</p>\n<p>它和上面的向量方程是等价的，具有相同的解集。</p>\n<p>当然，它们和增广矩阵为 $[\\boldsymbol{a_1};\\boldsymbol{a_2};\\cdots;\\boldsymbol{a_n};\\boldsymbol{b}]$ 的线性方程组也具有相同的解集。</p>\n<p>根据上面的定义，我们可以直接得出矩阵方程 $A\\boldsymbol{x}&#x3D;\\boldsymbol{b}$ 有解当且仅当 $\\boldsymbol{b}$ 是 $A$ 的各列的线性组合。</p>\n<h3 id=\"线性相关\"><a href=\"#线性相关\" class=\"headerlink\" title=\"线性相关\"></a>线性相关</h3><p>定义<strong>齐次方程组</strong>为线性方程组 $A\\boldsymbol{x}&#x3D;\\boldsymbol{0}$。</p>\n<p>显而易见，$\\boldsymbol{x}&#x3D;\\boldsymbol{0}$ 是该矩阵方程的一个解。这就是齐次方程组的<strong>平凡解</strong>。</p>\n<p>如果向量组 $A$ 的向量方程 $A\\boldsymbol{x}&#x3D;\\boldsymbol{0}$ 没有非平凡解，就称 $A$ 中的向量是<strong>线性无关</strong>的。</p>\n<p>也就是说，如果 $A$ 中的向量不能通过线性组合表示出零向量，它们就是线性无关的。反之，则可以通过移项得到：至少有一个向量可以被若干个其它的向量线性表示出，因此它们是线性相关的。</p>\n<p>显然，如果 $A$ 中含有零向量，或者向量个数超过向量的维数，就必定是线性相关的。</p>\n<h2 id=\"线性变换\"><a href=\"#线性变换\" class=\"headerlink\" title=\"线性变换\"></a>线性变换</h2><p>对于矩阵方程 $A\\boldsymbol{x}&#x3D;\\boldsymbol{b}$，我们可以从另一个角度去看。我们一开始有一个向量 $\\boldsymbol{x}$，受到了矩阵 $A$ 的作用后，变成了向量 $\\boldsymbol{b}$。这就像是对它作用了一个函数一样，这样的映射就是矩阵变换。</p>\n<p>在上面的例子里，$T$ 是这个映射的规则，假设定义域为 $\\mathbb{R}^{n}$，余定义域（相当于值域）为 $\\mathbb{R}^m$，则表示为：</p>\n<p>$$<br>T:\\mathbb{R}^n\\to\\mathbb{R}^m<br>$$</p>\n<p>线性变换的定义是满足向量的加法运算与标量的乘法运算，即对于定义域中一切 $\\boldsymbol{u},\\boldsymbol{v}$，满足：</p>\n<p>$$<br>T(\\boldsymbol{u}+\\boldsymbol{v})&#x3D;T(\\boldsymbol{u})+T(\\boldsymbol{v})\\<br>T(c\\boldsymbol{u})&#x3D;cT(\\boldsymbol{u})<br>$$</p>\n<p>可以证明，$\\mathbb{R}^n\\to\\mathbb{R}^m$ 的所有线性变换实际上都是矩阵变换。</p>\n<p>线性变换有很多神奇的用途，以后有空再写。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>本文是在阅读了《线性代数及其应用》后，为了巩固与日后复习而写的。</p>\n<p>线性代数这门课我是大一上学期学的，由于教材质量低下，与其说是学线性代数，不如说是学做线性代数习题的方法。课程结束后，那些死记硬背的奇怪概念很快的忘记了，对于线性代数的本质也完全没有理解。现在再看到线性代数的题目时，对于用到的结论更是感觉非常诡异。所以我决定推倒重来，沿着一个自然的学习路线重新学习线性代数，希望可以真正的理解它的内涵。</p>\n<blockquote>\n<p>将所见到的剑招忘得半点不剩，才能得其神髓，临敌时以意驭剑，千变万化，无穷无尽。倘若尚有一两招剑法忘不干净，心有拘囿，剑法便不能纯。——《倚天屠龙记》</p>\n</blockquote>"},{"title":"JSCPC2021","date":"2023-04-28T16:00:00.000Z","math":true,"_content":"\n今天不想干活，就体验了一下 [JSCPC2021](https://codeforces.com/gym/103495/standings)。\n\n最终 6 题 980 罚时，居然还不是同题数罚时最大的，大 胜 利。\n\n下面来记一下流水账。\n\n上来先跟榜过了 A，非常顺利。\n\n然后发现 I 似乎也是签到，再一看确实很简单，然后就连 WA 6 发。后来才发现是输入爆 int 了。。。\n\n然后是 K，感觉很容易猜到一个结论，就是长为 $k$ 的连续段最先出现在 $2^k-1$ 加入序列之后。那么打表就行了。但是数据范围看成 $1\\times 10^8$ 了，又来两发罚时。。。\n\n这个时候感觉状态很不好，看 C 又像是需要分类讨论的贪心，而 J 第一遍没看明白，就有点不想写了。\n\n过了一会又回来看 C，感觉最容易想到的从高到低贪心的想法似乎无懈可击，实现起来也并不复杂，就写了一下，然后过了。\n\n回头再去看 J，又读了一遍题，诶，这不是只要一个 tag 就够了吗，直接二分图染色。写完能过样例，直接一交，然后才发现忘记取少的那部分打标记了。\n\n现在从榜上来看应该尝试 D，但我还是把别的几个题也大致看了一下。\n\nD 是一个看上去很恶心的构造，而 H 是一个字符串题，一眼看上去也没有思路。B 和 L 难度更大，B 是一个数据范围奇怪的图论，或许需要状压之类的；L 在一棵树上不知道搞什么东西，肯定也不会。EFG 似乎更不可做，就不说了。\n\n看来最有希望的还是 D，在几个小的数据上试了一下，发现可以两行一起用掉，那么偶数的情况就可以解决了。都是奇数的时候试着化简到 $3\\times 3$ 的情况，发现 $3\\times 3$ 有很多种画法都是合法的，那么这题好像就做出来了。\n\n但其实还要考虑一下两种画法衔接的时候的角度也必须是锐角，尤其是最后走到 $3\\times 3$ 的时候。这里一开始没考虑周全，所以又多了几发罚时。\n\n这题写完还剩不到一个小时，直接下班了。\n\n先放一些代码。\n","source":"_posts/JSCPC2021.md","raw":"---\ntitle: JSCPC2021\ndate: 2023-04-29\ntag: [XCPC]\ncategory: [Competitive Programming]\nmath: true\n---\n\n今天不想干活，就体验了一下 [JSCPC2021](https://codeforces.com/gym/103495/standings)。\n\n最终 6 题 980 罚时，居然还不是同题数罚时最大的，大 胜 利。\n\n下面来记一下流水账。\n\n上来先跟榜过了 A，非常顺利。\n\n然后发现 I 似乎也是签到，再一看确实很简单，然后就连 WA 6 发。后来才发现是输入爆 int 了。。。\n\n然后是 K，感觉很容易猜到一个结论，就是长为 $k$ 的连续段最先出现在 $2^k-1$ 加入序列之后。那么打表就行了。但是数据范围看成 $1\\times 10^8$ 了，又来两发罚时。。。\n\n这个时候感觉状态很不好，看 C 又像是需要分类讨论的贪心，而 J 第一遍没看明白，就有点不想写了。\n\n过了一会又回来看 C，感觉最容易想到的从高到低贪心的想法似乎无懈可击，实现起来也并不复杂，就写了一下，然后过了。\n\n回头再去看 J，又读了一遍题，诶，这不是只要一个 tag 就够了吗，直接二分图染色。写完能过样例，直接一交，然后才发现忘记取少的那部分打标记了。\n\n现在从榜上来看应该尝试 D，但我还是把别的几个题也大致看了一下。\n\nD 是一个看上去很恶心的构造，而 H 是一个字符串题，一眼看上去也没有思路。B 和 L 难度更大，B 是一个数据范围奇怪的图论，或许需要状压之类的；L 在一棵树上不知道搞什么东西，肯定也不会。EFG 似乎更不可做，就不说了。\n\n看来最有希望的还是 D，在几个小的数据上试了一下，发现可以两行一起用掉，那么偶数的情况就可以解决了。都是奇数的时候试着化简到 $3\\times 3$ 的情况，发现 $3\\times 3$ 有很多种画法都是合法的，那么这题好像就做出来了。\n\n但其实还要考虑一下两种画法衔接的时候的角度也必须是锐角，尤其是最后走到 $3\\times 3$ 的时候。这里一开始没考虑周全，所以又多了几发罚时。\n\n这题写完还剩不到一个小时，直接下班了。\n\n先放一些代码。\n","slug":"JSCPC2021","published":1,"updated":"2023-04-29T12:20:35.149Z","comments":1,"layout":"post","photos":[],"_id":"cmir5cbx8000d2cle1nrd9zzo","content":"<p>今天不想干活，就体验了一下 <a href=\"https://codeforces.com/gym/103495/standings\">JSCPC2021</a>。</p>\n<p>最终 6 题 980 罚时，居然还不是同题数罚时最大的，大 胜 利。</p>\n<p>下面来记一下流水账。</p>\n<p>上来先跟榜过了 A，非常顺利。</p>\n<p>然后发现 I 似乎也是签到，再一看确实很简单，然后就连 WA 6 发。后来才发现是输入爆 int 了。。。</p>\n<p>然后是 K，感觉很容易猜到一个结论，就是长为 $k$ 的连续段最先出现在 $2^k-1$ 加入序列之后。那么打表就行了。但是数据范围看成 $1\\times 10^8$ 了，又来两发罚时。。。</p>\n<p>这个时候感觉状态很不好，看 C 又像是需要分类讨论的贪心，而 J 第一遍没看明白，就有点不想写了。</p>\n<p>过了一会又回来看 C，感觉最容易想到的从高到低贪心的想法似乎无懈可击，实现起来也并不复杂，就写了一下，然后过了。</p>\n<p>回头再去看 J，又读了一遍题，诶，这不是只要一个 tag 就够了吗，直接二分图染色。写完能过样例，直接一交，然后才发现忘记取少的那部分打标记了。</p>\n<p>现在从榜上来看应该尝试 D，但我还是把别的几个题也大致看了一下。</p>\n<p>D 是一个看上去很恶心的构造，而 H 是一个字符串题，一眼看上去也没有思路。B 和 L 难度更大，B 是一个数据范围奇怪的图论，或许需要状压之类的；L 在一棵树上不知道搞什么东西，肯定也不会。EFG 似乎更不可做，就不说了。</p>\n<p>看来最有希望的还是 D，在几个小的数据上试了一下，发现可以两行一起用掉，那么偶数的情况就可以解决了。都是奇数的时候试着化简到 $3\\times 3$ 的情况，发现 $3\\times 3$ 有很多种画法都是合法的，那么这题好像就做出来了。</p>\n<p>但其实还要考虑一下两种画法衔接的时候的角度也必须是锐角，尤其是最后走到 $3\\times 3$ 的时候。这里一开始没考虑周全，所以又多了几发罚时。</p>\n<p>这题写完还剩不到一个小时，直接下班了。</p>\n<p>先放一些代码。</p>\n","excerpt":"","more":"<p>今天不想干活，就体验了一下 <a href=\"https://codeforces.com/gym/103495/standings\">JSCPC2021</a>。</p>\n<p>最终 6 题 980 罚时，居然还不是同题数罚时最大的，大 胜 利。</p>\n<p>下面来记一下流水账。</p>\n<p>上来先跟榜过了 A，非常顺利。</p>\n<p>然后发现 I 似乎也是签到，再一看确实很简单，然后就连 WA 6 发。后来才发现是输入爆 int 了。。。</p>\n<p>然后是 K，感觉很容易猜到一个结论，就是长为 $k$ 的连续段最先出现在 $2^k-1$ 加入序列之后。那么打表就行了。但是数据范围看成 $1\\times 10^8$ 了，又来两发罚时。。。</p>\n<p>这个时候感觉状态很不好，看 C 又像是需要分类讨论的贪心，而 J 第一遍没看明白，就有点不想写了。</p>\n<p>过了一会又回来看 C，感觉最容易想到的从高到低贪心的想法似乎无懈可击，实现起来也并不复杂，就写了一下，然后过了。</p>\n<p>回头再去看 J，又读了一遍题，诶，这不是只要一个 tag 就够了吗，直接二分图染色。写完能过样例，直接一交，然后才发现忘记取少的那部分打标记了。</p>\n<p>现在从榜上来看应该尝试 D，但我还是把别的几个题也大致看了一下。</p>\n<p>D 是一个看上去很恶心的构造，而 H 是一个字符串题，一眼看上去也没有思路。B 和 L 难度更大，B 是一个数据范围奇怪的图论，或许需要状压之类的；L 在一棵树上不知道搞什么东西，肯定也不会。EFG 似乎更不可做，就不说了。</p>\n<p>看来最有希望的还是 D，在几个小的数据上试了一下，发现可以两行一起用掉，那么偶数的情况就可以解决了。都是奇数的时候试着化简到 $3\\times 3$ 的情况，发现 $3\\times 3$ 有很多种画法都是合法的，那么这题好像就做出来了。</p>\n<p>但其实还要考虑一下两种画法衔接的时候的角度也必须是锐角，尤其是最后走到 $3\\times 3$ 的时候。这里一开始没考虑周全，所以又多了几发罚时。</p>\n<p>这题写完还剩不到一个小时，直接下班了。</p>\n<p>先放一些代码。</p>\n"},{"title":"CO1","date":"2023-07-17T16:00:00.000Z","mathjax":true,"_content":"\n# 0 绪论\n\n## 一些定义\n\n### 优化问题\n\n对于数学优化问题：\n$$\n\\begin{array}{lll}\n\\min\\; f_0(x)\\\\\ns.t. \\; f_{i}(x)\\le b_{i}\\; (i = 1,2,\\cdots, m)\n\\end{array}\n$$\n\n其中向量 $x$ 称为**优化变量**；\n函数 $f_0:\\mathbf{R^n}\\to \\mathbf{R}$ 称为**目标函数**；\n函数 $f_i:\\mathbf{R^n}\\to \\mathbf{R}\\;(i = 1,2,\\cdots, m)$ 称为**约束函数**；\n常数 $b_i$ 称为**约束边界**。\n\n如果在所有满足约束的向量中向量 $x^*$ 对应的目标函数值最小，那么称 $x^*$ 为该问题的**最优解**。\n\n### 线性规划\n\n如果上面的问题中 $f_i$ 是线性函数，即：\n\n$$\n\\forall x,y\\in \\mathbf{R^n} \\\\\n\\forall \\alpha,\\beta \\in \\mathbf{R}\\\\\ns.t.\\; f_{i}(\\alpha x+\\beta y)=\\alpha f_i(x)+\\beta f_i(y)\n$$\n\n则此优化问题称为**线性规划**。\n\n### 凸优化\n\n凸优化问题中的目标函数和约束函数都是凸函数。如果函数 $f_i$ 是凸函数，则需要满足以下条件：\n\n$$\n\\forall x,y\\in \\mathbf{R^n} \\\\\n\\forall \\alpha,\\beta \\in \\mathbf{R}\\\\\n\\alpha + \\beta = 1,\\; \\alpha \\ge 0,\\; \\beta \\ge 0\\\\\ns.t.\\; f_{i}(\\alpha x+\\beta y)\\le\\alpha f_i(x)+\\beta f_i(y)\n$$\n\n直观感受一下可以发现，凸函数的图像是从中间凹陷下去的，即函数图像上取两个点连一条线段，线段中的点都位于函数图像的上方。\n\n显然，线性规划问题是一种凸优化问题。\n\n## 最小二乘问题\n\n最小二乘问题是一种常见的凸优化问题，具体形式如下：\n\n$$\n\\min\\; f_0(x)=\\|Ax-b\\|_{2}^{2}\n=\\sum_{i=1}^{k}(a_{i}^{T}x-b)^2\n$$\n\n该问题没有约束条件，约束目标是若干项的平方和。\n\n","source":"_posts/CO1.md","raw":"---\ntitle: CO1\ndate: 2023-07-18\ntag: [Convex Optimization]\ncategory: [Convex Optimization]\nmathjax: true\n---\n\n# 0 绪论\n\n## 一些定义\n\n### 优化问题\n\n对于数学优化问题：\n$$\n\\begin{array}{lll}\n\\min\\; f_0(x)\\\\\ns.t. \\; f_{i}(x)\\le b_{i}\\; (i = 1,2,\\cdots, m)\n\\end{array}\n$$\n\n其中向量 $x$ 称为**优化变量**；\n函数 $f_0:\\mathbf{R^n}\\to \\mathbf{R}$ 称为**目标函数**；\n函数 $f_i:\\mathbf{R^n}\\to \\mathbf{R}\\;(i = 1,2,\\cdots, m)$ 称为**约束函数**；\n常数 $b_i$ 称为**约束边界**。\n\n如果在所有满足约束的向量中向量 $x^*$ 对应的目标函数值最小，那么称 $x^*$ 为该问题的**最优解**。\n\n### 线性规划\n\n如果上面的问题中 $f_i$ 是线性函数，即：\n\n$$\n\\forall x,y\\in \\mathbf{R^n} \\\\\n\\forall \\alpha,\\beta \\in \\mathbf{R}\\\\\ns.t.\\; f_{i}(\\alpha x+\\beta y)=\\alpha f_i(x)+\\beta f_i(y)\n$$\n\n则此优化问题称为**线性规划**。\n\n### 凸优化\n\n凸优化问题中的目标函数和约束函数都是凸函数。如果函数 $f_i$ 是凸函数，则需要满足以下条件：\n\n$$\n\\forall x,y\\in \\mathbf{R^n} \\\\\n\\forall \\alpha,\\beta \\in \\mathbf{R}\\\\\n\\alpha + \\beta = 1,\\; \\alpha \\ge 0,\\; \\beta \\ge 0\\\\\ns.t.\\; f_{i}(\\alpha x+\\beta y)\\le\\alpha f_i(x)+\\beta f_i(y)\n$$\n\n直观感受一下可以发现，凸函数的图像是从中间凹陷下去的，即函数图像上取两个点连一条线段，线段中的点都位于函数图像的上方。\n\n显然，线性规划问题是一种凸优化问题。\n\n## 最小二乘问题\n\n最小二乘问题是一种常见的凸优化问题，具体形式如下：\n\n$$\n\\min\\; f_0(x)=\\|Ax-b\\|_{2}^{2}\n=\\sum_{i=1}^{k}(a_{i}^{T}x-b)^2\n$$\n\n该问题没有约束条件，约束目标是若干项的平方和。\n\n","slug":"CO1","published":1,"updated":"2025-12-04T07:53:44.953Z","comments":1,"layout":"post","photos":[],"_id":"cmir5cbx9000h2cleepyz3gik","content":"<h1 id=\"0-绪论\"><a href=\"#0-绪论\" class=\"headerlink\" title=\"0 绪论\"></a>0 绪论</h1><h2 id=\"一些定义\"><a href=\"#一些定义\" class=\"headerlink\" title=\"一些定义\"></a>一些定义</h2><h3 id=\"优化问题\"><a href=\"#优化问题\" class=\"headerlink\" title=\"优化问题\"></a>优化问题</h3><p>对于数学优化问题：<br>$$<br>\\begin{array}{lll}<br>\\min; f_0(x)\\<br>s.t. ; f_{i}(x)\\le b_{i}; (i &#x3D; 1,2,\\cdots, m)<br>\\end{array}<br>$$</p>\n<p>其中向量 $x$ 称为<strong>优化变量</strong>；<br>函数 $f_0:\\mathbf{R^n}\\to \\mathbf{R}$ 称为<strong>目标函数</strong>；<br>函数 $f_i:\\mathbf{R^n}\\to \\mathbf{R};(i &#x3D; 1,2,\\cdots, m)$ 称为<strong>约束函数</strong>；<br>常数 $b_i$ 称为<strong>约束边界</strong>。</p>\n<p>如果在所有满足约束的向量中向量 $x^*$ 对应的目标函数值最小，那么称 $x^*$ 为该问题的<strong>最优解</strong>。</p>\n<h3 id=\"线性规划\"><a href=\"#线性规划\" class=\"headerlink\" title=\"线性规划\"></a>线性规划</h3><p>如果上面的问题中 $f_i$ 是线性函数，即：</p>\n<p>$$<br>\\forall x,y\\in \\mathbf{R^n} \\<br>\\forall \\alpha,\\beta \\in \\mathbf{R}\\<br>s.t.; f_{i}(\\alpha x+\\beta y)&#x3D;\\alpha f_i(x)+\\beta f_i(y)<br>$$</p>\n<p>则此优化问题称为<strong>线性规划</strong>。</p>\n<h3 id=\"凸优化\"><a href=\"#凸优化\" class=\"headerlink\" title=\"凸优化\"></a>凸优化</h3><p>凸优化问题中的目标函数和约束函数都是凸函数。如果函数 $f_i$ 是凸函数，则需要满足以下条件：</p>\n<p>$$<br>\\forall x,y\\in \\mathbf{R^n} \\<br>\\forall \\alpha,\\beta \\in \\mathbf{R}\\<br>\\alpha + \\beta &#x3D; 1,; \\alpha \\ge 0,; \\beta \\ge 0\\<br>s.t.; f_{i}(\\alpha x+\\beta y)\\le\\alpha f_i(x)+\\beta f_i(y)<br>$$</p>\n<p>直观感受一下可以发现，凸函数的图像是从中间凹陷下去的，即函数图像上取两个点连一条线段，线段中的点都位于函数图像的上方。</p>\n<p>显然，线性规划问题是一种凸优化问题。</p>\n<h2 id=\"最小二乘问题\"><a href=\"#最小二乘问题\" class=\"headerlink\" title=\"最小二乘问题\"></a>最小二乘问题</h2><p>最小二乘问题是一种常见的凸优化问题，具体形式如下：</p>\n<p>$$<br>\\min; f_0(x)&#x3D;|Ax-b|<em>{2}^{2}<br>&#x3D;\\sum</em>{i&#x3D;1}^{k}(a_{i}^{T}x-b)^2<br>$$</p>\n<p>该问题没有约束条件，约束目标是若干项的平方和。</p>\n","excerpt":"","more":"<h1 id=\"0-绪论\"><a href=\"#0-绪论\" class=\"headerlink\" title=\"0 绪论\"></a>0 绪论</h1><h2 id=\"一些定义\"><a href=\"#一些定义\" class=\"headerlink\" title=\"一些定义\"></a>一些定义</h2><h3 id=\"优化问题\"><a href=\"#优化问题\" class=\"headerlink\" title=\"优化问题\"></a>优化问题</h3><p>对于数学优化问题：<br>$$<br>\\begin{array}{lll}<br>\\min; f_0(x)\\<br>s.t. ; f_{i}(x)\\le b_{i}; (i &#x3D; 1,2,\\cdots, m)<br>\\end{array}<br>$$</p>\n<p>其中向量 $x$ 称为<strong>优化变量</strong>；<br>函数 $f_0:\\mathbf{R^n}\\to \\mathbf{R}$ 称为<strong>目标函数</strong>；<br>函数 $f_i:\\mathbf{R^n}\\to \\mathbf{R};(i &#x3D; 1,2,\\cdots, m)$ 称为<strong>约束函数</strong>；<br>常数 $b_i$ 称为<strong>约束边界</strong>。</p>\n<p>如果在所有满足约束的向量中向量 $x^*$ 对应的目标函数值最小，那么称 $x^*$ 为该问题的<strong>最优解</strong>。</p>\n<h3 id=\"线性规划\"><a href=\"#线性规划\" class=\"headerlink\" title=\"线性规划\"></a>线性规划</h3><p>如果上面的问题中 $f_i$ 是线性函数，即：</p>\n<p>$$<br>\\forall x,y\\in \\mathbf{R^n} \\<br>\\forall \\alpha,\\beta \\in \\mathbf{R}\\<br>s.t.; f_{i}(\\alpha x+\\beta y)&#x3D;\\alpha f_i(x)+\\beta f_i(y)<br>$$</p>\n<p>则此优化问题称为<strong>线性规划</strong>。</p>\n<h3 id=\"凸优化\"><a href=\"#凸优化\" class=\"headerlink\" title=\"凸优化\"></a>凸优化</h3><p>凸优化问题中的目标函数和约束函数都是凸函数。如果函数 $f_i$ 是凸函数，则需要满足以下条件：</p>\n<p>$$<br>\\forall x,y\\in \\mathbf{R^n} \\<br>\\forall \\alpha,\\beta \\in \\mathbf{R}\\<br>\\alpha + \\beta &#x3D; 1,; \\alpha \\ge 0,; \\beta \\ge 0\\<br>s.t.; f_{i}(\\alpha x+\\beta y)\\le\\alpha f_i(x)+\\beta f_i(y)<br>$$</p>\n<p>直观感受一下可以发现，凸函数的图像是从中间凹陷下去的，即函数图像上取两个点连一条线段，线段中的点都位于函数图像的上方。</p>\n<p>显然，线性规划问题是一种凸优化问题。</p>\n<h2 id=\"最小二乘问题\"><a href=\"#最小二乘问题\" class=\"headerlink\" title=\"最小二乘问题\"></a>最小二乘问题</h2><p>最小二乘问题是一种常见的凸优化问题，具体形式如下：</p>\n<p>$$<br>\\min; f_0(x)&#x3D;|Ax-b|<em>{2}^{2}<br>&#x3D;\\sum</em>{i&#x3D;1}^{k}(a_{i}^{T}x-b)^2<br>$$</p>\n<p>该问题没有约束条件，约束目标是若干项的平方和。</p>\n"},{"title":"Matrix Operation","date":"2022-07-26T16:00:00.000Z","math":true,"_content":"\n矩阵的基本运算\n\n<!--more-->\n\n矩阵的加法和标量乘法很简单，就不多说了。\n\n## 矩阵乘法\n\n来看一个线性变换：对于 $\\mathbb{R}^k$ 中的一个向量 $\\boldsymbol{v}$，用一个 $n\\times k$ 的矩阵 $B$ 乘上这个 $\\boldsymbol{v}$，就会得到一个 $\\mathbb{R}^n$ 中的向量 $B\\boldsymbol{v}$。容易发现，向量的维度发生了改变。所以如果此时我们再需要对其进行一次变换，必须用一个 $n$ 列的矩阵。假设用一个 $m\\times n$ 矩阵 $A$ 乘上新向量 $B\\boldsymbol{v}$，就得到了向量 $A(B\\boldsymbol{v})$。\n\n由于线性变换的标准矩阵是唯一的，所以存在一个矩阵 $AB$ 满足 $(AB)\\boldsymbol{v}=A(B\\boldsymbol{v})$。矩阵乘法的概念就是这么来的。\n\n对于一个 $n\\times k$ 的矩阵 $B$，可以将其每一列看作一个 $n$ 维向量，即 $B=[\\boldsymbol{b_1},\\boldsymbol{b_2},\\cdots ,\\boldsymbol{b_k}]$。那么矩阵 $AB$ 就应该是 $[A\\boldsymbol{b_1},A\\boldsymbol{b_2},\\cdots ,A\\boldsymbol{b_k}]$，其实就相当于拆成矩阵和向量的乘积以后再拼回去。显然，$A$ 的列数必须等于 $B$ 的行数。\n\n这也就很好理解为什么两个矩阵相乘必须是前者的每一行乘上后者的每一列。\n\n结合矩阵加法和标量乘法的性质，容易发现矩阵的乘法满足结合律和分配律，但是不满足交换律。\n\n定义矩阵的主对角线为所有行列下标相等的元素，单位矩阵 $I_n$ 为主对角线元素均为 $1$、其余元素均为 $0$ 的 $n\\times n$ 矩阵。容易证明，$I_mA=A=AI_n$。\n\n值得注意的是，即便 $AB=AC$ 且 $A$ 不为零矩阵，也不能推出 $B=C$。\n\n## 转置\n\n对于 $m\\times n$ 矩阵 $A$，它的转置 $A^T$ 是一个 $n\\times m$ 矩阵，它的列由 $A$ 的对应行构成。\n\n显然，矩阵的转置有以下的性质：\n\n- $(A^T)^T=A$\n- $(A+B)^T=A^T+B^T$\n- $(rA)^T=rA^T$（$r$ 为常数）\n- $(AB)^T=B^TA^T$\n\n前三个很显然。下面证明第四个性质：对于 $(AB)^T$ 中位于 $(i,j)$ 的元素，在 $AB$ 中位于 $(j,i)$，等于 $\\sum_{t=1}^n a_{jt}b_{ti}$。而 $B^T$ 的第 $i$ 行，就是 $B$ 的第 $i$ 列，即 $b_{1i},b_{2i},\\cdots,b_{ni}$；$A^T$ 的第 $j$ 列，就是 $A$ 的第 $j$ 行，即 $a_{j1},a_{j2},\\cdots,a_{jn}$，对应位置相乘后求和就是 $\\sum_{t=1}^n a_{jt}b_{ti}$。\n\n事实上，有\n\n$$\n(\\prod_{i=1}^n A_i)^T=\\prod_{i=n}^1 A_i^T\n$$\n\n这可以通过数学归纳法来证明。\n\n## 矩阵的逆\n\n定义了加减乘三种运算后，我们不禁会想，能不能给矩阵也定义一个除法？\n\n参考离散数学里逆元的概念，所谓除法，就相当于对于一个给定的元素 $A$，求 $A$ 的逆元 $A^{-1}$，满足 $A^{-1}\\times A=A\\times A^{-1}=\\epsilon$。对于矩阵而言，幺元 $\\epsilon$ 就是单位矩阵。由于 $A^{-1}\\times A$ 和 $A\\times A^{-1}$ 都必须有意义，$A$ 必须是一个方阵。我们称 $A^{-1}$ 为 $A$ 的逆矩阵。\n\n由此可见，并非所有的矩阵都有逆矩阵。如果一个矩阵有逆矩阵，就称其为可逆矩阵，或者**非奇异矩阵**；否则称其为不可逆矩阵，或**奇异矩阵**。\n\n可逆矩阵也具有几个基本性质：\n\n- 可逆矩阵的逆矩阵是唯一的\n- 若 $A$ 可逆，则 $A^{-1}$ 也可逆，且 $(A^{-1})^{-1}=A$\n- $(AB)^{-1}=B^{-1}A^{-1}$\n- 若 $A$ 可逆，则 $A^T$ 也可逆，且 $(A^{T})^{-1}=(A^{-1})^T$\n\n利用定义，很容易证明前三个性质。第四个需要结合转置的性质来证明：\n\n$$\n(A^{-1})^TA^T=(AA^{-1})^T=I^T=I\n$$\n\n类似于转置的性质，$(AB)^{-1}=B^{-1}A^{-1}$ 也可以进行推广（其中 $A_i$ 都是维度相同的可逆矩阵）：\n\n$$\n(\\prod_{i=1}^n A_i)^{-1}=\\prod_{i=n}^1 A_i^{-1}\n$$\n\n逆矩阵的求法较为复杂，需要先做一些准备。\n\n### 初等矩阵\n\n把单位矩阵做一次初等行变换，就得到**初等矩阵**。\n\n如果对矩阵乘法的流程比较熟悉，就可以发现，如果对一个矩阵 $A$ 进行一次初等行变换，就相当于对 $A$ 左乘一个初等矩阵 $E$，其中 $E$ 是对单位矩阵进行同样的初等行变换得到的。\n\n由于初等行变换是可逆的，所以初等矩阵也是可逆的。这就产生了一种求逆矩阵的思路：\n\n若 $n$ 阶方阵 $A$ 是可逆的，那么 $A$ 必须行等价于 $I_n$，把 $A$ 化简为 $I_n$ 的一系列初等行变换作用于 $I_n$ 就得到了 $A^{-1}$。\n\n这就是把 $A$ 和 $I$ 排在一起构成增广矩阵 $[A\\quad I]$，然后把 $A$ 变成 $I$ 来求逆矩阵的原理。\n\n也可以换一个角度看待这种方法，对于 $A^{-1}$ 中的第 $i$ 列，将其取出命名为向量 $\\boldsymbol{x_i}$，那么相当于有向量方程组\n\n$$\nA\\boldsymbol{x_i}=\\boldsymbol{e_i}\n$$\n\n其中 $\\boldsymbol{e_i}$ 是单位矩阵的第 $i$ 列形成的向量。\n\n## 分块矩阵\n\n分块的思想十分简单，在我们将一个矩阵看作若干向量的组合时，就已经是一种对矩阵的分块了。\n\n分块矩阵的乘法和普通的矩阵乘法差不多，注意不要写错顺序就行了。\n\n例如：\n\n$$\n\\left[ \\begin{array}{ccc}\nA_{11} & A_{12}\\\\\nA_{21} & A_{22} \n\\end{array} \\right]\\times \n\\left[ \\begin{array}{ccc}\nB_{11} & B_{12}\\\\\nB_{21} & B_{22} \n\\end{array} \\right]\n\\\\ \\quad\n\\\\\n=\n\n\\left[ \\begin{array}{ccc}\nA_{11}B_{11}+A_{12}B_{21} & A_{11}B_{12}+A_{12}B_{22}\\\\\nA_{21}B_{11}+A_{22}B_{21} & A_{21}B_{12}+A_{22}B_{22}\n\\end{array} \\right]\n\n$$\n\n而分块矩阵求逆就很复杂。具体这里就不写了，只提一个小结论：分块对角矩阵是一个分块矩阵，除了主对角线上的分块外，其余全是零分块。这样的矩阵可逆当且仅当对角线上所有矩阵均可逆。\n\n分块矩阵和矩阵的因式分解在数值计算中都十分重要，以后有空写一下。\n\n## 秩\n\n### 子空间\n\n我们已经知道，一个 $m\\times n$ 矩阵 $A$ 可以看作 $n$ 个 $\\mathbb{R}^m$ 空间内的向量的集合。当 $A$ 乘上一个向量 $\\boldsymbol{x}$ 的时候，就相当于是将这 $n$ 个向量进行了一定长度的伸缩变换后重新加到了一起。那么对于 $\\boldsymbol{x}$ 的所有取值，产生的所有新向量 $A\\boldsymbol{x}$ 就形成了一个 $\\mathbb{R}^m$ 的子空间 $H$。\n\n显然，$H$ 具有以下性质：\n\n- $\\boldsymbol{0}\\in H$\n- $\\forall \\boldsymbol{u},\\boldsymbol{v}\\in H,\\boldsymbol{u}+\\boldsymbol{v}\\in H$\n- $\\forall \\boldsymbol{u}\\in H, c\\boldsymbol{u}\\in H$（$c$ 为常数）\n\n所以说，子空间对于加法和标量乘法运算是封闭的。\n\n定义矩阵 $A$ 的**列空间**为 $A$ 的各列的线性组合的集合，记作 $\\text{Col }A$。\n\n不难发现，$\\text{Col }A$ 就是 $\\text{Span}\\lbrace \\boldsymbol{a_1}\\cdots\\boldsymbol{a_n} \\rbrace$ 的另一种表示。显然，$\\text{Col }A\\subseteq \\mathbb{R}^m$，并且只有在 $A$ 的列生成 $\\mathbb{R}^m$ 时取到等号。\n\n定义矩阵 $A$ 的**零空间**为齐次方程 $A\\boldsymbol{x}=\\boldsymbol{b}$ 的所有解的集合，记作 $\\text{Nul }A$。\n\n不难发现，$\\text{Nul }A$ 一定是 $\\mathbb{R}^n$ 的一个子空间。\n\n子空间一般含有无穷个向量，所以最好能通过一个有限的向量集合来表示一个子空间。定义 $\\mathbb{R}^n$ 的子空间 $H$ 的一组**基**是 $H$ 中的一个线性无关集，它生成 $H$。\n\n显然，$n$ 阶单位矩阵中的 $n$ 个列向量 $\\boldsymbol{e_1}\\cdots\\boldsymbol{e_n}$ 就构成了 $\\mathbb{R}^n$ 的一组基。$\\lbrace\\boldsymbol{e_1}\\cdots\\boldsymbol{e_n}\\rbrace$ 称为 $\\mathbb{R}^n$ 的**标准基**。\n\n矩阵 $A$ 的主元列构成 $A$ 的列空间的基。\n\n有一点需要特殊说明，零子空间没有基。\n\n### 秩\n\n假设 $\\mathcal{B}=\\lbrace \\boldsymbol{b_1}\\cdots\\boldsymbol{b_p}  \\rbrace$ 是子空间 $H$ 的一组基，对 $H$ 中的每一个向量 $\\boldsymbol{x}$，其相对于 $H$ 的坐标是使 $\\boldsymbol{x}=c_1\\boldsymbol{b_1}+\\cdots+c_p\\boldsymbol{b_p}$ 成立的一组权值 $c_i$，且 $\\mathbb{R}^p$ 中的向量\n\n$$\n[\\boldsymbol{x}]_{\\mathcal{B}}=\\left[ \n\\begin{array}{ccc}\nc_1\\\\\n\\vdots\\\\\nc_p\n\\end{array}\n\\right]\n$$\n\n称为 $\\boldsymbol{x}$ 相对于 $\\mathcal{B}$ 的坐标向量，或 $\\boldsymbol{x}$ 的 $\\mathcal{B}$-坐标向量。\n\n#### 同构\n\n如果映射 $\\boldsymbol{x}\\to [\\boldsymbol{x}]_{\\mathcal{B}}$ 是 $H$ 和 $\\mathbb{R}^p$ 之间保持线性关系的一一映射，则称这种映射是**同构**的，且 $H$ 与 $\\mathbb{R}^p$ 同构。\n\n如果 $\\mathcal{B}=\\lbrace \\boldsymbol{b_1}\\cdots\\boldsymbol{b_p}  \\rbrace$ 是 $H$ 的基，则映射 $\\boldsymbol{x}\\to [\\boldsymbol{x}]_{\\mathcal{B}}$ 是使 $H$ 和 $\\mathbb{R}^p$ 之间保持线性关系的一一映射。\n\n#### 维数\n\n可以证明，一个子空间的所有基都拥有相同数量的向量。\n\n定义子空间 $H$ 的维数 $\\dim H$ 为 $H$ 的任意一个基的向量个数。$\\lbrace \\boldsymbol{0}\\rbrace$ 的维数为零。\n\n定义矩阵 $A$ 的**秩**为 $A$ 的列空间的维数，记为 $\\text{rank }A$。\n\n如果一个矩阵 $A$ 有 $n$ 列，那么 $\\text{rank }A+\\dim \\text{Nul } A=n$。（秩定理）\n\n虽然这里产生了很多新的概念，但它们都是围绕着列向量的线性相关性展开的。如果 $A$ 是一个 $n$ 阶可逆矩阵，那么必然有：\n\n- $A$ 的列向量是 $\\mathbb{R}^n$ 的基\n- $\\text{rank }A=n$\n- $\\dim \\text{Col }A=n$\n\n\n","source":"_posts/LA1.md","raw":"---\ntitle: Matrix Operation\ndate: 2022-07-27\ntag: [linear algebra]\ncategory: [Linear Algebra]\nmath: true\n---\n\n矩阵的基本运算\n\n<!--more-->\n\n矩阵的加法和标量乘法很简单，就不多说了。\n\n## 矩阵乘法\n\n来看一个线性变换：对于 $\\mathbb{R}^k$ 中的一个向量 $\\boldsymbol{v}$，用一个 $n\\times k$ 的矩阵 $B$ 乘上这个 $\\boldsymbol{v}$，就会得到一个 $\\mathbb{R}^n$ 中的向量 $B\\boldsymbol{v}$。容易发现，向量的维度发生了改变。所以如果此时我们再需要对其进行一次变换，必须用一个 $n$ 列的矩阵。假设用一个 $m\\times n$ 矩阵 $A$ 乘上新向量 $B\\boldsymbol{v}$，就得到了向量 $A(B\\boldsymbol{v})$。\n\n由于线性变换的标准矩阵是唯一的，所以存在一个矩阵 $AB$ 满足 $(AB)\\boldsymbol{v}=A(B\\boldsymbol{v})$。矩阵乘法的概念就是这么来的。\n\n对于一个 $n\\times k$ 的矩阵 $B$，可以将其每一列看作一个 $n$ 维向量，即 $B=[\\boldsymbol{b_1},\\boldsymbol{b_2},\\cdots ,\\boldsymbol{b_k}]$。那么矩阵 $AB$ 就应该是 $[A\\boldsymbol{b_1},A\\boldsymbol{b_2},\\cdots ,A\\boldsymbol{b_k}]$，其实就相当于拆成矩阵和向量的乘积以后再拼回去。显然，$A$ 的列数必须等于 $B$ 的行数。\n\n这也就很好理解为什么两个矩阵相乘必须是前者的每一行乘上后者的每一列。\n\n结合矩阵加法和标量乘法的性质，容易发现矩阵的乘法满足结合律和分配律，但是不满足交换律。\n\n定义矩阵的主对角线为所有行列下标相等的元素，单位矩阵 $I_n$ 为主对角线元素均为 $1$、其余元素均为 $0$ 的 $n\\times n$ 矩阵。容易证明，$I_mA=A=AI_n$。\n\n值得注意的是，即便 $AB=AC$ 且 $A$ 不为零矩阵，也不能推出 $B=C$。\n\n## 转置\n\n对于 $m\\times n$ 矩阵 $A$，它的转置 $A^T$ 是一个 $n\\times m$ 矩阵，它的列由 $A$ 的对应行构成。\n\n显然，矩阵的转置有以下的性质：\n\n- $(A^T)^T=A$\n- $(A+B)^T=A^T+B^T$\n- $(rA)^T=rA^T$（$r$ 为常数）\n- $(AB)^T=B^TA^T$\n\n前三个很显然。下面证明第四个性质：对于 $(AB)^T$ 中位于 $(i,j)$ 的元素，在 $AB$ 中位于 $(j,i)$，等于 $\\sum_{t=1}^n a_{jt}b_{ti}$。而 $B^T$ 的第 $i$ 行，就是 $B$ 的第 $i$ 列，即 $b_{1i},b_{2i},\\cdots,b_{ni}$；$A^T$ 的第 $j$ 列，就是 $A$ 的第 $j$ 行，即 $a_{j1},a_{j2},\\cdots,a_{jn}$，对应位置相乘后求和就是 $\\sum_{t=1}^n a_{jt}b_{ti}$。\n\n事实上，有\n\n$$\n(\\prod_{i=1}^n A_i)^T=\\prod_{i=n}^1 A_i^T\n$$\n\n这可以通过数学归纳法来证明。\n\n## 矩阵的逆\n\n定义了加减乘三种运算后，我们不禁会想，能不能给矩阵也定义一个除法？\n\n参考离散数学里逆元的概念，所谓除法，就相当于对于一个给定的元素 $A$，求 $A$ 的逆元 $A^{-1}$，满足 $A^{-1}\\times A=A\\times A^{-1}=\\epsilon$。对于矩阵而言，幺元 $\\epsilon$ 就是单位矩阵。由于 $A^{-1}\\times A$ 和 $A\\times A^{-1}$ 都必须有意义，$A$ 必须是一个方阵。我们称 $A^{-1}$ 为 $A$ 的逆矩阵。\n\n由此可见，并非所有的矩阵都有逆矩阵。如果一个矩阵有逆矩阵，就称其为可逆矩阵，或者**非奇异矩阵**；否则称其为不可逆矩阵，或**奇异矩阵**。\n\n可逆矩阵也具有几个基本性质：\n\n- 可逆矩阵的逆矩阵是唯一的\n- 若 $A$ 可逆，则 $A^{-1}$ 也可逆，且 $(A^{-1})^{-1}=A$\n- $(AB)^{-1}=B^{-1}A^{-1}$\n- 若 $A$ 可逆，则 $A^T$ 也可逆，且 $(A^{T})^{-1}=(A^{-1})^T$\n\n利用定义，很容易证明前三个性质。第四个需要结合转置的性质来证明：\n\n$$\n(A^{-1})^TA^T=(AA^{-1})^T=I^T=I\n$$\n\n类似于转置的性质，$(AB)^{-1}=B^{-1}A^{-1}$ 也可以进行推广（其中 $A_i$ 都是维度相同的可逆矩阵）：\n\n$$\n(\\prod_{i=1}^n A_i)^{-1}=\\prod_{i=n}^1 A_i^{-1}\n$$\n\n逆矩阵的求法较为复杂，需要先做一些准备。\n\n### 初等矩阵\n\n把单位矩阵做一次初等行变换，就得到**初等矩阵**。\n\n如果对矩阵乘法的流程比较熟悉，就可以发现，如果对一个矩阵 $A$ 进行一次初等行变换，就相当于对 $A$ 左乘一个初等矩阵 $E$，其中 $E$ 是对单位矩阵进行同样的初等行变换得到的。\n\n由于初等行变换是可逆的，所以初等矩阵也是可逆的。这就产生了一种求逆矩阵的思路：\n\n若 $n$ 阶方阵 $A$ 是可逆的，那么 $A$ 必须行等价于 $I_n$，把 $A$ 化简为 $I_n$ 的一系列初等行变换作用于 $I_n$ 就得到了 $A^{-1}$。\n\n这就是把 $A$ 和 $I$ 排在一起构成增广矩阵 $[A\\quad I]$，然后把 $A$ 变成 $I$ 来求逆矩阵的原理。\n\n也可以换一个角度看待这种方法，对于 $A^{-1}$ 中的第 $i$ 列，将其取出命名为向量 $\\boldsymbol{x_i}$，那么相当于有向量方程组\n\n$$\nA\\boldsymbol{x_i}=\\boldsymbol{e_i}\n$$\n\n其中 $\\boldsymbol{e_i}$ 是单位矩阵的第 $i$ 列形成的向量。\n\n## 分块矩阵\n\n分块的思想十分简单，在我们将一个矩阵看作若干向量的组合时，就已经是一种对矩阵的分块了。\n\n分块矩阵的乘法和普通的矩阵乘法差不多，注意不要写错顺序就行了。\n\n例如：\n\n$$\n\\left[ \\begin{array}{ccc}\nA_{11} & A_{12}\\\\\nA_{21} & A_{22} \n\\end{array} \\right]\\times \n\\left[ \\begin{array}{ccc}\nB_{11} & B_{12}\\\\\nB_{21} & B_{22} \n\\end{array} \\right]\n\\\\ \\quad\n\\\\\n=\n\n\\left[ \\begin{array}{ccc}\nA_{11}B_{11}+A_{12}B_{21} & A_{11}B_{12}+A_{12}B_{22}\\\\\nA_{21}B_{11}+A_{22}B_{21} & A_{21}B_{12}+A_{22}B_{22}\n\\end{array} \\right]\n\n$$\n\n而分块矩阵求逆就很复杂。具体这里就不写了，只提一个小结论：分块对角矩阵是一个分块矩阵，除了主对角线上的分块外，其余全是零分块。这样的矩阵可逆当且仅当对角线上所有矩阵均可逆。\n\n分块矩阵和矩阵的因式分解在数值计算中都十分重要，以后有空写一下。\n\n## 秩\n\n### 子空间\n\n我们已经知道，一个 $m\\times n$ 矩阵 $A$ 可以看作 $n$ 个 $\\mathbb{R}^m$ 空间内的向量的集合。当 $A$ 乘上一个向量 $\\boldsymbol{x}$ 的时候，就相当于是将这 $n$ 个向量进行了一定长度的伸缩变换后重新加到了一起。那么对于 $\\boldsymbol{x}$ 的所有取值，产生的所有新向量 $A\\boldsymbol{x}$ 就形成了一个 $\\mathbb{R}^m$ 的子空间 $H$。\n\n显然，$H$ 具有以下性质：\n\n- $\\boldsymbol{0}\\in H$\n- $\\forall \\boldsymbol{u},\\boldsymbol{v}\\in H,\\boldsymbol{u}+\\boldsymbol{v}\\in H$\n- $\\forall \\boldsymbol{u}\\in H, c\\boldsymbol{u}\\in H$（$c$ 为常数）\n\n所以说，子空间对于加法和标量乘法运算是封闭的。\n\n定义矩阵 $A$ 的**列空间**为 $A$ 的各列的线性组合的集合，记作 $\\text{Col }A$。\n\n不难发现，$\\text{Col }A$ 就是 $\\text{Span}\\lbrace \\boldsymbol{a_1}\\cdots\\boldsymbol{a_n} \\rbrace$ 的另一种表示。显然，$\\text{Col }A\\subseteq \\mathbb{R}^m$，并且只有在 $A$ 的列生成 $\\mathbb{R}^m$ 时取到等号。\n\n定义矩阵 $A$ 的**零空间**为齐次方程 $A\\boldsymbol{x}=\\boldsymbol{b}$ 的所有解的集合，记作 $\\text{Nul }A$。\n\n不难发现，$\\text{Nul }A$ 一定是 $\\mathbb{R}^n$ 的一个子空间。\n\n子空间一般含有无穷个向量，所以最好能通过一个有限的向量集合来表示一个子空间。定义 $\\mathbb{R}^n$ 的子空间 $H$ 的一组**基**是 $H$ 中的一个线性无关集，它生成 $H$。\n\n显然，$n$ 阶单位矩阵中的 $n$ 个列向量 $\\boldsymbol{e_1}\\cdots\\boldsymbol{e_n}$ 就构成了 $\\mathbb{R}^n$ 的一组基。$\\lbrace\\boldsymbol{e_1}\\cdots\\boldsymbol{e_n}\\rbrace$ 称为 $\\mathbb{R}^n$ 的**标准基**。\n\n矩阵 $A$ 的主元列构成 $A$ 的列空间的基。\n\n有一点需要特殊说明，零子空间没有基。\n\n### 秩\n\n假设 $\\mathcal{B}=\\lbrace \\boldsymbol{b_1}\\cdots\\boldsymbol{b_p}  \\rbrace$ 是子空间 $H$ 的一组基，对 $H$ 中的每一个向量 $\\boldsymbol{x}$，其相对于 $H$ 的坐标是使 $\\boldsymbol{x}=c_1\\boldsymbol{b_1}+\\cdots+c_p\\boldsymbol{b_p}$ 成立的一组权值 $c_i$，且 $\\mathbb{R}^p$ 中的向量\n\n$$\n[\\boldsymbol{x}]_{\\mathcal{B}}=\\left[ \n\\begin{array}{ccc}\nc_1\\\\\n\\vdots\\\\\nc_p\n\\end{array}\n\\right]\n$$\n\n称为 $\\boldsymbol{x}$ 相对于 $\\mathcal{B}$ 的坐标向量，或 $\\boldsymbol{x}$ 的 $\\mathcal{B}$-坐标向量。\n\n#### 同构\n\n如果映射 $\\boldsymbol{x}\\to [\\boldsymbol{x}]_{\\mathcal{B}}$ 是 $H$ 和 $\\mathbb{R}^p$ 之间保持线性关系的一一映射，则称这种映射是**同构**的，且 $H$ 与 $\\mathbb{R}^p$ 同构。\n\n如果 $\\mathcal{B}=\\lbrace \\boldsymbol{b_1}\\cdots\\boldsymbol{b_p}  \\rbrace$ 是 $H$ 的基，则映射 $\\boldsymbol{x}\\to [\\boldsymbol{x}]_{\\mathcal{B}}$ 是使 $H$ 和 $\\mathbb{R}^p$ 之间保持线性关系的一一映射。\n\n#### 维数\n\n可以证明，一个子空间的所有基都拥有相同数量的向量。\n\n定义子空间 $H$ 的维数 $\\dim H$ 为 $H$ 的任意一个基的向量个数。$\\lbrace \\boldsymbol{0}\\rbrace$ 的维数为零。\n\n定义矩阵 $A$ 的**秩**为 $A$ 的列空间的维数，记为 $\\text{rank }A$。\n\n如果一个矩阵 $A$ 有 $n$ 列，那么 $\\text{rank }A+\\dim \\text{Nul } A=n$。（秩定理）\n\n虽然这里产生了很多新的概念，但它们都是围绕着列向量的线性相关性展开的。如果 $A$ 是一个 $n$ 阶可逆矩阵，那么必然有：\n\n- $A$ 的列向量是 $\\mathbb{R}^n$ 的基\n- $\\text{rank }A=n$\n- $\\dim \\text{Col }A=n$\n\n\n","slug":"LA1","published":1,"updated":"2023-02-25T05:46:11.829Z","comments":1,"layout":"post","photos":[],"_id":"cmir5cbx9000j2cle91tpg8jm","content":"<p>矩阵的基本运算</p>\n<span id=\"more\"></span>\n\n<p>矩阵的加法和标量乘法很简单，就不多说了。</p>\n<h2 id=\"矩阵乘法\"><a href=\"#矩阵乘法\" class=\"headerlink\" title=\"矩阵乘法\"></a>矩阵乘法</h2><p>来看一个线性变换：对于 $\\mathbb{R}^k$ 中的一个向量 $\\boldsymbol{v}$，用一个 $n\\times k$ 的矩阵 $B$ 乘上这个 $\\boldsymbol{v}$，就会得到一个 $\\mathbb{R}^n$ 中的向量 $B\\boldsymbol{v}$。容易发现，向量的维度发生了改变。所以如果此时我们再需要对其进行一次变换，必须用一个 $n$ 列的矩阵。假设用一个 $m\\times n$ 矩阵 $A$ 乘上新向量 $B\\boldsymbol{v}$，就得到了向量 $A(B\\boldsymbol{v})$。</p>\n<p>由于线性变换的标准矩阵是唯一的，所以存在一个矩阵 $AB$ 满足 $(AB)\\boldsymbol{v}&#x3D;A(B\\boldsymbol{v})$。矩阵乘法的概念就是这么来的。</p>\n<p>对于一个 $n\\times k$ 的矩阵 $B$，可以将其每一列看作一个 $n$ 维向量，即 $B&#x3D;[\\boldsymbol{b_1},\\boldsymbol{b_2},\\cdots ,\\boldsymbol{b_k}]$。那么矩阵 $AB$ 就应该是 $[A\\boldsymbol{b_1},A\\boldsymbol{b_2},\\cdots ,A\\boldsymbol{b_k}]$，其实就相当于拆成矩阵和向量的乘积以后再拼回去。显然，$A$ 的列数必须等于 $B$ 的行数。</p>\n<p>这也就很好理解为什么两个矩阵相乘必须是前者的每一行乘上后者的每一列。</p>\n<p>结合矩阵加法和标量乘法的性质，容易发现矩阵的乘法满足结合律和分配律，但是不满足交换律。</p>\n<p>定义矩阵的主对角线为所有行列下标相等的元素，单位矩阵 $I_n$ 为主对角线元素均为 $1$、其余元素均为 $0$ 的 $n\\times n$ 矩阵。容易证明，$I_mA&#x3D;A&#x3D;AI_n$。</p>\n<p>值得注意的是，即便 $AB&#x3D;AC$ 且 $A$ 不为零矩阵，也不能推出 $B&#x3D;C$。</p>\n<h2 id=\"转置\"><a href=\"#转置\" class=\"headerlink\" title=\"转置\"></a>转置</h2><p>对于 $m\\times n$ 矩阵 $A$，它的转置 $A^T$ 是一个 $n\\times m$ 矩阵，它的列由 $A$ 的对应行构成。</p>\n<p>显然，矩阵的转置有以下的性质：</p>\n<ul>\n<li>$(A^T)^T&#x3D;A$</li>\n<li>$(A+B)^T&#x3D;A^T+B^T$</li>\n<li>$(rA)^T&#x3D;rA^T$（$r$ 为常数）</li>\n<li>$(AB)^T&#x3D;B^TA^T$</li>\n</ul>\n<p>前三个很显然。下面证明第四个性质：对于 $(AB)^T$ 中位于 $(i,j)$ 的元素，在 $AB$ 中位于 $(j,i)$，等于 $\\sum_{t&#x3D;1}^n a_{jt}b_{ti}$。而 $B^T$ 的第 $i$ 行，就是 $B$ 的第 $i$ 列，即 $b_{1i},b_{2i},\\cdots,b_{ni}$；$A^T$ 的第 $j$ 列，就是 $A$ 的第 $j$ 行，即 $a_{j1},a_{j2},\\cdots,a_{jn}$，对应位置相乘后求和就是 $\\sum_{t&#x3D;1}^n a_{jt}b_{ti}$。</p>\n<p>事实上，有</p>\n<p>$$<br>(\\prod_{i&#x3D;1}^n A_i)^T&#x3D;\\prod_{i&#x3D;n}^1 A_i^T<br>$$</p>\n<p>这可以通过数学归纳法来证明。</p>\n<h2 id=\"矩阵的逆\"><a href=\"#矩阵的逆\" class=\"headerlink\" title=\"矩阵的逆\"></a>矩阵的逆</h2><p>定义了加减乘三种运算后，我们不禁会想，能不能给矩阵也定义一个除法？</p>\n<p>参考离散数学里逆元的概念，所谓除法，就相当于对于一个给定的元素 $A$，求 $A$ 的逆元 $A^{-1}$，满足 $A^{-1}\\times A&#x3D;A\\times A^{-1}&#x3D;\\epsilon$。对于矩阵而言，幺元 $\\epsilon$ 就是单位矩阵。由于 $A^{-1}\\times A$ 和 $A\\times A^{-1}$ 都必须有意义，$A$ 必须是一个方阵。我们称 $A^{-1}$ 为 $A$ 的逆矩阵。</p>\n<p>由此可见，并非所有的矩阵都有逆矩阵。如果一个矩阵有逆矩阵，就称其为可逆矩阵，或者<strong>非奇异矩阵</strong>；否则称其为不可逆矩阵，或<strong>奇异矩阵</strong>。</p>\n<p>可逆矩阵也具有几个基本性质：</p>\n<ul>\n<li>可逆矩阵的逆矩阵是唯一的</li>\n<li>若 $A$ 可逆，则 $A^{-1}$ 也可逆，且 $(A^{-1})^{-1}&#x3D;A$</li>\n<li>$(AB)^{-1}&#x3D;B^{-1}A^{-1}$</li>\n<li>若 $A$ 可逆，则 $A^T$ 也可逆，且 $(A^{T})^{-1}&#x3D;(A^{-1})^T$</li>\n</ul>\n<p>利用定义，很容易证明前三个性质。第四个需要结合转置的性质来证明：</p>\n<p>$$<br>(A^{-1})^TA^T&#x3D;(AA^{-1})^T&#x3D;I^T&#x3D;I<br>$$</p>\n<p>类似于转置的性质，$(AB)^{-1}&#x3D;B^{-1}A^{-1}$ 也可以进行推广（其中 $A_i$ 都是维度相同的可逆矩阵）：</p>\n<p>$$<br>(\\prod_{i&#x3D;1}^n A_i)^{-1}&#x3D;\\prod_{i&#x3D;n}^1 A_i^{-1}<br>$$</p>\n<p>逆矩阵的求法较为复杂，需要先做一些准备。</p>\n<h3 id=\"初等矩阵\"><a href=\"#初等矩阵\" class=\"headerlink\" title=\"初等矩阵\"></a>初等矩阵</h3><p>把单位矩阵做一次初等行变换，就得到<strong>初等矩阵</strong>。</p>\n<p>如果对矩阵乘法的流程比较熟悉，就可以发现，如果对一个矩阵 $A$ 进行一次初等行变换，就相当于对 $A$ 左乘一个初等矩阵 $E$，其中 $E$ 是对单位矩阵进行同样的初等行变换得到的。</p>\n<p>由于初等行变换是可逆的，所以初等矩阵也是可逆的。这就产生了一种求逆矩阵的思路：</p>\n<p>若 $n$ 阶方阵 $A$ 是可逆的，那么 $A$ 必须行等价于 $I_n$，把 $A$ 化简为 $I_n$ 的一系列初等行变换作用于 $I_n$ 就得到了 $A^{-1}$。</p>\n<p>这就是把 $A$ 和 $I$ 排在一起构成增广矩阵 $[A\\quad I]$，然后把 $A$ 变成 $I$ 来求逆矩阵的原理。</p>\n<p>也可以换一个角度看待这种方法，对于 $A^{-1}$ 中的第 $i$ 列，将其取出命名为向量 $\\boldsymbol{x_i}$，那么相当于有向量方程组</p>\n<p>$$<br>A\\boldsymbol{x_i}&#x3D;\\boldsymbol{e_i}<br>$$</p>\n<p>其中 $\\boldsymbol{e_i}$ 是单位矩阵的第 $i$ 列形成的向量。</p>\n<h2 id=\"分块矩阵\"><a href=\"#分块矩阵\" class=\"headerlink\" title=\"分块矩阵\"></a>分块矩阵</h2><p>分块的思想十分简单，在我们将一个矩阵看作若干向量的组合时，就已经是一种对矩阵的分块了。</p>\n<p>分块矩阵的乘法和普通的矩阵乘法差不多，注意不要写错顺序就行了。</p>\n<p>例如：</p>\n<h1 id=\"left-begin-array-ccc-A-11-A-12-A-21-A-22-end-array-right-times-left-begin-array-ccc-B-11-B-12-B-21-B-22-end-array-right-quad\"><a href=\"#left-begin-array-ccc-A-11-A-12-A-21-A-22-end-array-right-times-left-begin-array-ccc-B-11-B-12-B-21-B-22-end-array-right-quad\" class=\"headerlink\" title=\"$$\\left[ \\begin{array}{ccc}A_{11} &amp; A_{12}\\A_{21} &amp; A_{22}\\end{array} \\right]\\times\\left[ \\begin{array}{ccc}B_{11} &amp; B_{12}\\B_{21} &amp; B_{22}\\end{array} \\right]\\ \\quad\\\"></a>$$<br>\\left[ \\begin{array}{ccc}<br>A_{11} &amp; A_{12}\\<br>A_{21} &amp; A_{22}<br>\\end{array} \\right]\\times<br>\\left[ \\begin{array}{ccc}<br>B_{11} &amp; B_{12}\\<br>B_{21} &amp; B_{22}<br>\\end{array} \\right]<br>\\ \\quad<br>\\</h1><p>\\left[ \\begin{array}{ccc}<br>A_{11}B_{11}+A_{12}B_{21} &amp; A_{11}B_{12}+A_{12}B_{22}\\<br>A_{21}B_{11}+A_{22}B_{21} &amp; A_{21}B_{12}+A_{22}B_{22}<br>\\end{array} \\right]</p>\n<p>$$</p>\n<p>而分块矩阵求逆就很复杂。具体这里就不写了，只提一个小结论：分块对角矩阵是一个分块矩阵，除了主对角线上的分块外，其余全是零分块。这样的矩阵可逆当且仅当对角线上所有矩阵均可逆。</p>\n<p>分块矩阵和矩阵的因式分解在数值计算中都十分重要，以后有空写一下。</p>\n<h2 id=\"秩\"><a href=\"#秩\" class=\"headerlink\" title=\"秩\"></a>秩</h2><h3 id=\"子空间\"><a href=\"#子空间\" class=\"headerlink\" title=\"子空间\"></a>子空间</h3><p>我们已经知道，一个 $m\\times n$ 矩阵 $A$ 可以看作 $n$ 个 $\\mathbb{R}^m$ 空间内的向量的集合。当 $A$ 乘上一个向量 $\\boldsymbol{x}$ 的时候，就相当于是将这 $n$ 个向量进行了一定长度的伸缩变换后重新加到了一起。那么对于 $\\boldsymbol{x}$ 的所有取值，产生的所有新向量 $A\\boldsymbol{x}$ 就形成了一个 $\\mathbb{R}^m$ 的子空间 $H$。</p>\n<p>显然，$H$ 具有以下性质：</p>\n<ul>\n<li>$\\boldsymbol{0}\\in H$</li>\n<li>$\\forall \\boldsymbol{u},\\boldsymbol{v}\\in H,\\boldsymbol{u}+\\boldsymbol{v}\\in H$</li>\n<li>$\\forall \\boldsymbol{u}\\in H, c\\boldsymbol{u}\\in H$（$c$ 为常数）</li>\n</ul>\n<p>所以说，子空间对于加法和标量乘法运算是封闭的。</p>\n<p>定义矩阵 $A$ 的<strong>列空间</strong>为 $A$ 的各列的线性组合的集合，记作 $\\text{Col }A$。</p>\n<p>不难发现，$\\text{Col }A$ 就是 $\\text{Span}\\lbrace \\boldsymbol{a_1}\\cdots\\boldsymbol{a_n} \\rbrace$ 的另一种表示。显然，$\\text{Col }A\\subseteq \\mathbb{R}^m$，并且只有在 $A$ 的列生成 $\\mathbb{R}^m$ 时取到等号。</p>\n<p>定义矩阵 $A$ 的<strong>零空间</strong>为齐次方程 $A\\boldsymbol{x}&#x3D;\\boldsymbol{b}$ 的所有解的集合，记作 $\\text{Nul }A$。</p>\n<p>不难发现，$\\text{Nul }A$ 一定是 $\\mathbb{R}^n$ 的一个子空间。</p>\n<p>子空间一般含有无穷个向量，所以最好能通过一个有限的向量集合来表示一个子空间。定义 $\\mathbb{R}^n$ 的子空间 $H$ 的一组<strong>基</strong>是 $H$ 中的一个线性无关集，它生成 $H$。</p>\n<p>显然，$n$ 阶单位矩阵中的 $n$ 个列向量 $\\boldsymbol{e_1}\\cdots\\boldsymbol{e_n}$ 就构成了 $\\mathbb{R}^n$ 的一组基。$\\lbrace\\boldsymbol{e_1}\\cdots\\boldsymbol{e_n}\\rbrace$ 称为 $\\mathbb{R}^n$ 的<strong>标准基</strong>。</p>\n<p>矩阵 $A$ 的主元列构成 $A$ 的列空间的基。</p>\n<p>有一点需要特殊说明，零子空间没有基。</p>\n<h3 id=\"秩-1\"><a href=\"#秩-1\" class=\"headerlink\" title=\"秩\"></a>秩</h3><p>假设 $\\mathcal{B}&#x3D;\\lbrace \\boldsymbol{b_1}\\cdots\\boldsymbol{b_p}  \\rbrace$ 是子空间 $H$ 的一组基，对 $H$ 中的每一个向量 $\\boldsymbol{x}$，其相对于 $H$ 的坐标是使 $\\boldsymbol{x}&#x3D;c_1\\boldsymbol{b_1}+\\cdots+c_p\\boldsymbol{b_p}$ 成立的一组权值 $c_i$，且 $\\mathbb{R}^p$ 中的向量</p>\n<p>$$<br>[\\boldsymbol{x}]_{\\mathcal{B}}&#x3D;\\left[<br>\\begin{array}{ccc}<br>c_1\\<br>\\vdots\\<br>c_p<br>\\end{array}<br>\\right]<br>$$</p>\n<p>称为 $\\boldsymbol{x}$ 相对于 $\\mathcal{B}$ 的坐标向量，或 $\\boldsymbol{x}$ 的 $\\mathcal{B}$-坐标向量。</p>\n<h4 id=\"同构\"><a href=\"#同构\" class=\"headerlink\" title=\"同构\"></a>同构</h4><p>如果映射 $\\boldsymbol{x}\\to [\\boldsymbol{x}]_{\\mathcal{B}}$ 是 $H$ 和 $\\mathbb{R}^p$ 之间保持线性关系的一一映射，则称这种映射是<strong>同构</strong>的，且 $H$ 与 $\\mathbb{R}^p$ 同构。</p>\n<p>如果 $\\mathcal{B}&#x3D;\\lbrace \\boldsymbol{b_1}\\cdots\\boldsymbol{b_p}  \\rbrace$ 是 $H$ 的基，则映射 $\\boldsymbol{x}\\to [\\boldsymbol{x}]_{\\mathcal{B}}$ 是使 $H$ 和 $\\mathbb{R}^p$ 之间保持线性关系的一一映射。</p>\n<h4 id=\"维数\"><a href=\"#维数\" class=\"headerlink\" title=\"维数\"></a>维数</h4><p>可以证明，一个子空间的所有基都拥有相同数量的向量。</p>\n<p>定义子空间 $H$ 的维数 $\\dim H$ 为 $H$ 的任意一个基的向量个数。$\\lbrace \\boldsymbol{0}\\rbrace$ 的维数为零。</p>\n<p>定义矩阵 $A$ 的<strong>秩</strong>为 $A$ 的列空间的维数，记为 $\\text{rank }A$。</p>\n<p>如果一个矩阵 $A$ 有 $n$ 列，那么 $\\text{rank }A+\\dim \\text{Nul } A&#x3D;n$。（秩定理）</p>\n<p>虽然这里产生了很多新的概念，但它们都是围绕着列向量的线性相关性展开的。如果 $A$ 是一个 $n$ 阶可逆矩阵，那么必然有：</p>\n<ul>\n<li>$A$ 的列向量是 $\\mathbb{R}^n$ 的基</li>\n<li>$\\text{rank }A&#x3D;n$</li>\n<li>$\\dim \\text{Col }A&#x3D;n$</li>\n</ul>\n","excerpt":"<p>矩阵的基本运算</p>","more":"<p>矩阵的加法和标量乘法很简单，就不多说了。</p>\n<h2 id=\"矩阵乘法\"><a href=\"#矩阵乘法\" class=\"headerlink\" title=\"矩阵乘法\"></a>矩阵乘法</h2><p>来看一个线性变换：对于 $\\mathbb{R}^k$ 中的一个向量 $\\boldsymbol{v}$，用一个 $n\\times k$ 的矩阵 $B$ 乘上这个 $\\boldsymbol{v}$，就会得到一个 $\\mathbb{R}^n$ 中的向量 $B\\boldsymbol{v}$。容易发现，向量的维度发生了改变。所以如果此时我们再需要对其进行一次变换，必须用一个 $n$ 列的矩阵。假设用一个 $m\\times n$ 矩阵 $A$ 乘上新向量 $B\\boldsymbol{v}$，就得到了向量 $A(B\\boldsymbol{v})$。</p>\n<p>由于线性变换的标准矩阵是唯一的，所以存在一个矩阵 $AB$ 满足 $(AB)\\boldsymbol{v}&#x3D;A(B\\boldsymbol{v})$。矩阵乘法的概念就是这么来的。</p>\n<p>对于一个 $n\\times k$ 的矩阵 $B$，可以将其每一列看作一个 $n$ 维向量，即 $B&#x3D;[\\boldsymbol{b_1},\\boldsymbol{b_2},\\cdots ,\\boldsymbol{b_k}]$。那么矩阵 $AB$ 就应该是 $[A\\boldsymbol{b_1},A\\boldsymbol{b_2},\\cdots ,A\\boldsymbol{b_k}]$，其实就相当于拆成矩阵和向量的乘积以后再拼回去。显然，$A$ 的列数必须等于 $B$ 的行数。</p>\n<p>这也就很好理解为什么两个矩阵相乘必须是前者的每一行乘上后者的每一列。</p>\n<p>结合矩阵加法和标量乘法的性质，容易发现矩阵的乘法满足结合律和分配律，但是不满足交换律。</p>\n<p>定义矩阵的主对角线为所有行列下标相等的元素，单位矩阵 $I_n$ 为主对角线元素均为 $1$、其余元素均为 $0$ 的 $n\\times n$ 矩阵。容易证明，$I_mA&#x3D;A&#x3D;AI_n$。</p>\n<p>值得注意的是，即便 $AB&#x3D;AC$ 且 $A$ 不为零矩阵，也不能推出 $B&#x3D;C$。</p>\n<h2 id=\"转置\"><a href=\"#转置\" class=\"headerlink\" title=\"转置\"></a>转置</h2><p>对于 $m\\times n$ 矩阵 $A$，它的转置 $A^T$ 是一个 $n\\times m$ 矩阵，它的列由 $A$ 的对应行构成。</p>\n<p>显然，矩阵的转置有以下的性质：</p>\n<ul>\n<li>$(A^T)^T&#x3D;A$</li>\n<li>$(A+B)^T&#x3D;A^T+B^T$</li>\n<li>$(rA)^T&#x3D;rA^T$（$r$ 为常数）</li>\n<li>$(AB)^T&#x3D;B^TA^T$</li>\n</ul>\n<p>前三个很显然。下面证明第四个性质：对于 $(AB)^T$ 中位于 $(i,j)$ 的元素，在 $AB$ 中位于 $(j,i)$，等于 $\\sum_{t&#x3D;1}^n a_{jt}b_{ti}$。而 $B^T$ 的第 $i$ 行，就是 $B$ 的第 $i$ 列，即 $b_{1i},b_{2i},\\cdots,b_{ni}$；$A^T$ 的第 $j$ 列，就是 $A$ 的第 $j$ 行，即 $a_{j1},a_{j2},\\cdots,a_{jn}$，对应位置相乘后求和就是 $\\sum_{t&#x3D;1}^n a_{jt}b_{ti}$。</p>\n<p>事实上，有</p>\n<p>$$<br>(\\prod_{i&#x3D;1}^n A_i)^T&#x3D;\\prod_{i&#x3D;n}^1 A_i^T<br>$$</p>\n<p>这可以通过数学归纳法来证明。</p>\n<h2 id=\"矩阵的逆\"><a href=\"#矩阵的逆\" class=\"headerlink\" title=\"矩阵的逆\"></a>矩阵的逆</h2><p>定义了加减乘三种运算后，我们不禁会想，能不能给矩阵也定义一个除法？</p>\n<p>参考离散数学里逆元的概念，所谓除法，就相当于对于一个给定的元素 $A$，求 $A$ 的逆元 $A^{-1}$，满足 $A^{-1}\\times A&#x3D;A\\times A^{-1}&#x3D;\\epsilon$。对于矩阵而言，幺元 $\\epsilon$ 就是单位矩阵。由于 $A^{-1}\\times A$ 和 $A\\times A^{-1}$ 都必须有意义，$A$ 必须是一个方阵。我们称 $A^{-1}$ 为 $A$ 的逆矩阵。</p>\n<p>由此可见，并非所有的矩阵都有逆矩阵。如果一个矩阵有逆矩阵，就称其为可逆矩阵，或者<strong>非奇异矩阵</strong>；否则称其为不可逆矩阵，或<strong>奇异矩阵</strong>。</p>\n<p>可逆矩阵也具有几个基本性质：</p>\n<ul>\n<li>可逆矩阵的逆矩阵是唯一的</li>\n<li>若 $A$ 可逆，则 $A^{-1}$ 也可逆，且 $(A^{-1})^{-1}&#x3D;A$</li>\n<li>$(AB)^{-1}&#x3D;B^{-1}A^{-1}$</li>\n<li>若 $A$ 可逆，则 $A^T$ 也可逆，且 $(A^{T})^{-1}&#x3D;(A^{-1})^T$</li>\n</ul>\n<p>利用定义，很容易证明前三个性质。第四个需要结合转置的性质来证明：</p>\n<p>$$<br>(A^{-1})^TA^T&#x3D;(AA^{-1})^T&#x3D;I^T&#x3D;I<br>$$</p>\n<p>类似于转置的性质，$(AB)^{-1}&#x3D;B^{-1}A^{-1}$ 也可以进行推广（其中 $A_i$ 都是维度相同的可逆矩阵）：</p>\n<p>$$<br>(\\prod_{i&#x3D;1}^n A_i)^{-1}&#x3D;\\prod_{i&#x3D;n}^1 A_i^{-1}<br>$$</p>\n<p>逆矩阵的求法较为复杂，需要先做一些准备。</p>\n<h3 id=\"初等矩阵\"><a href=\"#初等矩阵\" class=\"headerlink\" title=\"初等矩阵\"></a>初等矩阵</h3><p>把单位矩阵做一次初等行变换，就得到<strong>初等矩阵</strong>。</p>\n<p>如果对矩阵乘法的流程比较熟悉，就可以发现，如果对一个矩阵 $A$ 进行一次初等行变换，就相当于对 $A$ 左乘一个初等矩阵 $E$，其中 $E$ 是对单位矩阵进行同样的初等行变换得到的。</p>\n<p>由于初等行变换是可逆的，所以初等矩阵也是可逆的。这就产生了一种求逆矩阵的思路：</p>\n<p>若 $n$ 阶方阵 $A$ 是可逆的，那么 $A$ 必须行等价于 $I_n$，把 $A$ 化简为 $I_n$ 的一系列初等行变换作用于 $I_n$ 就得到了 $A^{-1}$。</p>\n<p>这就是把 $A$ 和 $I$ 排在一起构成增广矩阵 $[A\\quad I]$，然后把 $A$ 变成 $I$ 来求逆矩阵的原理。</p>\n<p>也可以换一个角度看待这种方法，对于 $A^{-1}$ 中的第 $i$ 列，将其取出命名为向量 $\\boldsymbol{x_i}$，那么相当于有向量方程组</p>\n<p>$$<br>A\\boldsymbol{x_i}&#x3D;\\boldsymbol{e_i}<br>$$</p>\n<p>其中 $\\boldsymbol{e_i}$ 是单位矩阵的第 $i$ 列形成的向量。</p>\n<h2 id=\"分块矩阵\"><a href=\"#分块矩阵\" class=\"headerlink\" title=\"分块矩阵\"></a>分块矩阵</h2><p>分块的思想十分简单，在我们将一个矩阵看作若干向量的组合时，就已经是一种对矩阵的分块了。</p>\n<p>分块矩阵的乘法和普通的矩阵乘法差不多，注意不要写错顺序就行了。</p>\n<p>例如：</p>\n<h1 id=\"left-begin-array-ccc-A-11-A-12-A-21-A-22-end-array-right-times-left-begin-array-ccc-B-11-B-12-B-21-B-22-end-array-right-quad\"><a href=\"#left-begin-array-ccc-A-11-A-12-A-21-A-22-end-array-right-times-left-begin-array-ccc-B-11-B-12-B-21-B-22-end-array-right-quad\" class=\"headerlink\" title=\"$$\\left[ \\begin{array}{ccc}A_{11} &amp; A_{12}\\A_{21} &amp; A_{22}\\end{array} \\right]\\times\\left[ \\begin{array}{ccc}B_{11} &amp; B_{12}\\B_{21} &amp; B_{22}\\end{array} \\right]\\ \\quad\\\"></a>$$<br>\\left[ \\begin{array}{ccc}<br>A_{11} &amp; A_{12}\\<br>A_{21} &amp; A_{22}<br>\\end{array} \\right]\\times<br>\\left[ \\begin{array}{ccc}<br>B_{11} &amp; B_{12}\\<br>B_{21} &amp; B_{22}<br>\\end{array} \\right]<br>\\ \\quad<br>\\</h1><p>\\left[ \\begin{array}{ccc}<br>A_{11}B_{11}+A_{12}B_{21} &amp; A_{11}B_{12}+A_{12}B_{22}\\<br>A_{21}B_{11}+A_{22}B_{21} &amp; A_{21}B_{12}+A_{22}B_{22}<br>\\end{array} \\right]</p>\n<p>$$</p>\n<p>而分块矩阵求逆就很复杂。具体这里就不写了，只提一个小结论：分块对角矩阵是一个分块矩阵，除了主对角线上的分块外，其余全是零分块。这样的矩阵可逆当且仅当对角线上所有矩阵均可逆。</p>\n<p>分块矩阵和矩阵的因式分解在数值计算中都十分重要，以后有空写一下。</p>\n<h2 id=\"秩\"><a href=\"#秩\" class=\"headerlink\" title=\"秩\"></a>秩</h2><h3 id=\"子空间\"><a href=\"#子空间\" class=\"headerlink\" title=\"子空间\"></a>子空间</h3><p>我们已经知道，一个 $m\\times n$ 矩阵 $A$ 可以看作 $n$ 个 $\\mathbb{R}^m$ 空间内的向量的集合。当 $A$ 乘上一个向量 $\\boldsymbol{x}$ 的时候，就相当于是将这 $n$ 个向量进行了一定长度的伸缩变换后重新加到了一起。那么对于 $\\boldsymbol{x}$ 的所有取值，产生的所有新向量 $A\\boldsymbol{x}$ 就形成了一个 $\\mathbb{R}^m$ 的子空间 $H$。</p>\n<p>显然，$H$ 具有以下性质：</p>\n<ul>\n<li>$\\boldsymbol{0}\\in H$</li>\n<li>$\\forall \\boldsymbol{u},\\boldsymbol{v}\\in H,\\boldsymbol{u}+\\boldsymbol{v}\\in H$</li>\n<li>$\\forall \\boldsymbol{u}\\in H, c\\boldsymbol{u}\\in H$（$c$ 为常数）</li>\n</ul>\n<p>所以说，子空间对于加法和标量乘法运算是封闭的。</p>\n<p>定义矩阵 $A$ 的<strong>列空间</strong>为 $A$ 的各列的线性组合的集合，记作 $\\text{Col }A$。</p>\n<p>不难发现，$\\text{Col }A$ 就是 $\\text{Span}\\lbrace \\boldsymbol{a_1}\\cdots\\boldsymbol{a_n} \\rbrace$ 的另一种表示。显然，$\\text{Col }A\\subseteq \\mathbb{R}^m$，并且只有在 $A$ 的列生成 $\\mathbb{R}^m$ 时取到等号。</p>\n<p>定义矩阵 $A$ 的<strong>零空间</strong>为齐次方程 $A\\boldsymbol{x}&#x3D;\\boldsymbol{b}$ 的所有解的集合，记作 $\\text{Nul }A$。</p>\n<p>不难发现，$\\text{Nul }A$ 一定是 $\\mathbb{R}^n$ 的一个子空间。</p>\n<p>子空间一般含有无穷个向量，所以最好能通过一个有限的向量集合来表示一个子空间。定义 $\\mathbb{R}^n$ 的子空间 $H$ 的一组<strong>基</strong>是 $H$ 中的一个线性无关集，它生成 $H$。</p>\n<p>显然，$n$ 阶单位矩阵中的 $n$ 个列向量 $\\boldsymbol{e_1}\\cdots\\boldsymbol{e_n}$ 就构成了 $\\mathbb{R}^n$ 的一组基。$\\lbrace\\boldsymbol{e_1}\\cdots\\boldsymbol{e_n}\\rbrace$ 称为 $\\mathbb{R}^n$ 的<strong>标准基</strong>。</p>\n<p>矩阵 $A$ 的主元列构成 $A$ 的列空间的基。</p>\n<p>有一点需要特殊说明，零子空间没有基。</p>\n<h3 id=\"秩-1\"><a href=\"#秩-1\" class=\"headerlink\" title=\"秩\"></a>秩</h3><p>假设 $\\mathcal{B}&#x3D;\\lbrace \\boldsymbol{b_1}\\cdots\\boldsymbol{b_p}  \\rbrace$ 是子空间 $H$ 的一组基，对 $H$ 中的每一个向量 $\\boldsymbol{x}$，其相对于 $H$ 的坐标是使 $\\boldsymbol{x}&#x3D;c_1\\boldsymbol{b_1}+\\cdots+c_p\\boldsymbol{b_p}$ 成立的一组权值 $c_i$，且 $\\mathbb{R}^p$ 中的向量</p>\n<p>$$<br>[\\boldsymbol{x}]_{\\mathcal{B}}&#x3D;\\left[<br>\\begin{array}{ccc}<br>c_1\\<br>\\vdots\\<br>c_p<br>\\end{array}<br>\\right]<br>$$</p>\n<p>称为 $\\boldsymbol{x}$ 相对于 $\\mathcal{B}$ 的坐标向量，或 $\\boldsymbol{x}$ 的 $\\mathcal{B}$-坐标向量。</p>\n<h4 id=\"同构\"><a href=\"#同构\" class=\"headerlink\" title=\"同构\"></a>同构</h4><p>如果映射 $\\boldsymbol{x}\\to [\\boldsymbol{x}]_{\\mathcal{B}}$ 是 $H$ 和 $\\mathbb{R}^p$ 之间保持线性关系的一一映射，则称这种映射是<strong>同构</strong>的，且 $H$ 与 $\\mathbb{R}^p$ 同构。</p>\n<p>如果 $\\mathcal{B}&#x3D;\\lbrace \\boldsymbol{b_1}\\cdots\\boldsymbol{b_p}  \\rbrace$ 是 $H$ 的基，则映射 $\\boldsymbol{x}\\to [\\boldsymbol{x}]_{\\mathcal{B}}$ 是使 $H$ 和 $\\mathbb{R}^p$ 之间保持线性关系的一一映射。</p>\n<h4 id=\"维数\"><a href=\"#维数\" class=\"headerlink\" title=\"维数\"></a>维数</h4><p>可以证明，一个子空间的所有基都拥有相同数量的向量。</p>\n<p>定义子空间 $H$ 的维数 $\\dim H$ 为 $H$ 的任意一个基的向量个数。$\\lbrace \\boldsymbol{0}\\rbrace$ 的维数为零。</p>\n<p>定义矩阵 $A$ 的<strong>秩</strong>为 $A$ 的列空间的维数，记为 $\\text{rank }A$。</p>\n<p>如果一个矩阵 $A$ 有 $n$ 列，那么 $\\text{rank }A+\\dim \\text{Nul } A&#x3D;n$。（秩定理）</p>\n<p>虽然这里产生了很多新的概念，但它们都是围绕着列向量的线性相关性展开的。如果 $A$ 是一个 $n$ 阶可逆矩阵，那么必然有：</p>\n<ul>\n<li>$A$ 的列向量是 $\\mathbb{R}^n$ 的基</li>\n<li>$\\text{rank }A&#x3D;n$</li>\n<li>$\\dim \\text{Col }A&#x3D;n$</li>\n</ul>"},{"title":"Manacher's Algorithm","date":"2020-09-30T16:00:00.000Z","math":true,"_content":"\nManacher 算法一般用于解决与回文子串有关的问题。\n\n<!-- more -->\n\n先从一个简单的问题开始：给定字符串 $s$，其长度为 $n$，求它的最长回文子串。\n\n容易想到一个 $O(n^2)$ 的暴力算法：枚举每个字符作为回文串的中心的情况，每次尽可能向两边扩展，这样必定可以找到所有的回文串，可以很轻松得到答案。\n\n这种暴力做法也有一种治标不治本的优化，即二分哈希，可以在 $O(n\\log n)$ 时间解决问题。下面来看 Glenn K. Manacher 在1975年提出的巧妙算法。\n\n在实现上述暴力算法的时候，容易注意到一个事实：长度为奇数的回文串与长度为偶数的回文串是不一样的，需要分开讨论。所以下面先只考虑长度为奇数的情况。\n\n现在我们设法对之前的暴力算法进行优化。暴力算法之所以复杂度为 $O(n^2)$，是因为它对于每个位置都独立的计算出了以该位置为中心的最长回文子串。那么如何像 KMP 等其他常见字符串算法一样，利用之前得到的信息来优化当前的流程呢？回忆字符串的 border 的概念，回文串也有类似的性质。假设有一个长度为奇数的回文串 $p$，其对称中心在 $x$ 处，左右端点为 $(x-r,x+r)$，那么显然，$\\forall t \\in[0,r]$，字符串 $[x-r,x-r+2t]$ 和字符串 $[x+r-2t,x+r]$ 相等。\n\n利用这条性质就可以进行一些优化。假设之前我们找到的右端点最靠右的回文串 $q$ 是 $[l,r]$，当前计算的位置是 $i$，那么有两种可能：\n\n- $i\\le r$：此时的 $i$ 位于一个回文串的内部，找到 $i$ 在 $q$ 内的对称点 $j$（$j=l+r-i$），显然以 $j$ 为中心的最长回文子串 $p_j$ 已经被计算过了。由于 $q$ 是已知的右端点最靠右的回文串，$p_j$ 的右端点必然不超过 $r$。令 $l_j$ 为 $p_j$ 的左端点，取 $l_0=\\max(l,l_j)$，那么 $p_j$ 与 $q$ 相交的长度为 $2\\times(j-l_0)+1$，将这个串对称到右边，就得到了一个以 $i$ 为中心的回文串，并且该回文串的右端点 $r_i$ 不超过 $r$。若 $r_i\\lt r$，说明此处的回文串已经找完了，可以开始计算下一位置；否则意味着可以继续向外延伸，那就只能暴力往后找了。\n\n- $i\\gt r$：此时右边的字符都是未知的，没有任何可以利用的信息，只能采用暴力算法进行计算。\n\n奇数长度回文串的问题就此解决了。偶数长度的回文串也可以采用类似的方法解决，但也能用一种简便的方法：在原串的首尾以及所有两个字符的间隔出均插入一个字符集之外的字符，形成一个长度为 $2n+1$ 的新串，则原串内所有长度为偶数的回文串在新串中也变成了长度为奇数的回文串。\n\nManacher 算法的代码实现也并不复杂，这里以求字符串 $s$ 的最长回文子串为例：\n\n``` cpp\nstring manacher(string &s){\n    int n = s.length();\n    vector<char> aux(2 * n + 2);\n    int m = -1;\n    for (auto &&c : s) {\n        aux[++m] = '#';\n        aux[++m] = c;\n    }\n    aux[++m] = '#';\n    int l = 0, r = -1;\n    vector<int> p(m + 1, 0);\n    for (int i = 0; i <= m; ++i) {\n        if (i >= r) {\n            while (i - p[i] >= 0 && i + p[i] <= m && aux[i - p[i]] == aux[i + p[i]])\n                p[i]++;\n            l = i - p[i], r = i + p[i];\n        } else {\n            int j = l + r - i;\n            p[i] = j - max(j - p[j], l);\n            if (i + p[i] == r) {\n                while (i - p[i] >= 0 && i + p[i] <= m && aux[i - p[i]] == aux[i + p[i]])\n                    p[i]++;\n                l = i - p[i], r = i + p[i];\n            }\n        }\n    }\n    int st = 0, len = 0;\n    for (int i = 0; i <= m; ++i) {\n        if (p[i] - 1 > len) {\n            len = p[i] - 1;\n            st = (i - p[i] + 1) / 2;\n        }\n    }\n    return s.substr(st, len);\n}\n```\n\n可能最容易出错的部分是从新串映射回原串的过程，如果下标不从 $0$ 开始就是另一种写法了。\n\n虽然 Manacher 算法在很多情况下都会去暴力的扩展，但它的时间复杂度依然是 $O(n)$，因为每次暴力扩展都会导致 $r$ 的改变，而 $r$ 只增不减，且不会超过 $2n+1$，所以暴力扩展的次数是 $O(n)$ 的。\n\n- 84758431\n\n![84758431.jpg](https://i.loli.net/2020/12/10/yBUpl1i3DhwJMYx.jpg)\n","source":"_posts/Manacher.md","raw":"---\ntitle: Manacher's Algorithm\ndate: 2020-10-01\ntag: [manacher]\ncategory: [String]\nmath: true\n---\n\nManacher 算法一般用于解决与回文子串有关的问题。\n\n<!-- more -->\n\n先从一个简单的问题开始：给定字符串 $s$，其长度为 $n$，求它的最长回文子串。\n\n容易想到一个 $O(n^2)$ 的暴力算法：枚举每个字符作为回文串的中心的情况，每次尽可能向两边扩展，这样必定可以找到所有的回文串，可以很轻松得到答案。\n\n这种暴力做法也有一种治标不治本的优化，即二分哈希，可以在 $O(n\\log n)$ 时间解决问题。下面来看 Glenn K. Manacher 在1975年提出的巧妙算法。\n\n在实现上述暴力算法的时候，容易注意到一个事实：长度为奇数的回文串与长度为偶数的回文串是不一样的，需要分开讨论。所以下面先只考虑长度为奇数的情况。\n\n现在我们设法对之前的暴力算法进行优化。暴力算法之所以复杂度为 $O(n^2)$，是因为它对于每个位置都独立的计算出了以该位置为中心的最长回文子串。那么如何像 KMP 等其他常见字符串算法一样，利用之前得到的信息来优化当前的流程呢？回忆字符串的 border 的概念，回文串也有类似的性质。假设有一个长度为奇数的回文串 $p$，其对称中心在 $x$ 处，左右端点为 $(x-r,x+r)$，那么显然，$\\forall t \\in[0,r]$，字符串 $[x-r,x-r+2t]$ 和字符串 $[x+r-2t,x+r]$ 相等。\n\n利用这条性质就可以进行一些优化。假设之前我们找到的右端点最靠右的回文串 $q$ 是 $[l,r]$，当前计算的位置是 $i$，那么有两种可能：\n\n- $i\\le r$：此时的 $i$ 位于一个回文串的内部，找到 $i$ 在 $q$ 内的对称点 $j$（$j=l+r-i$），显然以 $j$ 为中心的最长回文子串 $p_j$ 已经被计算过了。由于 $q$ 是已知的右端点最靠右的回文串，$p_j$ 的右端点必然不超过 $r$。令 $l_j$ 为 $p_j$ 的左端点，取 $l_0=\\max(l,l_j)$，那么 $p_j$ 与 $q$ 相交的长度为 $2\\times(j-l_0)+1$，将这个串对称到右边，就得到了一个以 $i$ 为中心的回文串，并且该回文串的右端点 $r_i$ 不超过 $r$。若 $r_i\\lt r$，说明此处的回文串已经找完了，可以开始计算下一位置；否则意味着可以继续向外延伸，那就只能暴力往后找了。\n\n- $i\\gt r$：此时右边的字符都是未知的，没有任何可以利用的信息，只能采用暴力算法进行计算。\n\n奇数长度回文串的问题就此解决了。偶数长度的回文串也可以采用类似的方法解决，但也能用一种简便的方法：在原串的首尾以及所有两个字符的间隔出均插入一个字符集之外的字符，形成一个长度为 $2n+1$ 的新串，则原串内所有长度为偶数的回文串在新串中也变成了长度为奇数的回文串。\n\nManacher 算法的代码实现也并不复杂，这里以求字符串 $s$ 的最长回文子串为例：\n\n``` cpp\nstring manacher(string &s){\n    int n = s.length();\n    vector<char> aux(2 * n + 2);\n    int m = -1;\n    for (auto &&c : s) {\n        aux[++m] = '#';\n        aux[++m] = c;\n    }\n    aux[++m] = '#';\n    int l = 0, r = -1;\n    vector<int> p(m + 1, 0);\n    for (int i = 0; i <= m; ++i) {\n        if (i >= r) {\n            while (i - p[i] >= 0 && i + p[i] <= m && aux[i - p[i]] == aux[i + p[i]])\n                p[i]++;\n            l = i - p[i], r = i + p[i];\n        } else {\n            int j = l + r - i;\n            p[i] = j - max(j - p[j], l);\n            if (i + p[i] == r) {\n                while (i - p[i] >= 0 && i + p[i] <= m && aux[i - p[i]] == aux[i + p[i]])\n                    p[i]++;\n                l = i - p[i], r = i + p[i];\n            }\n        }\n    }\n    int st = 0, len = 0;\n    for (int i = 0; i <= m; ++i) {\n        if (p[i] - 1 > len) {\n            len = p[i] - 1;\n            st = (i - p[i] + 1) / 2;\n        }\n    }\n    return s.substr(st, len);\n}\n```\n\n可能最容易出错的部分是从新串映射回原串的过程，如果下标不从 $0$ 开始就是另一种写法了。\n\n虽然 Manacher 算法在很多情况下都会去暴力的扩展，但它的时间复杂度依然是 $O(n)$，因为每次暴力扩展都会导致 $r$ 的改变，而 $r$ 只增不减，且不会超过 $2n+1$，所以暴力扩展的次数是 $O(n)$ 的。\n\n- 84758431\n\n![84758431.jpg](https://i.loli.net/2020/12/10/yBUpl1i3DhwJMYx.jpg)\n","slug":"Manacher","published":1,"updated":"2023-02-25T05:46:11.839Z","comments":1,"layout":"post","photos":[],"_id":"cmir5cbxa000n2clehybodb22","content":"<p>Manacher 算法一般用于解决与回文子串有关的问题。</p>\n<span id=\"more\"></span>\n\n<p>先从一个简单的问题开始：给定字符串 $s$，其长度为 $n$，求它的最长回文子串。</p>\n<p>容易想到一个 $O(n^2)$ 的暴力算法：枚举每个字符作为回文串的中心的情况，每次尽可能向两边扩展，这样必定可以找到所有的回文串，可以很轻松得到答案。</p>\n<p>这种暴力做法也有一种治标不治本的优化，即二分哈希，可以在 $O(n\\log n)$ 时间解决问题。下面来看 Glenn K. Manacher 在1975年提出的巧妙算法。</p>\n<p>在实现上述暴力算法的时候，容易注意到一个事实：长度为奇数的回文串与长度为偶数的回文串是不一样的，需要分开讨论。所以下面先只考虑长度为奇数的情况。</p>\n<p>现在我们设法对之前的暴力算法进行优化。暴力算法之所以复杂度为 $O(n^2)$，是因为它对于每个位置都独立的计算出了以该位置为中心的最长回文子串。那么如何像 KMP 等其他常见字符串算法一样，利用之前得到的信息来优化当前的流程呢？回忆字符串的 border 的概念，回文串也有类似的性质。假设有一个长度为奇数的回文串 $p$，其对称中心在 $x$ 处，左右端点为 $(x-r,x+r)$，那么显然，$\\forall t \\in[0,r]$，字符串 $[x-r,x-r+2t]$ 和字符串 $[x+r-2t,x+r]$ 相等。</p>\n<p>利用这条性质就可以进行一些优化。假设之前我们找到的右端点最靠右的回文串 $q$ 是 $[l,r]$，当前计算的位置是 $i$，那么有两种可能：</p>\n<ul>\n<li><p>$i\\le r$：此时的 $i$ 位于一个回文串的内部，找到 $i$ 在 $q$ 内的对称点 $j$（$j&#x3D;l+r-i$），显然以 $j$ 为中心的最长回文子串 $p_j$ 已经被计算过了。由于 $q$ 是已知的右端点最靠右的回文串，$p_j$ 的右端点必然不超过 $r$。令 $l_j$ 为 $p_j$ 的左端点，取 $l_0&#x3D;\\max(l,l_j)$，那么 $p_j$ 与 $q$ 相交的长度为 $2\\times(j-l_0)+1$，将这个串对称到右边，就得到了一个以 $i$ 为中心的回文串，并且该回文串的右端点 $r_i$ 不超过 $r$。若 $r_i\\lt r$，说明此处的回文串已经找完了，可以开始计算下一位置；否则意味着可以继续向外延伸，那就只能暴力往后找了。</p>\n</li>\n<li><p>$i\\gt r$：此时右边的字符都是未知的，没有任何可以利用的信息，只能采用暴力算法进行计算。</p>\n</li>\n</ul>\n<p>奇数长度回文串的问题就此解决了。偶数长度的回文串也可以采用类似的方法解决，但也能用一种简便的方法：在原串的首尾以及所有两个字符的间隔出均插入一个字符集之外的字符，形成一个长度为 $2n+1$ 的新串，则原串内所有长度为偶数的回文串在新串中也变成了长度为奇数的回文串。</p>\n<p>Manacher 算法的代码实现也并不复杂，这里以求字符串 $s$ 的最长回文子串为例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">manacher</span><span class=\"params\">(string &amp;s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = s.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">char</span>&gt; <span class=\"title\">aux</span><span class=\"params\">(<span class=\"number\">2</span> * n + <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> m = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;c : s) &#123;</span><br><span class=\"line\">        aux[++m] = <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">        aux[++m] = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    aux[++m] = <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">p</span><span class=\"params\">(m + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= m; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i - p[i] &gt;= <span class=\"number\">0</span> &amp;&amp; i + p[i] &lt;= m &amp;&amp; aux[i - p[i]] == aux[i + p[i]])</span><br><span class=\"line\">                p[i]++;</span><br><span class=\"line\">            l = i - p[i], r = i + p[i];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> j = l + r - i;</span><br><span class=\"line\">            p[i] = j - <span class=\"built_in\">max</span>(j - p[j], l);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i + p[i] == r) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (i - p[i] &gt;= <span class=\"number\">0</span> &amp;&amp; i + p[i] &lt;= m &amp;&amp; aux[i - p[i]] == aux[i + p[i]])</span><br><span class=\"line\">                    p[i]++;</span><br><span class=\"line\">                l = i - p[i], r = i + p[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> st = <span class=\"number\">0</span>, len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= m; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[i] - <span class=\"number\">1</span> &gt; len) &#123;</span><br><span class=\"line\">            len = p[i] - <span class=\"number\">1</span>;</span><br><span class=\"line\">            st = (i - p[i] + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"built_in\">substr</span>(st, len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可能最容易出错的部分是从新串映射回原串的过程，如果下标不从 $0$ 开始就是另一种写法了。</p>\n<p>虽然 Manacher 算法在很多情况下都会去暴力的扩展，但它的时间复杂度依然是 $O(n)$，因为每次暴力扩展都会导致 $r$ 的改变，而 $r$ 只增不减，且不会超过 $2n+1$，所以暴力扩展的次数是 $O(n)$ 的。</p>\n<ul>\n<li>84758431</li>\n</ul>\n<p><img src=\"https://i.loli.net/2020/12/10/yBUpl1i3DhwJMYx.jpg\" alt=\"84758431.jpg\"></p>\n","excerpt":"<p>Manacher 算法一般用于解决与回文子串有关的问题。</p>","more":"<p>先从一个简单的问题开始：给定字符串 $s$，其长度为 $n$，求它的最长回文子串。</p>\n<p>容易想到一个 $O(n^2)$ 的暴力算法：枚举每个字符作为回文串的中心的情况，每次尽可能向两边扩展，这样必定可以找到所有的回文串，可以很轻松得到答案。</p>\n<p>这种暴力做法也有一种治标不治本的优化，即二分哈希，可以在 $O(n\\log n)$ 时间解决问题。下面来看 Glenn K. Manacher 在1975年提出的巧妙算法。</p>\n<p>在实现上述暴力算法的时候，容易注意到一个事实：长度为奇数的回文串与长度为偶数的回文串是不一样的，需要分开讨论。所以下面先只考虑长度为奇数的情况。</p>\n<p>现在我们设法对之前的暴力算法进行优化。暴力算法之所以复杂度为 $O(n^2)$，是因为它对于每个位置都独立的计算出了以该位置为中心的最长回文子串。那么如何像 KMP 等其他常见字符串算法一样，利用之前得到的信息来优化当前的流程呢？回忆字符串的 border 的概念，回文串也有类似的性质。假设有一个长度为奇数的回文串 $p$，其对称中心在 $x$ 处，左右端点为 $(x-r,x+r)$，那么显然，$\\forall t \\in[0,r]$，字符串 $[x-r,x-r+2t]$ 和字符串 $[x+r-2t,x+r]$ 相等。</p>\n<p>利用这条性质就可以进行一些优化。假设之前我们找到的右端点最靠右的回文串 $q$ 是 $[l,r]$，当前计算的位置是 $i$，那么有两种可能：</p>\n<ul>\n<li><p>$i\\le r$：此时的 $i$ 位于一个回文串的内部，找到 $i$ 在 $q$ 内的对称点 $j$（$j&#x3D;l+r-i$），显然以 $j$ 为中心的最长回文子串 $p_j$ 已经被计算过了。由于 $q$ 是已知的右端点最靠右的回文串，$p_j$ 的右端点必然不超过 $r$。令 $l_j$ 为 $p_j$ 的左端点，取 $l_0&#x3D;\\max(l,l_j)$，那么 $p_j$ 与 $q$ 相交的长度为 $2\\times(j-l_0)+1$，将这个串对称到右边，就得到了一个以 $i$ 为中心的回文串，并且该回文串的右端点 $r_i$ 不超过 $r$。若 $r_i\\lt r$，说明此处的回文串已经找完了，可以开始计算下一位置；否则意味着可以继续向外延伸，那就只能暴力往后找了。</p>\n</li>\n<li><p>$i\\gt r$：此时右边的字符都是未知的，没有任何可以利用的信息，只能采用暴力算法进行计算。</p>\n</li>\n</ul>\n<p>奇数长度回文串的问题就此解决了。偶数长度的回文串也可以采用类似的方法解决，但也能用一种简便的方法：在原串的首尾以及所有两个字符的间隔出均插入一个字符集之外的字符，形成一个长度为 $2n+1$ 的新串，则原串内所有长度为偶数的回文串在新串中也变成了长度为奇数的回文串。</p>\n<p>Manacher 算法的代码实现也并不复杂，这里以求字符串 $s$ 的最长回文子串为例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">manacher</span><span class=\"params\">(string &amp;s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = s.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">char</span>&gt; <span class=\"title\">aux</span><span class=\"params\">(<span class=\"number\">2</span> * n + <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> m = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;c : s) &#123;</span><br><span class=\"line\">        aux[++m] = <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">        aux[++m] = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    aux[++m] = <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">p</span><span class=\"params\">(m + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= m; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i - p[i] &gt;= <span class=\"number\">0</span> &amp;&amp; i + p[i] &lt;= m &amp;&amp; aux[i - p[i]] == aux[i + p[i]])</span><br><span class=\"line\">                p[i]++;</span><br><span class=\"line\">            l = i - p[i], r = i + p[i];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> j = l + r - i;</span><br><span class=\"line\">            p[i] = j - <span class=\"built_in\">max</span>(j - p[j], l);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i + p[i] == r) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (i - p[i] &gt;= <span class=\"number\">0</span> &amp;&amp; i + p[i] &lt;= m &amp;&amp; aux[i - p[i]] == aux[i + p[i]])</span><br><span class=\"line\">                    p[i]++;</span><br><span class=\"line\">                l = i - p[i], r = i + p[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> st = <span class=\"number\">0</span>, len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= m; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[i] - <span class=\"number\">1</span> &gt; len) &#123;</span><br><span class=\"line\">            len = p[i] - <span class=\"number\">1</span>;</span><br><span class=\"line\">            st = (i - p[i] + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.<span class=\"built_in\">substr</span>(st, len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可能最容易出错的部分是从新串映射回原串的过程，如果下标不从 $0$ 开始就是另一种写法了。</p>\n<p>虽然 Manacher 算法在很多情况下都会去暴力的扩展，但它的时间复杂度依然是 $O(n)$，因为每次暴力扩展都会导致 $r$ 的改变，而 $r$ 只增不减，且不会超过 $2n+1$，所以暴力扩展的次数是 $O(n)$ 的。</p>\n<ul>\n<li>84758431</li>\n</ul>\n<p><img src=\"https://i.loli.net/2020/12/10/yBUpl1i3DhwJMYx.jpg\" alt=\"84758431.jpg\"></p>"},{"title":"Determinant","date":"2022-07-27T16:00:00.000Z","math":true,"_content":"\n行列式\n\n<!--more-->\n\n设二阶方阵\n\n$$\nA=\\left[ \\begin{array}{ccc}\na & b\\\\\nc & d \n\\end{array} \\right]\n$$\n\n容易证明，若 $A$ 可逆，当且仅当 $ad-bc\\neq 0$。\n\n若 $A$ 可逆，我们还能更进一步求出 $A$ 的逆矩阵：\n\n$$\nA^{-1}=\\frac{1}{ad-bc}\\left[ \\begin{array}{rrr}\nd & -b\\\\\n-c & a \n\\end{array} \\right]\n$$\n\n看起来 $ad-bc$ 这个数似乎与矩阵 $A$ 有着特殊的联系。我们将其称为 $A$ 的行列式，记作 $\\det A=ad-bc$。\n\n然后利用“如果一个 $n$ 阶方阵可逆，当且仅当它的行列式非零。”这一定义，将行列式的概念推广到更大的方阵。\n\n$A,B$ 均为三阶矩阵，$|A|=3,|B|=2,|A^{-1}+B|=2$，求 $|A+B^{-1}|$","source":"_posts/LA2.md","raw":"---\ntitle: Determinant\ndate: 2022-07-28\ntag: [linear algebra]\ncategory: [Linear Algebra]\nmath: true\n---\n\n行列式\n\n<!--more-->\n\n设二阶方阵\n\n$$\nA=\\left[ \\begin{array}{ccc}\na & b\\\\\nc & d \n\\end{array} \\right]\n$$\n\n容易证明，若 $A$ 可逆，当且仅当 $ad-bc\\neq 0$。\n\n若 $A$ 可逆，我们还能更进一步求出 $A$ 的逆矩阵：\n\n$$\nA^{-1}=\\frac{1}{ad-bc}\\left[ \\begin{array}{rrr}\nd & -b\\\\\n-c & a \n\\end{array} \\right]\n$$\n\n看起来 $ad-bc$ 这个数似乎与矩阵 $A$ 有着特殊的联系。我们将其称为 $A$ 的行列式，记作 $\\det A=ad-bc$。\n\n然后利用“如果一个 $n$ 阶方阵可逆，当且仅当它的行列式非零。”这一定义，将行列式的概念推广到更大的方阵。\n\n$A,B$ 均为三阶矩阵，$|A|=3,|B|=2,|A^{-1}+B|=2$，求 $|A+B^{-1}|$","slug":"LA2","published":1,"updated":"2023-02-25T05:46:11.829Z","comments":1,"layout":"post","photos":[],"_id":"cmir5cbxa000p2cle41q41j63","content":"<p>行列式</p>\n<span id=\"more\"></span>\n\n<p>设二阶方阵</p>\n<p>$$<br>A&#x3D;\\left[ \\begin{array}{ccc}<br>a &amp; b\\<br>c &amp; d<br>\\end{array} \\right]<br>$$</p>\n<p>容易证明，若 $A$ 可逆，当且仅当 $ad-bc\\neq 0$。</p>\n<p>若 $A$ 可逆，我们还能更进一步求出 $A$ 的逆矩阵：</p>\n<p>$$<br>A^{-1}&#x3D;\\frac{1}{ad-bc}\\left[ \\begin{array}{rrr}<br>d &amp; -b\\<br>-c &amp; a<br>\\end{array} \\right]<br>$$</p>\n<p>看起来 $ad-bc$ 这个数似乎与矩阵 $A$ 有着特殊的联系。我们将其称为 $A$ 的行列式，记作 $\\det A&#x3D;ad-bc$。</p>\n<p>然后利用“如果一个 $n$ 阶方阵可逆，当且仅当它的行列式非零。”这一定义，将行列式的概念推广到更大的方阵。</p>\n<p>$A,B$ 均为三阶矩阵，$|A|&#x3D;3,|B|&#x3D;2,|A^{-1}+B|&#x3D;2$，求 $|A+B^{-1}|$</p>\n","excerpt":"<p>行列式</p>","more":"<p>设二阶方阵</p>\n<p>$$<br>A&#x3D;\\left[ \\begin{array}{ccc}<br>a &amp; b\\<br>c &amp; d<br>\\end{array} \\right]<br>$$</p>\n<p>容易证明，若 $A$ 可逆，当且仅当 $ad-bc\\neq 0$。</p>\n<p>若 $A$ 可逆，我们还能更进一步求出 $A$ 的逆矩阵：</p>\n<p>$$<br>A^{-1}&#x3D;\\frac{1}{ad-bc}\\left[ \\begin{array}{rrr}<br>d &amp; -b\\<br>-c &amp; a<br>\\end{array} \\right]<br>$$</p>\n<p>看起来 $ad-bc$ 这个数似乎与矩阵 $A$ 有着特殊的联系。我们将其称为 $A$ 的行列式，记作 $\\det A&#x3D;ad-bc$。</p>\n<p>然后利用“如果一个 $n$ 阶方阵可逆，当且仅当它的行列式非零。”这一定义，将行列式的概念推广到更大的方阵。</p>\n<p>$A,B$ 均为三阶矩阵，$|A|&#x3D;3,|B|&#x3D;2,|A^{-1}+B|&#x3D;2$，求 $|A+B^{-1}|$</p>"},{"title":"分数规划","date":"2023-04-05T16:00:00.000Z","math":true,"_content":"\n分数规划问题一般表现为求一个分式的极值。\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, W;\n    cin >> n >> W;\n    vector<int> a(n + 1);\n    vector<int> b(n + 1);\n    double l = 0, r = 0;\n    for (int i = 1; i <= n; ++i) {\n        cin >> b[i] >> a[i];\n        r = max(r, 1.0 * a[i] / b[i]);\n    }\n    double ans;\n    vector<double> dp(W + 1, 0);\n    auto check = [&](double mid) -> bool {\n        for (int i = 1; i <= W; ++i)\n            dp[i] = -1e9;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = W; j >= 0; j--) {\n                int k = min(W, j + b[i]);\n                dp[k] = max(dp[k], dp[j] + a[i] - mid * b[i]);\n            }\n        }\n        return dp[W] > 0;\n    };\n    for (int T = 1; T <= 100; ++T) {\n        double mid = (l + r) / 2;\n        if (check(mid))\n            ans = mid, l = mid;\n        else\n            r = mid;\n        if (fabs(r - l) < 1e-6)\n            break;\n    }\n    cout << (int) (ans * 1000) << endl;\n}\n```","source":"_posts/frac_programming.md","raw":"---\ntitle: 分数规划\ndate: 2023-04-06\ntag: [algorithm]\ncategory: [Algorithm and DataStructure]\nmath: true\n---\n\n分数规划问题一般表现为求一个分式的极值。\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, W;\n    cin >> n >> W;\n    vector<int> a(n + 1);\n    vector<int> b(n + 1);\n    double l = 0, r = 0;\n    for (int i = 1; i <= n; ++i) {\n        cin >> b[i] >> a[i];\n        r = max(r, 1.0 * a[i] / b[i]);\n    }\n    double ans;\n    vector<double> dp(W + 1, 0);\n    auto check = [&](double mid) -> bool {\n        for (int i = 1; i <= W; ++i)\n            dp[i] = -1e9;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = W; j >= 0; j--) {\n                int k = min(W, j + b[i]);\n                dp[k] = max(dp[k], dp[j] + a[i] - mid * b[i]);\n            }\n        }\n        return dp[W] > 0;\n    };\n    for (int T = 1; T <= 100; ++T) {\n        double mid = (l + r) / 2;\n        if (check(mid))\n            ans = mid, l = mid;\n        else\n            r = mid;\n        if (fabs(r - l) < 1e-6)\n            break;\n    }\n    cout << (int) (ans * 1000) << endl;\n}\n```","slug":"frac_programming","published":1,"updated":"2023-04-06T15:04:20.169Z","comments":1,"layout":"post","photos":[],"_id":"cmir5cbxb000t2cle4fzcfq7s","content":"<p>分数规划问题一般表现为求一个分式的极值。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> n, W;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; W;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">b</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; b[i] &gt;&gt; a[i];</span><br><span class=\"line\">        r = <span class=\"built_in\">max</span>(r, <span class=\"number\">1.0</span> * a[i] / b[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">double</span> ans;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">double</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(W + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> check = [&amp;](<span class=\"type\">double</span> mid) -&gt; <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= W; ++i)</span><br><span class=\"line\">            dp[i] = <span class=\"number\">-1e9</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = W; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> k = <span class=\"built_in\">min</span>(W, j + b[i]);</span><br><span class=\"line\">                dp[k] = <span class=\"built_in\">max</span>(dp[k], dp[j] + a[i] - mid * b[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[W] &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> T = <span class=\"number\">1</span>; T &lt;= <span class=\"number\">100</span>; ++T) &#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(mid))</span><br><span class=\"line\">            ans = mid, l = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            r = mid;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">fabs</span>(r - l) &lt; <span class=\"number\">1e-6</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; (<span class=\"type\">int</span>) (ans * <span class=\"number\">1000</span>) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<p>分数规划问题一般表现为求一个分式的极值。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> n, W;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; W;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">b</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; b[i] &gt;&gt; a[i];</span><br><span class=\"line\">        r = <span class=\"built_in\">max</span>(r, <span class=\"number\">1.0</span> * a[i] / b[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">double</span> ans;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">double</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(W + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> check = [&amp;](<span class=\"type\">double</span> mid) -&gt; <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= W; ++i)</span><br><span class=\"line\">            dp[i] = <span class=\"number\">-1e9</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = W; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> k = <span class=\"built_in\">min</span>(W, j + b[i]);</span><br><span class=\"line\">                dp[k] = <span class=\"built_in\">max</span>(dp[k], dp[j] + a[i] - mid * b[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[W] &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> T = <span class=\"number\">1</span>; T &lt;= <span class=\"number\">100</span>; ++T) &#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(mid))</span><br><span class=\"line\">            ans = mid, l = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            r = mid;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">fabs</span>(r - l) &lt; <span class=\"number\">1e-6</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; (<span class=\"type\">int</span>) (ans * <span class=\"number\">1000</span>) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Generating Function","date":"2023-04-29T16:00:00.000Z","math":true,"_content":"\n生成函数入门\n\n先来看这道题 [HDU2082](http://acm.hdu.edu.cn/showproblem.php?pid=2082)。\n\n有 $26$ 种字母，第 $i$ 个字母权值为 $i$，有 $a_i$ 个。问有多少种方案可以构造出总价值介于 $[1,50]$ 的字母集合。\n\n显然这题是可以 dp 的，但是我们换一种视角来看这个问题。\n\n对于第 $k$ 个字母，我们最少一个都不选，最多选 $a_k$ 个。于是构造这样一个多项式：\n\n$$\n1+x^{k}+x^{2k}+\\cdots +x^{a_k \\cdot k}\n$$\n\n这里我们并不关心多项式的值，只是采用这个形式，用每一项的指数来表示权值，用系数表示方案的数量。\n\n那么所有选择的方案，就是将这些多项式乘起来，即\n\n$$\n\\prod_{i=1}^{26}\\sum_{j=0}^{a_i}x^{ij}\n$$\n\n只需统计 $x^1,x^2,\\cdots,x^{50}$ 的系数之和，就是所求的答案了。\n\n``` cpp\n#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::string;\nusing ll = long long;\nusing uint = unsigned int;\nusing ull = unsigned long long;\nusing pii = std::pair<int, int>;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 3e5 + 5;\n\nvoid solve() {\n    vector<ll> a(60);\n    a[0] = 1;\n    for (int i = 1; i <= 26; ++i) {\n        int x;\n        cin >> x;\n        if (x == 0) continue;\n        vector<ll> b(60);\n        for (int j = 0; j <= 50; ++j) {\n            for (int k = 0; k <= x; ++k) {\n                if (i * k + j > 50) \n                    break;\n                b[i * k + j] += a[j];\n            }\n        }\n        a = b;\n    }\n    ll ans = std::accumulate(a.begin() + 1, a.begin() + 50 + 1, 0LL);\n    cout << ans << endl;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T = 1;\n    cin >> T;\n    for (int t = 1; t <= T; ++t) {\n        solve();\n    }\n    return 0;\n}\n```\n\n使用同样的做法可以解决 [HDU1028](https://acm.hdu.edu.cn/showproblem.php?pid=1028)，把一个整数划分为若干个整数之和，不考虑顺序，求所有方案的数量。复杂度 $O(n^2\\log n)$。\n\n``` cpp\nvoid solve(int n) {\n    vector<ll> a(n + 1);\n    a[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        vector<ll> b(n + 1);\n        int m = n / i;\n        for (int j = 0; j <= n; ++j) {\n            for (int k = 0; k <= m; ++k) {\n                if (i * k + j > n)\n                    break;\n                b[i * k + j] += a[j];\n            }\n        }\n        a = b;\n    }\n    cout << a[n] << '\\n';\n}\n```\n\n以上就是生成函数最简单的应用。由于每个多项式中的自变量 $x$ 并没有什么意义，这种多项式也称为形式幂级数。\n\n上面的形如 $\\sum a_ix^i$ 的生成函数称为普通生成函数，可以解决组合问题。\n\n另一类生成函数可以解决排列问题。\n\n\n","source":"_posts/gf_0.md","raw":"---\ntitle: Generating Function\ndate: 2023-04-30\ntag: [GF]\ncategory: [Math]\nmath: true\n---\n\n生成函数入门\n\n先来看这道题 [HDU2082](http://acm.hdu.edu.cn/showproblem.php?pid=2082)。\n\n有 $26$ 种字母，第 $i$ 个字母权值为 $i$，有 $a_i$ 个。问有多少种方案可以构造出总价值介于 $[1,50]$ 的字母集合。\n\n显然这题是可以 dp 的，但是我们换一种视角来看这个问题。\n\n对于第 $k$ 个字母，我们最少一个都不选，最多选 $a_k$ 个。于是构造这样一个多项式：\n\n$$\n1+x^{k}+x^{2k}+\\cdots +x^{a_k \\cdot k}\n$$\n\n这里我们并不关心多项式的值，只是采用这个形式，用每一项的指数来表示权值，用系数表示方案的数量。\n\n那么所有选择的方案，就是将这些多项式乘起来，即\n\n$$\n\\prod_{i=1}^{26}\\sum_{j=0}^{a_i}x^{ij}\n$$\n\n只需统计 $x^1,x^2,\\cdots,x^{50}$ 的系数之和，就是所求的答案了。\n\n``` cpp\n#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::string;\nusing ll = long long;\nusing uint = unsigned int;\nusing ull = unsigned long long;\nusing pii = std::pair<int, int>;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 3e5 + 5;\n\nvoid solve() {\n    vector<ll> a(60);\n    a[0] = 1;\n    for (int i = 1; i <= 26; ++i) {\n        int x;\n        cin >> x;\n        if (x == 0) continue;\n        vector<ll> b(60);\n        for (int j = 0; j <= 50; ++j) {\n            for (int k = 0; k <= x; ++k) {\n                if (i * k + j > 50) \n                    break;\n                b[i * k + j] += a[j];\n            }\n        }\n        a = b;\n    }\n    ll ans = std::accumulate(a.begin() + 1, a.begin() + 50 + 1, 0LL);\n    cout << ans << endl;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T = 1;\n    cin >> T;\n    for (int t = 1; t <= T; ++t) {\n        solve();\n    }\n    return 0;\n}\n```\n\n使用同样的做法可以解决 [HDU1028](https://acm.hdu.edu.cn/showproblem.php?pid=1028)，把一个整数划分为若干个整数之和，不考虑顺序，求所有方案的数量。复杂度 $O(n^2\\log n)$。\n\n``` cpp\nvoid solve(int n) {\n    vector<ll> a(n + 1);\n    a[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        vector<ll> b(n + 1);\n        int m = n / i;\n        for (int j = 0; j <= n; ++j) {\n            for (int k = 0; k <= m; ++k) {\n                if (i * k + j > n)\n                    break;\n                b[i * k + j] += a[j];\n            }\n        }\n        a = b;\n    }\n    cout << a[n] << '\\n';\n}\n```\n\n以上就是生成函数最简单的应用。由于每个多项式中的自变量 $x$ 并没有什么意义，这种多项式也称为形式幂级数。\n\n上面的形如 $\\sum a_ix^i$ 的生成函数称为普通生成函数，可以解决组合问题。\n\n另一类生成函数可以解决排列问题。\n\n\n","slug":"gf_0","published":1,"updated":"2023-04-30T09:08:58.927Z","comments":1,"layout":"post","photos":[],"_id":"cmir5cbxb000v2clefrpl4tbr","content":"<p>生成函数入门</p>\n<p>先来看这道题 <a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2082\">HDU2082</a>。</p>\n<p>有 $26$ 种字母，第 $i$ 个字母权值为 $i$，有 $a_i$ 个。问有多少种方案可以构造出总价值介于 $[1,50]$ 的字母集合。</p>\n<p>显然这题是可以 dp 的，但是我们换一种视角来看这个问题。</p>\n<p>对于第 $k$ 个字母，我们最少一个都不选，最多选 $a_k$ 个。于是构造这样一个多项式：</p>\n<p>$$<br>1+x^{k}+x^{2k}+\\cdots +x^{a_k \\cdot k}<br>$$</p>\n<p>这里我们并不关心多项式的值，只是采用这个形式，用每一项的指数来表示权值，用系数表示方案的数量。</p>\n<p>那么所有选择的方案，就是将这些多项式乘起来，即</p>\n<p>$$<br>\\prod_{i&#x3D;1}^{26}\\sum_{j&#x3D;0}^{a_i}x^{ij}<br>$$</p>\n<p>只需统计 $x^1,x^2,\\cdots,x^{50}$ 的系数之和，就是所求的答案了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cin;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cout;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::endl;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::vector;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::string;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> uint = <span class=\"type\">unsigned</span> <span class=\"type\">int</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ull = <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> pii = std::pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> inf = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">3e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">60</span>)</span></span>;</span><br><span class=\"line\">    a[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">26</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x;</span><br><span class=\"line\">        cin &gt;&gt; x;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">60</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= <span class=\"number\">50</span>; ++j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt;= x; ++k) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i * k + j &gt; <span class=\"number\">50</span>) </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                b[i * k + j] += a[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a = b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll ans = std::<span class=\"built_in\">accumulate</span>(a.<span class=\"built_in\">begin</span>() + <span class=\"number\">1</span>, a.<span class=\"built_in\">begin</span>() + <span class=\"number\">50</span> + <span class=\"number\">1</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> t = <span class=\"number\">1</span>; t &lt;= T; ++t) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用同样的做法可以解决 <a href=\"https://acm.hdu.edu.cn/showproblem.php?pid=1028\">HDU1028</a>，把一个整数划分为若干个整数之和，不考虑顺序，求所有方案的数量。复杂度 $O(n^2\\log n)$。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">a</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    a[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">b</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = n / i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= n; ++j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt;= m; ++k) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i * k + j &gt; n)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                b[i * k + j] += a[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a = b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; a[n] &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是生成函数最简单的应用。由于每个多项式中的自变量 $x$ 并没有什么意义，这种多项式也称为形式幂级数。</p>\n<p>上面的形如 $\\sum a_ix^i$ 的生成函数称为普通生成函数，可以解决组合问题。</p>\n<p>另一类生成函数可以解决排列问题。</p>\n","excerpt":"","more":"<p>生成函数入门</p>\n<p>先来看这道题 <a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2082\">HDU2082</a>。</p>\n<p>有 $26$ 种字母，第 $i$ 个字母权值为 $i$，有 $a_i$ 个。问有多少种方案可以构造出总价值介于 $[1,50]$ 的字母集合。</p>\n<p>显然这题是可以 dp 的，但是我们换一种视角来看这个问题。</p>\n<p>对于第 $k$ 个字母，我们最少一个都不选，最多选 $a_k$ 个。于是构造这样一个多项式：</p>\n<p>$$<br>1+x^{k}+x^{2k}+\\cdots +x^{a_k \\cdot k}<br>$$</p>\n<p>这里我们并不关心多项式的值，只是采用这个形式，用每一项的指数来表示权值，用系数表示方案的数量。</p>\n<p>那么所有选择的方案，就是将这些多项式乘起来，即</p>\n<p>$$<br>\\prod_{i&#x3D;1}^{26}\\sum_{j&#x3D;0}^{a_i}x^{ij}<br>$$</p>\n<p>只需统计 $x^1,x^2,\\cdots,x^{50}$ 的系数之和，就是所求的答案了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cin;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::cout;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::endl;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::vector;</span><br><span class=\"line\"><span class=\"keyword\">using</span> std::string;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> uint = <span class=\"type\">unsigned</span> <span class=\"type\">int</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ull = <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> pii = std::pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> inf = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn = <span class=\"number\">3e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">60</span>)</span></span>;</span><br><span class=\"line\">    a[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">26</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x;</span><br><span class=\"line\">        cin &gt;&gt; x;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">60</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= <span class=\"number\">50</span>; ++j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt;= x; ++k) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i * k + j &gt; <span class=\"number\">50</span>) </span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                b[i * k + j] += a[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a = b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll ans = std::<span class=\"built_in\">accumulate</span>(a.<span class=\"built_in\">begin</span>() + <span class=\"number\">1</span>, a.<span class=\"built_in\">begin</span>() + <span class=\"number\">50</span> + <span class=\"number\">1</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> T = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> t = <span class=\"number\">1</span>; t &lt;= T; ++t) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用同样的做法可以解决 <a href=\"https://acm.hdu.edu.cn/showproblem.php?pid=1028\">HDU1028</a>，把一个整数划分为若干个整数之和，不考虑顺序，求所有方案的数量。复杂度 $O(n^2\\log n)$。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">a</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    a[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">b</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = n / i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= n; ++j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt;= m; ++k) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i * k + j &gt; n)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                b[i * k + j] += a[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a = b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; a[n] &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是生成函数最简单的应用。由于每个多项式中的自变量 $x$ 并没有什么意义，这种多项式也称为形式幂级数。</p>\n<p>上面的形如 $\\sum a_ix^i$ 的生成函数称为普通生成函数，可以解决组合问题。</p>\n<p>另一类生成函数可以解决排列问题。</p>\n"},{"title":"Configuration of Ubuntu","date":"2021-05-08T16:00:00.000Z","math":true,"_content":"\nUbuntu 配置\n\n<!--more-->\n\n# 准备工作\n\n首先装好系统，记得在**软件和更新**里换源。\n\n然后装 Chrome，搜狗拼音输入法，Clash，都照着教程来就好了。\n\n这三个是一定要先装好的。\n\n# 个性化\n\n先安装 Gnome-Tweak-Tool：\n\n``` shell\nsudo apt-get update\nsudo apt-get install gnome-tweak-tool\n```\n\n然后打开，可以在桌面一栏选择是否显示图标，在窗口一栏选择按钮位置等。我还是习惯默认的设置。\n\n这时外观栏中的 Shell 应该是灰色的，需要先装一个扩展：\n\n``` shell\nsudo apt-get install gnome-shell-extensions\n```\n\n然后重新打开，在扩展栏中打开 User themes 按钮。\n\n理论上 Shell 那边已经好了，但我实际操作中还是灰色的。这时需要再装一个浏览器扩展：\n\n```shell\nsudo apt install chrome-gnome-shell\n```\n\n然后 Chrome 打开 [这个网址](https://extensions.gnome.org/extension/19/user-themes/)，启用插件。再重新开一遍 Gnome-Tweak-Tool 就好了。\n\n接下来就可以装主题了。\n\n我这次装的是 [这个](https://www.opendesktop.org/s/Gnome/p/1241688)，进去在 File 标签下面下载压缩文件，通过以下两个命令解压：\n\n``` shell\nxz -d filename.tar.xz\ntar xvf filename.tar\n```\n\n就会获得一个文件夹。在下载文件夹中打开终端，`sudo mv filename /usr/share/themes` 就好了。\n\n现在打开 Tweaks 就可以选择刚才装好的主题。\n\n图标的修改方法类似，[网址](https://www.opendesktop.org/s/Gnome/p/1102582/)，解压后放到 `/usr/share/icons` 里面。\n\n修改 Shell：[网址](https://www.opendesktop.org/s/Gnome/p/1013741/)，解压后放到 `/usr/share/themes` 里面。\n\n再去 Ubuntu 软件里安装 Dash to Dock 和 Coverflow Alt-Tab，在扩展里打开相应的开关，自定义设置即可。\n\n[更深入的美化教程](https://www.cnblogs.com/feipeng8848/p/8970556.html)\n\n# 软件安装\n\n# 小工具\n\n### caffeine\n\n阻止休眠的小插件，非常好用\n\n```shell\nsudo add-apt-repository ppa:eugenesan/ppa\nsudo apt-get update\nsudo apt-get install caffeine -y\n```\n\n### copyq\n\n评价很好的剪贴板管理软件\n\n```shell\nsudo add-apt-repository ppa:hluk/copyq \nsudo apt-get update\nsudo apt-get install copyq\n```\n\n### neofetch\n\n看系统状态\n\n```shell\nsudo add-apt-repository ppa:dawidd0811/neofetch \nsudo apt-get update \nsudo apt-get install neofetch\n```\n\n装完执行 `neofetch` 命令可以看到很多东西。当然还有更高级的用法。\n\n### shutter\n\n截图软件\n\n```shell\nsudo apt-get install shutter\n```\n\n应该可以设置快捷键，懒得搞了。\n\n### simplescreenrecorder\n\n录屏软件\n\n```shell\nsudo apt-get install simplescreenrecorder\n```\n\n### VLC\n\n播放器，先要装一个 snap\n\n```shell\nsudo apt install snapd\nsudo snap install vlc\n```\n\n### filezilla\n\nFTP 客户端\n\n```shell\nsudo apt-get install filezilla\n# sudo apt-get install filezilla-locales\n```\n\n## Git\n\n```shell\nsudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install git\n```\n\n## typora\n\n打开 [官网](https://www.typora.io/) 照教程来就行了。\n\n## vscode\n\n去官网直接下载会非常慢并且很容易失败，找到下载链接后将网址：\n\n```\nhttps://az764295.vo.msecnd.net/stable/cfa2e218100323074ac1948c885448fdf4de2a7f/code_1.56.0-1620166262_amd64.deb\n```\n\n改成这样：\n\n```\nhttp://vscode.cdn.azure.cn/stable/cfa2e218100323074ac1948c885448fdf4de2a7f/code_1.56.0-1620166262_amd64.deb\n```\n\n就解决了。\n\n**插件**：\n\n- Chinese\n- One Dark Pro\n- C/C++\n- C++ Intellisense\n- Code Runner 记得开 run in terminal\n- Bracket Pair Colorizer 2 \n- Python\n- TabOut\n\n最主要的就这些。字体装一下 JetBrains Mono，大小 20\n\n```\n'JetBrains Mono', 'monospace', monospace, 'JetBrains Mono'\n```\n\n## shell\n\nzsh、fish 之类的都很不错，等以后学会了再写。\n\n# 环境配置\n\n## C/C++\n\n先看看有没有：\n\n```shell\ngcc --version\ng++ --version\n```\n\n很遗憾，并没有：\n\n```shell\nsudo apt-get install gcc\nsudo apt-get install g++\n```\n\n现在装的两个都是 7.5.0 版本的。\n\n## Python\n\npython3 已经有了，没有的话 `sudo apt install python3`。\n\n## LaTex\n\n有空再装。","source":"_posts/ubuntu_config.md","raw":"---\ntitle: Configuration of Ubuntu\ndate: 2021-05-09\ntag: [ubuntu]\ncategory: [Tutorial]\nmath: true\n---\n\nUbuntu 配置\n\n<!--more-->\n\n# 准备工作\n\n首先装好系统，记得在**软件和更新**里换源。\n\n然后装 Chrome，搜狗拼音输入法，Clash，都照着教程来就好了。\n\n这三个是一定要先装好的。\n\n# 个性化\n\n先安装 Gnome-Tweak-Tool：\n\n``` shell\nsudo apt-get update\nsudo apt-get install gnome-tweak-tool\n```\n\n然后打开，可以在桌面一栏选择是否显示图标，在窗口一栏选择按钮位置等。我还是习惯默认的设置。\n\n这时外观栏中的 Shell 应该是灰色的，需要先装一个扩展：\n\n``` shell\nsudo apt-get install gnome-shell-extensions\n```\n\n然后重新打开，在扩展栏中打开 User themes 按钮。\n\n理论上 Shell 那边已经好了，但我实际操作中还是灰色的。这时需要再装一个浏览器扩展：\n\n```shell\nsudo apt install chrome-gnome-shell\n```\n\n然后 Chrome 打开 [这个网址](https://extensions.gnome.org/extension/19/user-themes/)，启用插件。再重新开一遍 Gnome-Tweak-Tool 就好了。\n\n接下来就可以装主题了。\n\n我这次装的是 [这个](https://www.opendesktop.org/s/Gnome/p/1241688)，进去在 File 标签下面下载压缩文件，通过以下两个命令解压：\n\n``` shell\nxz -d filename.tar.xz\ntar xvf filename.tar\n```\n\n就会获得一个文件夹。在下载文件夹中打开终端，`sudo mv filename /usr/share/themes` 就好了。\n\n现在打开 Tweaks 就可以选择刚才装好的主题。\n\n图标的修改方法类似，[网址](https://www.opendesktop.org/s/Gnome/p/1102582/)，解压后放到 `/usr/share/icons` 里面。\n\n修改 Shell：[网址](https://www.opendesktop.org/s/Gnome/p/1013741/)，解压后放到 `/usr/share/themes` 里面。\n\n再去 Ubuntu 软件里安装 Dash to Dock 和 Coverflow Alt-Tab，在扩展里打开相应的开关，自定义设置即可。\n\n[更深入的美化教程](https://www.cnblogs.com/feipeng8848/p/8970556.html)\n\n# 软件安装\n\n# 小工具\n\n### caffeine\n\n阻止休眠的小插件，非常好用\n\n```shell\nsudo add-apt-repository ppa:eugenesan/ppa\nsudo apt-get update\nsudo apt-get install caffeine -y\n```\n\n### copyq\n\n评价很好的剪贴板管理软件\n\n```shell\nsudo add-apt-repository ppa:hluk/copyq \nsudo apt-get update\nsudo apt-get install copyq\n```\n\n### neofetch\n\n看系统状态\n\n```shell\nsudo add-apt-repository ppa:dawidd0811/neofetch \nsudo apt-get update \nsudo apt-get install neofetch\n```\n\n装完执行 `neofetch` 命令可以看到很多东西。当然还有更高级的用法。\n\n### shutter\n\n截图软件\n\n```shell\nsudo apt-get install shutter\n```\n\n应该可以设置快捷键，懒得搞了。\n\n### simplescreenrecorder\n\n录屏软件\n\n```shell\nsudo apt-get install simplescreenrecorder\n```\n\n### VLC\n\n播放器，先要装一个 snap\n\n```shell\nsudo apt install snapd\nsudo snap install vlc\n```\n\n### filezilla\n\nFTP 客户端\n\n```shell\nsudo apt-get install filezilla\n# sudo apt-get install filezilla-locales\n```\n\n## Git\n\n```shell\nsudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install git\n```\n\n## typora\n\n打开 [官网](https://www.typora.io/) 照教程来就行了。\n\n## vscode\n\n去官网直接下载会非常慢并且很容易失败，找到下载链接后将网址：\n\n```\nhttps://az764295.vo.msecnd.net/stable/cfa2e218100323074ac1948c885448fdf4de2a7f/code_1.56.0-1620166262_amd64.deb\n```\n\n改成这样：\n\n```\nhttp://vscode.cdn.azure.cn/stable/cfa2e218100323074ac1948c885448fdf4de2a7f/code_1.56.0-1620166262_amd64.deb\n```\n\n就解决了。\n\n**插件**：\n\n- Chinese\n- One Dark Pro\n- C/C++\n- C++ Intellisense\n- Code Runner 记得开 run in terminal\n- Bracket Pair Colorizer 2 \n- Python\n- TabOut\n\n最主要的就这些。字体装一下 JetBrains Mono，大小 20\n\n```\n'JetBrains Mono', 'monospace', monospace, 'JetBrains Mono'\n```\n\n## shell\n\nzsh、fish 之类的都很不错，等以后学会了再写。\n\n# 环境配置\n\n## C/C++\n\n先看看有没有：\n\n```shell\ngcc --version\ng++ --version\n```\n\n很遗憾，并没有：\n\n```shell\nsudo apt-get install gcc\nsudo apt-get install g++\n```\n\n现在装的两个都是 7.5.0 版本的。\n\n## Python\n\npython3 已经有了，没有的话 `sudo apt install python3`。\n\n## LaTex\n\n有空再装。","slug":"ubuntu_config","published":1,"updated":"2023-02-25T05:46:11.840Z","comments":1,"layout":"post","photos":[],"_id":"cmir5cbxc000y2cle5l5t5bsu","content":"<p>Ubuntu 配置</p>\n<span id=\"more\"></span>\n\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>首先装好系统，记得在<strong>软件和更新</strong>里换源。</p>\n<p>然后装 Chrome，搜狗拼音输入法，Clash，都照着教程来就好了。</p>\n<p>这三个是一定要先装好的。</p>\n<h1 id=\"个性化\"><a href=\"#个性化\" class=\"headerlink\" title=\"个性化\"></a>个性化</h1><p>先安装 Gnome-Tweak-Tool：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install gnome-tweak-tool</span><br></pre></td></tr></table></figure>\n\n<p>然后打开，可以在桌面一栏选择是否显示图标，在窗口一栏选择按钮位置等。我还是习惯默认的设置。</p>\n<p>这时外观栏中的 Shell 应该是灰色的，需要先装一个扩展：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gnome-shell-extensions</span><br></pre></td></tr></table></figure>\n\n<p>然后重新打开，在扩展栏中打开 User themes 按钮。</p>\n<p>理论上 Shell 那边已经好了，但我实际操作中还是灰色的。这时需要再装一个浏览器扩展：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install chrome-gnome-shell</span><br></pre></td></tr></table></figure>\n\n<p>然后 Chrome 打开 <a href=\"https://extensions.gnome.org/extension/19/user-themes/\">这个网址</a>，启用插件。再重新开一遍 Gnome-Tweak-Tool 就好了。</p>\n<p>接下来就可以装主题了。</p>\n<p>我这次装的是 <a href=\"https://www.opendesktop.org/s/Gnome/p/1241688\">这个</a>，进去在 File 标签下面下载压缩文件，通过以下两个命令解压：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xz -d filename.tar.xz</span><br><span class=\"line\">tar xvf filename.tar</span><br></pre></td></tr></table></figure>\n\n<p>就会获得一个文件夹。在下载文件夹中打开终端，<code>sudo mv filename /usr/share/themes</code> 就好了。</p>\n<p>现在打开 Tweaks 就可以选择刚才装好的主题。</p>\n<p>图标的修改方法类似，<a href=\"https://www.opendesktop.org/s/Gnome/p/1102582/\">网址</a>，解压后放到 <code>/usr/share/icons</code> 里面。</p>\n<p>修改 Shell：<a href=\"https://www.opendesktop.org/s/Gnome/p/1013741/\">网址</a>，解压后放到 <code>/usr/share/themes</code> 里面。</p>\n<p>再去 Ubuntu 软件里安装 Dash to Dock 和 Coverflow Alt-Tab，在扩展里打开相应的开关，自定义设置即可。</p>\n<p><a href=\"https://www.cnblogs.com/feipeng8848/p/8970556.html\">更深入的美化教程</a></p>\n<h1 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h1><h1 id=\"小工具\"><a href=\"#小工具\" class=\"headerlink\" title=\"小工具\"></a>小工具</h1><h3 id=\"caffeine\"><a href=\"#caffeine\" class=\"headerlink\" title=\"caffeine\"></a>caffeine</h3><p>阻止休眠的小插件，非常好用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:eugenesan/ppa</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install caffeine -y</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"copyq\"><a href=\"#copyq\" class=\"headerlink\" title=\"copyq\"></a>copyq</h3><p>评价很好的剪贴板管理软件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:hluk/copyq </span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install copyq</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"neofetch\"><a href=\"#neofetch\" class=\"headerlink\" title=\"neofetch\"></a>neofetch</h3><p>看系统状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:dawidd0811/neofetch </span><br><span class=\"line\">sudo apt-get update </span><br><span class=\"line\">sudo apt-get install neofetch</span><br></pre></td></tr></table></figure>\n\n<p>装完执行 <code>neofetch</code> 命令可以看到很多东西。当然还有更高级的用法。</p>\n<h3 id=\"shutter\"><a href=\"#shutter\" class=\"headerlink\" title=\"shutter\"></a>shutter</h3><p>截图软件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install shutter</span><br></pre></td></tr></table></figure>\n\n<p>应该可以设置快捷键，懒得搞了。</p>\n<h3 id=\"simplescreenrecorder\"><a href=\"#simplescreenrecorder\" class=\"headerlink\" title=\"simplescreenrecorder\"></a>simplescreenrecorder</h3><p>录屏软件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install simplescreenrecorder</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"VLC\"><a href=\"#VLC\" class=\"headerlink\" title=\"VLC\"></a>VLC</h3><p>播放器，先要装一个 snap</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install snapd</span><br><span class=\"line\">sudo snap install vlc</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"filezilla\"><a href=\"#filezilla\" class=\"headerlink\" title=\"filezilla\"></a>filezilla</h3><p>FTP 客户端</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install filezilla</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"built_in\">sudo</span> apt-get install filezilla-locales</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade</span><br><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"typora\"><a href=\"#typora\" class=\"headerlink\" title=\"typora\"></a>typora</h2><p>打开 <a href=\"https://www.typora.io/\">官网</a> 照教程来就行了。</p>\n<h2 id=\"vscode\"><a href=\"#vscode\" class=\"headerlink\" title=\"vscode\"></a>vscode</h2><p>去官网直接下载会非常慢并且很容易失败，找到下载链接后将网址：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://az764295.vo.msecnd.net/stable/cfa2e218100323074ac1948c885448fdf4de2a7f/code_1.56.0-1620166262_amd64.deb</span><br></pre></td></tr></table></figure>\n\n<p>改成这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://vscode.cdn.azure.cn/stable/cfa2e218100323074ac1948c885448fdf4de2a7f/code_1.56.0-1620166262_amd64.deb</span><br></pre></td></tr></table></figure>\n\n<p>就解决了。</p>\n<p><strong>插件</strong>：</p>\n<ul>\n<li>Chinese</li>\n<li>One Dark Pro</li>\n<li>C&#x2F;C++</li>\n<li>C++ Intellisense</li>\n<li>Code Runner 记得开 run in terminal</li>\n<li>Bracket Pair Colorizer 2 </li>\n<li>Python</li>\n<li>TabOut</li>\n</ul>\n<p>最主要的就这些。字体装一下 JetBrains Mono，大小 20</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x27;JetBrains Mono&#x27;, &#x27;monospace&#x27;, monospace, &#x27;JetBrains Mono&#x27;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"shell\"><a href=\"#shell\" class=\"headerlink\" title=\"shell\"></a>shell</h2><p>zsh、fish 之类的都很不错，等以后学会了再写。</p>\n<h1 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h1><h2 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C&#x2F;C++\"></a>C&#x2F;C++</h2><p>先看看有没有：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc --version</span><br><span class=\"line\">g++ --version</span><br></pre></td></tr></table></figure>\n\n<p>很遗憾，并没有：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gcc</span><br><span class=\"line\">sudo apt-get install g++</span><br></pre></td></tr></table></figure>\n\n<p>现在装的两个都是 7.5.0 版本的。</p>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><p>python3 已经有了，没有的话 <code>sudo apt install python3</code>。</p>\n<h2 id=\"LaTex\"><a href=\"#LaTex\" class=\"headerlink\" title=\"LaTex\"></a>LaTex</h2><p>有空再装。</p>\n","excerpt":"<p>Ubuntu 配置</p>","more":"<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>首先装好系统，记得在<strong>软件和更新</strong>里换源。</p>\n<p>然后装 Chrome，搜狗拼音输入法，Clash，都照着教程来就好了。</p>\n<p>这三个是一定要先装好的。</p>\n<h1 id=\"个性化\"><a href=\"#个性化\" class=\"headerlink\" title=\"个性化\"></a>个性化</h1><p>先安装 Gnome-Tweak-Tool：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install gnome-tweak-tool</span><br></pre></td></tr></table></figure>\n\n<p>然后打开，可以在桌面一栏选择是否显示图标，在窗口一栏选择按钮位置等。我还是习惯默认的设置。</p>\n<p>这时外观栏中的 Shell 应该是灰色的，需要先装一个扩展：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gnome-shell-extensions</span><br></pre></td></tr></table></figure>\n\n<p>然后重新打开，在扩展栏中打开 User themes 按钮。</p>\n<p>理论上 Shell 那边已经好了，但我实际操作中还是灰色的。这时需要再装一个浏览器扩展：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install chrome-gnome-shell</span><br></pre></td></tr></table></figure>\n\n<p>然后 Chrome 打开 <a href=\"https://extensions.gnome.org/extension/19/user-themes/\">这个网址</a>，启用插件。再重新开一遍 Gnome-Tweak-Tool 就好了。</p>\n<p>接下来就可以装主题了。</p>\n<p>我这次装的是 <a href=\"https://www.opendesktop.org/s/Gnome/p/1241688\">这个</a>，进去在 File 标签下面下载压缩文件，通过以下两个命令解压：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xz -d filename.tar.xz</span><br><span class=\"line\">tar xvf filename.tar</span><br></pre></td></tr></table></figure>\n\n<p>就会获得一个文件夹。在下载文件夹中打开终端，<code>sudo mv filename /usr/share/themes</code> 就好了。</p>\n<p>现在打开 Tweaks 就可以选择刚才装好的主题。</p>\n<p>图标的修改方法类似，<a href=\"https://www.opendesktop.org/s/Gnome/p/1102582/\">网址</a>，解压后放到 <code>/usr/share/icons</code> 里面。</p>\n<p>修改 Shell：<a href=\"https://www.opendesktop.org/s/Gnome/p/1013741/\">网址</a>，解压后放到 <code>/usr/share/themes</code> 里面。</p>\n<p>再去 Ubuntu 软件里安装 Dash to Dock 和 Coverflow Alt-Tab，在扩展里打开相应的开关，自定义设置即可。</p>\n<p><a href=\"https://www.cnblogs.com/feipeng8848/p/8970556.html\">更深入的美化教程</a></p>\n<h1 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h1><h1 id=\"小工具\"><a href=\"#小工具\" class=\"headerlink\" title=\"小工具\"></a>小工具</h1><h3 id=\"caffeine\"><a href=\"#caffeine\" class=\"headerlink\" title=\"caffeine\"></a>caffeine</h3><p>阻止休眠的小插件，非常好用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:eugenesan/ppa</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install caffeine -y</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"copyq\"><a href=\"#copyq\" class=\"headerlink\" title=\"copyq\"></a>copyq</h3><p>评价很好的剪贴板管理软件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:hluk/copyq </span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install copyq</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"neofetch\"><a href=\"#neofetch\" class=\"headerlink\" title=\"neofetch\"></a>neofetch</h3><p>看系统状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:dawidd0811/neofetch </span><br><span class=\"line\">sudo apt-get update </span><br><span class=\"line\">sudo apt-get install neofetch</span><br></pre></td></tr></table></figure>\n\n<p>装完执行 <code>neofetch</code> 命令可以看到很多东西。当然还有更高级的用法。</p>\n<h3 id=\"shutter\"><a href=\"#shutter\" class=\"headerlink\" title=\"shutter\"></a>shutter</h3><p>截图软件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install shutter</span><br></pre></td></tr></table></figure>\n\n<p>应该可以设置快捷键，懒得搞了。</p>\n<h3 id=\"simplescreenrecorder\"><a href=\"#simplescreenrecorder\" class=\"headerlink\" title=\"simplescreenrecorder\"></a>simplescreenrecorder</h3><p>录屏软件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install simplescreenrecorder</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"VLC\"><a href=\"#VLC\" class=\"headerlink\" title=\"VLC\"></a>VLC</h3><p>播放器，先要装一个 snap</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install snapd</span><br><span class=\"line\">sudo snap install vlc</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"filezilla\"><a href=\"#filezilla\" class=\"headerlink\" title=\"filezilla\"></a>filezilla</h3><p>FTP 客户端</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install filezilla</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"built_in\">sudo</span> apt-get install filezilla-locales</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade</span><br><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"typora\"><a href=\"#typora\" class=\"headerlink\" title=\"typora\"></a>typora</h2><p>打开 <a href=\"https://www.typora.io/\">官网</a> 照教程来就行了。</p>\n<h2 id=\"vscode\"><a href=\"#vscode\" class=\"headerlink\" title=\"vscode\"></a>vscode</h2><p>去官网直接下载会非常慢并且很容易失败，找到下载链接后将网址：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://az764295.vo.msecnd.net/stable/cfa2e218100323074ac1948c885448fdf4de2a7f/code_1.56.0-1620166262_amd64.deb</span><br></pre></td></tr></table></figure>\n\n<p>改成这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://vscode.cdn.azure.cn/stable/cfa2e218100323074ac1948c885448fdf4de2a7f/code_1.56.0-1620166262_amd64.deb</span><br></pre></td></tr></table></figure>\n\n<p>就解决了。</p>\n<p><strong>插件</strong>：</p>\n<ul>\n<li>Chinese</li>\n<li>One Dark Pro</li>\n<li>C&#x2F;C++</li>\n<li>C++ Intellisense</li>\n<li>Code Runner 记得开 run in terminal</li>\n<li>Bracket Pair Colorizer 2 </li>\n<li>Python</li>\n<li>TabOut</li>\n</ul>\n<p>最主要的就这些。字体装一下 JetBrains Mono，大小 20</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x27;JetBrains Mono&#x27;, &#x27;monospace&#x27;, monospace, &#x27;JetBrains Mono&#x27;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"shell\"><a href=\"#shell\" class=\"headerlink\" title=\"shell\"></a>shell</h2><p>zsh、fish 之类的都很不错，等以后学会了再写。</p>\n<h1 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h1><h2 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C&#x2F;C++\"></a>C&#x2F;C++</h2><p>先看看有没有：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc --version</span><br><span class=\"line\">g++ --version</span><br></pre></td></tr></table></figure>\n\n<p>很遗憾，并没有：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gcc</span><br><span class=\"line\">sudo apt-get install g++</span><br></pre></td></tr></table></figure>\n\n<p>现在装的两个都是 7.5.0 版本的。</p>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><p>python3 已经有了，没有的话 <code>sudo apt install python3</code>。</p>\n<h2 id=\"LaTex\"><a href=\"#LaTex\" class=\"headerlink\" title=\"LaTex\"></a>LaTex</h2><p>有空再装。</p>"},{"title":"博客维护指南","date":"2018-01-04T16:00:00.000Z","updated":"2018-01-04T16:00:00.000Z","excerpt":"全部由GPT生成","keywords":null,"description":"这是description","top_img":null,"cover":null,"toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"_content":"\n\n\n\n这是手动实现的摘要！\n\n<!--more-->\n\n\n我把 **最正确、最稳、不踩坑的双机维护方法** 给你整理一下，让你在两台电脑上随时写作、同步、预览、部署都没有问题。\n\n---\n\n# ✅ 总体结构\n\n你的博客现在结构如下：\n\n* **仓库 A：hexo-blog**\n  👉 存放 Hexo 源码、主题配置、文章等\n  👉 包含 `themes/butterfly` 的 Git submodule\n\n* **仓库 B：phlzy.github.io**\n  👉 GitHub Actions 自动部署结果（静态文件），无需手动维护\n\n你只需要在两台电脑上维护 **hexo-blog** 即可。\n\n---\n\n# 🧱 🔧 两台电脑如何初始化 hexo-blog（含 submodule）？\n\n## ① 克隆 hexo-blog 仓库（重点：带 submodule）\n\n不要直接 clone，需要加参数：\n\n```bash\ngit clone --recursive https://github.com/phlzy/hexo-blog.git\ncd hexo-blog\n```\n\n如果你忘记加 `--recursive`，也没关系，用下面的补救命令：\n\n```bash\ngit submodule update --init --recursive\n```\n\n这一步会把 Butterfly 主题的文件完整拉下来。\n\n---\n\n# 🧱 🔧 ② 安装依赖（两台电脑都需要执行一次）\n\n```bash\nnpm install\n```\n\nHexo、主题所需 renderer 插件都会自动安装。\n\n---\n\n# 🧱 🔧 ③ 本地预览\n\n```bash\nhexo clean\nhexo g\nhexo s\n```\n\n访问：\n\n```\nhttp://localhost:4000/\n```\n\n---\n\n# 🚀 双机写作同步流程（每天都用到）\n\n## ⭐ 在任意电脑开始工作前必须做：\n\n```bash\ngit pull --recurse-submodules\n```\n\n（`--recurse-submodules` 确保主题也同步）\n\n⚠ 如果你不写这个参数，有时候 submodule 不会自动更新。\n\n---\n\n## ⭐ 写完文章后推送：\n\n```bash\ngit add .\ngit commit -m \"Add new post\"\ngit push\n```\n\nGitHub Actions 会自动部署到 `phlzy.github.io`\n\n---\n\n# 🧠 如何确认 submodule 状态正常？\n\n每次切换电脑后，可以检查 submodule 指向的 commit 是否正确：\n\n```bash\ngit submodule status\n```\n\n如果正确，会显示主题仓库的 commit hash。\n\n---\n\n# 🧱 💡 你要特别注意的 **submodule 不要直接修改主题文件**！\n\n如果你编辑了 `themes/butterfly` 里的文件（例如 CSS、布局），Git 会认为：\n\n* “这个子模块被改动了”\n* 你必须提交 submodule 的新指针（不推荐）\n\n除非你非常熟悉 submodule 的机制，否则不要动主题代码。\n\n### ✔ 如果你想修改样式，推荐使用：\n\n```\nsource/_data/styles.styl\nsource/_data/override.styl\n```\n\n我可以告诉你如何正确添加额外 CSS。\n\n---\n\n# 🔧 如果你确实改了 submodule（例如主题配置文件）\n\n正常修改 `themes/butterfly/_config.yml` 是完全可以的，**它不属于 submodule 管理文件**，不会造成仓库指针变化。\n\n只有主题目录中包含在 submodule 仓库中的文件才会导致“submodule pointer changed”。\n\n---\n\n# 🎯 避免 submodule 冲突的小技巧\n\n在任何电脑上：\n\n```bash\ngit pull --recurse-submodules\ngit submodule update --remote\n```\n\n后者可以让主题自动跟随上游更新（如果你愿意自动更新）。","source":"_posts/writing_blog_on_multiple_PC.md","raw":"---\ntitle: 博客维护指南\ndate: 2018-01-05 00:00:00\nupdated: 2018-01-05 00:00:00\ntags:\n  - blog\ncategories:\n  - Misc\nexcerpt: 全部由GPT生成\nkeywords:\ndescription: 这是description\ntop_img:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\n---\n\n\n\n\n这是手动实现的摘要！\n\n<!--more-->\n\n\n我把 **最正确、最稳、不踩坑的双机维护方法** 给你整理一下，让你在两台电脑上随时写作、同步、预览、部署都没有问题。\n\n---\n\n# ✅ 总体结构\n\n你的博客现在结构如下：\n\n* **仓库 A：hexo-blog**\n  👉 存放 Hexo 源码、主题配置、文章等\n  👉 包含 `themes/butterfly` 的 Git submodule\n\n* **仓库 B：phlzy.github.io**\n  👉 GitHub Actions 自动部署结果（静态文件），无需手动维护\n\n你只需要在两台电脑上维护 **hexo-blog** 即可。\n\n---\n\n# 🧱 🔧 两台电脑如何初始化 hexo-blog（含 submodule）？\n\n## ① 克隆 hexo-blog 仓库（重点：带 submodule）\n\n不要直接 clone，需要加参数：\n\n```bash\ngit clone --recursive https://github.com/phlzy/hexo-blog.git\ncd hexo-blog\n```\n\n如果你忘记加 `--recursive`，也没关系，用下面的补救命令：\n\n```bash\ngit submodule update --init --recursive\n```\n\n这一步会把 Butterfly 主题的文件完整拉下来。\n\n---\n\n# 🧱 🔧 ② 安装依赖（两台电脑都需要执行一次）\n\n```bash\nnpm install\n```\n\nHexo、主题所需 renderer 插件都会自动安装。\n\n---\n\n# 🧱 🔧 ③ 本地预览\n\n```bash\nhexo clean\nhexo g\nhexo s\n```\n\n访问：\n\n```\nhttp://localhost:4000/\n```\n\n---\n\n# 🚀 双机写作同步流程（每天都用到）\n\n## ⭐ 在任意电脑开始工作前必须做：\n\n```bash\ngit pull --recurse-submodules\n```\n\n（`--recurse-submodules` 确保主题也同步）\n\n⚠ 如果你不写这个参数，有时候 submodule 不会自动更新。\n\n---\n\n## ⭐ 写完文章后推送：\n\n```bash\ngit add .\ngit commit -m \"Add new post\"\ngit push\n```\n\nGitHub Actions 会自动部署到 `phlzy.github.io`\n\n---\n\n# 🧠 如何确认 submodule 状态正常？\n\n每次切换电脑后，可以检查 submodule 指向的 commit 是否正确：\n\n```bash\ngit submodule status\n```\n\n如果正确，会显示主题仓库的 commit hash。\n\n---\n\n# 🧱 💡 你要特别注意的 **submodule 不要直接修改主题文件**！\n\n如果你编辑了 `themes/butterfly` 里的文件（例如 CSS、布局），Git 会认为：\n\n* “这个子模块被改动了”\n* 你必须提交 submodule 的新指针（不推荐）\n\n除非你非常熟悉 submodule 的机制，否则不要动主题代码。\n\n### ✔ 如果你想修改样式，推荐使用：\n\n```\nsource/_data/styles.styl\nsource/_data/override.styl\n```\n\n我可以告诉你如何正确添加额外 CSS。\n\n---\n\n# 🔧 如果你确实改了 submodule（例如主题配置文件）\n\n正常修改 `themes/butterfly/_config.yml` 是完全可以的，**它不属于 submodule 管理文件**，不会造成仓库指针变化。\n\n只有主题目录中包含在 submodule 仓库中的文件才会导致“submodule pointer changed”。\n\n---\n\n# 🎯 避免 submodule 冲突的小技巧\n\n在任何电脑上：\n\n```bash\ngit pull --recurse-submodules\ngit submodule update --remote\n```\n\n后者可以让主题自动跟随上游更新（如果你愿意自动更新）。","slug":"writing_blog_on_multiple_PC","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmir5cbxc00112cle0em682ed","content":"<p>这是手动实现的摘要！</p>\n<!--more-->\n\n\n<p>我把 <strong>最正确、最稳、不踩坑的双机维护方法</strong> 给你整理一下，让你在两台电脑上随时写作、同步、预览、部署都没有问题。</p>\n<hr>\n<h1 id=\"✅-总体结构\"><a href=\"#✅-总体结构\" class=\"headerlink\" title=\"✅ 总体结构\"></a>✅ 总体结构</h1><p>你的博客现在结构如下：</p>\n<ul>\n<li><p><strong>仓库 A：hexo-blog</strong><br>👉 存放 Hexo 源码、主题配置、文章等<br>👉 包含 <code>themes/butterfly</code> 的 Git submodule</p>\n</li>\n<li><p><strong>仓库 B：phlzy.github.io</strong><br>👉 GitHub Actions 自动部署结果（静态文件），无需手动维护</p>\n</li>\n</ul>\n<p>你只需要在两台电脑上维护 <strong>hexo-blog</strong> 即可。</p>\n<hr>\n<h1 id=\"🧱-🔧-两台电脑如何初始化-hexo-blog（含-submodule）？\"><a href=\"#🧱-🔧-两台电脑如何初始化-hexo-blog（含-submodule）？\" class=\"headerlink\" title=\"🧱 🔧 两台电脑如何初始化 hexo-blog（含 submodule）？\"></a>🧱 🔧 两台电脑如何初始化 hexo-blog（含 submodule）？</h1><h2 id=\"①-克隆-hexo-blog-仓库（重点：带-submodule）\"><a href=\"#①-克隆-hexo-blog-仓库（重点：带-submodule）\" class=\"headerlink\" title=\"① 克隆 hexo-blog 仓库（重点：带 submodule）\"></a>① 克隆 hexo-blog 仓库（重点：带 submodule）</h2><p>不要直接 clone，需要加参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive https://github.com/phlzy/hexo-blog.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> hexo-blog</span><br></pre></td></tr></table></figure>\n\n<p>如果你忘记加 <code>--recursive</code>，也没关系，用下面的补救命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>\n\n<p>这一步会把 Butterfly 主题的文件完整拉下来。</p>\n<hr>\n<h1 id=\"🧱-🔧-②-安装依赖（两台电脑都需要执行一次）\"><a href=\"#🧱-🔧-②-安装依赖（两台电脑都需要执行一次）\" class=\"headerlink\" title=\"🧱 🔧 ② 安装依赖（两台电脑都需要执行一次）\"></a>🧱 🔧 ② 安装依赖（两台电脑都需要执行一次）</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>Hexo、主题所需 renderer 插件都会自动安装。</p>\n<hr>\n<h1 id=\"🧱-🔧-③-本地预览\"><a href=\"#🧱-🔧-③-本地预览\" class=\"headerlink\" title=\"🧱 🔧 ③ 本地预览\"></a>🧱 🔧 ③ 本地预览</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n\n<p>访问：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:4000/</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"🚀-双机写作同步流程（每天都用到）\"><a href=\"#🚀-双机写作同步流程（每天都用到）\" class=\"headerlink\" title=\"🚀 双机写作同步流程（每天都用到）\"></a>🚀 双机写作同步流程（每天都用到）</h1><h2 id=\"⭐-在任意电脑开始工作前必须做：\"><a href=\"#⭐-在任意电脑开始工作前必须做：\" class=\"headerlink\" title=\"⭐ 在任意电脑开始工作前必须做：\"></a>⭐ 在任意电脑开始工作前必须做：</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --recurse-submodules</span><br></pre></td></tr></table></figure>\n\n<p>（<code>--recurse-submodules</code> 确保主题也同步）</p>\n<p>⚠ 如果你不写这个参数，有时候 submodule 不会自动更新。</p>\n<hr>\n<h2 id=\"⭐-写完文章后推送：\"><a href=\"#⭐-写完文章后推送：\" class=\"headerlink\" title=\"⭐ 写完文章后推送：\"></a>⭐ 写完文章后推送：</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;Add new post&quot;</span></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>GitHub Actions 会自动部署到 <code>phlzy.github.io</code></p>\n<hr>\n<h1 id=\"🧠-如何确认-submodule-状态正常？\"><a href=\"#🧠-如何确认-submodule-状态正常？\" class=\"headerlink\" title=\"🧠 如何确认 submodule 状态正常？\"></a>🧠 如何确认 submodule 状态正常？</h1><p>每次切换电脑后，可以检查 submodule 指向的 commit 是否正确：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule status</span><br></pre></td></tr></table></figure>\n\n<p>如果正确，会显示主题仓库的 commit hash。</p>\n<hr>\n<h1 id=\"🧱-💡-你要特别注意的-submodule-不要直接修改主题文件！\"><a href=\"#🧱-💡-你要特别注意的-submodule-不要直接修改主题文件！\" class=\"headerlink\" title=\"🧱 💡 你要特别注意的 submodule 不要直接修改主题文件！\"></a>🧱 💡 你要特别注意的 <strong>submodule 不要直接修改主题文件</strong>！</h1><p>如果你编辑了 <code>themes/butterfly</code> 里的文件（例如 CSS、布局），Git 会认为：</p>\n<ul>\n<li>“这个子模块被改动了”</li>\n<li>你必须提交 submodule 的新指针（不推荐）</li>\n</ul>\n<p>除非你非常熟悉 submodule 的机制，否则不要动主题代码。</p>\n<h3 id=\"✔-如果你想修改样式，推荐使用：\"><a href=\"#✔-如果你想修改样式，推荐使用：\" class=\"headerlink\" title=\"✔ 如果你想修改样式，推荐使用：\"></a>✔ 如果你想修改样式，推荐使用：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source/_data/styles.styl</span><br><span class=\"line\">source/_data/override.styl</span><br></pre></td></tr></table></figure>\n\n<p>我可以告诉你如何正确添加额外 CSS。</p>\n<hr>\n<h1 id=\"🔧-如果你确实改了-submodule（例如主题配置文件）\"><a href=\"#🔧-如果你确实改了-submodule（例如主题配置文件）\" class=\"headerlink\" title=\"🔧 如果你确实改了 submodule（例如主题配置文件）\"></a>🔧 如果你确实改了 submodule（例如主题配置文件）</h1><p>正常修改 <code>themes/butterfly/_config.yml</code> 是完全可以的，<strong>它不属于 submodule 管理文件</strong>，不会造成仓库指针变化。</p>\n<p>只有主题目录中包含在 submodule 仓库中的文件才会导致“submodule pointer changed”。</p>\n<hr>\n<h1 id=\"🎯-避免-submodule-冲突的小技巧\"><a href=\"#🎯-避免-submodule-冲突的小技巧\" class=\"headerlink\" title=\"🎯 避免 submodule 冲突的小技巧\"></a>🎯 避免 submodule 冲突的小技巧</h1><p>在任何电脑上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --recurse-submodules</span><br><span class=\"line\">git submodule update --remote</span><br></pre></td></tr></table></figure>\n\n<p>后者可以让主题自动跟随上游更新（如果你愿意自动更新）。</p>\n","more":"<p>这是手动实现的摘要！</p>\n<!--more-->\n\n\n<p>我把 <strong>最正确、最稳、不踩坑的双机维护方法</strong> 给你整理一下，让你在两台电脑上随时写作、同步、预览、部署都没有问题。</p>\n<hr>\n<h1 id=\"✅-总体结构\"><a href=\"#✅-总体结构\" class=\"headerlink\" title=\"✅ 总体结构\"></a>✅ 总体结构</h1><p>你的博客现在结构如下：</p>\n<ul>\n<li><p><strong>仓库 A：hexo-blog</strong><br>👉 存放 Hexo 源码、主题配置、文章等<br>👉 包含 <code>themes/butterfly</code> 的 Git submodule</p>\n</li>\n<li><p><strong>仓库 B：phlzy.github.io</strong><br>👉 GitHub Actions 自动部署结果（静态文件），无需手动维护</p>\n</li>\n</ul>\n<p>你只需要在两台电脑上维护 <strong>hexo-blog</strong> 即可。</p>\n<hr>\n<h1 id=\"🧱-🔧-两台电脑如何初始化-hexo-blog（含-submodule）？\"><a href=\"#🧱-🔧-两台电脑如何初始化-hexo-blog（含-submodule）？\" class=\"headerlink\" title=\"🧱 🔧 两台电脑如何初始化 hexo-blog（含 submodule）？\"></a>🧱 🔧 两台电脑如何初始化 hexo-blog（含 submodule）？</h1><h2 id=\"①-克隆-hexo-blog-仓库（重点：带-submodule）\"><a href=\"#①-克隆-hexo-blog-仓库（重点：带-submodule）\" class=\"headerlink\" title=\"① 克隆 hexo-blog 仓库（重点：带 submodule）\"></a>① 克隆 hexo-blog 仓库（重点：带 submodule）</h2><p>不要直接 clone，需要加参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> --recursive https://github.com/phlzy/hexo-blog.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> hexo-blog</span><br></pre></td></tr></table></figure>\n\n<p>如果你忘记加 <code>--recursive</code>，也没关系，用下面的补救命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>\n\n<p>这一步会把 Butterfly 主题的文件完整拉下来。</p>\n<hr>\n<h1 id=\"🧱-🔧-②-安装依赖（两台电脑都需要执行一次）\"><a href=\"#🧱-🔧-②-安装依赖（两台电脑都需要执行一次）\" class=\"headerlink\" title=\"🧱 🔧 ② 安装依赖（两台电脑都需要执行一次）\"></a>🧱 🔧 ② 安装依赖（两台电脑都需要执行一次）</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>Hexo、主题所需 renderer 插件都会自动安装。</p>\n<hr>\n<h1 id=\"🧱-🔧-③-本地预览\"><a href=\"#🧱-🔧-③-本地预览\" class=\"headerlink\" title=\"🧱 🔧 ③ 本地预览\"></a>🧱 🔧 ③ 本地预览</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n\n<p>访问：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:4000/</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"🚀-双机写作同步流程（每天都用到）\"><a href=\"#🚀-双机写作同步流程（每天都用到）\" class=\"headerlink\" title=\"🚀 双机写作同步流程（每天都用到）\"></a>🚀 双机写作同步流程（每天都用到）</h1><h2 id=\"⭐-在任意电脑开始工作前必须做：\"><a href=\"#⭐-在任意电脑开始工作前必须做：\" class=\"headerlink\" title=\"⭐ 在任意电脑开始工作前必须做：\"></a>⭐ 在任意电脑开始工作前必须做：</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --recurse-submodules</span><br></pre></td></tr></table></figure>\n\n<p>（<code>--recurse-submodules</code> 确保主题也同步）</p>\n<p>⚠ 如果你不写这个参数，有时候 submodule 不会自动更新。</p>\n<hr>\n<h2 id=\"⭐-写完文章后推送：\"><a href=\"#⭐-写完文章后推送：\" class=\"headerlink\" title=\"⭐ 写完文章后推送：\"></a>⭐ 写完文章后推送：</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;Add new post&quot;</span></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>GitHub Actions 会自动部署到 <code>phlzy.github.io</code></p>\n<hr>\n<h1 id=\"🧠-如何确认-submodule-状态正常？\"><a href=\"#🧠-如何确认-submodule-状态正常？\" class=\"headerlink\" title=\"🧠 如何确认 submodule 状态正常？\"></a>🧠 如何确认 submodule 状态正常？</h1><p>每次切换电脑后，可以检查 submodule 指向的 commit 是否正确：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule status</span><br></pre></td></tr></table></figure>\n\n<p>如果正确，会显示主题仓库的 commit hash。</p>\n<hr>\n<h1 id=\"🧱-💡-你要特别注意的-submodule-不要直接修改主题文件！\"><a href=\"#🧱-💡-你要特别注意的-submodule-不要直接修改主题文件！\" class=\"headerlink\" title=\"🧱 💡 你要特别注意的 submodule 不要直接修改主题文件！\"></a>🧱 💡 你要特别注意的 <strong>submodule 不要直接修改主题文件</strong>！</h1><p>如果你编辑了 <code>themes/butterfly</code> 里的文件（例如 CSS、布局），Git 会认为：</p>\n<ul>\n<li>“这个子模块被改动了”</li>\n<li>你必须提交 submodule 的新指针（不推荐）</li>\n</ul>\n<p>除非你非常熟悉 submodule 的机制，否则不要动主题代码。</p>\n<h3 id=\"✔-如果你想修改样式，推荐使用：\"><a href=\"#✔-如果你想修改样式，推荐使用：\" class=\"headerlink\" title=\"✔ 如果你想修改样式，推荐使用：\"></a>✔ 如果你想修改样式，推荐使用：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source/_data/styles.styl</span><br><span class=\"line\">source/_data/override.styl</span><br></pre></td></tr></table></figure>\n\n<p>我可以告诉你如何正确添加额外 CSS。</p>\n<hr>\n<h1 id=\"🔧-如果你确实改了-submodule（例如主题配置文件）\"><a href=\"#🔧-如果你确实改了-submodule（例如主题配置文件）\" class=\"headerlink\" title=\"🔧 如果你确实改了 submodule（例如主题配置文件）\"></a>🔧 如果你确实改了 submodule（例如主题配置文件）</h1><p>正常修改 <code>themes/butterfly/_config.yml</code> 是完全可以的，<strong>它不属于 submodule 管理文件</strong>，不会造成仓库指针变化。</p>\n<p>只有主题目录中包含在 submodule 仓库中的文件才会导致“submodule pointer changed”。</p>\n<hr>\n<h1 id=\"🎯-避免-submodule-冲突的小技巧\"><a href=\"#🎯-避免-submodule-冲突的小技巧\" class=\"headerlink\" title=\"🎯 避免 submodule 冲突的小技巧\"></a>🎯 避免 submodule 冲突的小技巧</h1><p>在任何电脑上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --recurse-submodules</span><br><span class=\"line\">git submodule update --remote</span><br></pre></td></tr></table></figure>\n\n<p>后者可以让主题自动跟随上游更新（如果你愿意自动更新）。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmir5cbx200012clehhvb9q1s","category_id":"cmir5cbx500042cle13u083gn","_id":"cmir5cbx8000e2cleb44u2ncq"},{"post_id":"cmir5cbx400032cle30rzhlpf","category_id":"cmir5cbx700092cle70gd5sxs","_id":"cmir5cbx9000k2cle3f6jbhex"},{"post_id":"cmir5cbx600062cle080kfzdd","category_id":"cmir5cbx8000f2cle5rixfiot","_id":"cmir5cbxb000r2cleb05d69gb"},{"post_id":"cmir5cbx600072cleffaz24zu","category_id":"cmir5cbx8000f2cle5rixfiot","_id":"cmir5cbxc000x2cleet39bjrh"},{"post_id":"cmir5cbxb000t2cle4fzcfq7s","category_id":"cmir5cbx700092cle70gd5sxs","_id":"cmir5cbxc00122cle8ibrb2wq"},{"post_id":"cmir5cbx700082clehg2e7hbh","category_id":"cmir5cbx700092cle70gd5sxs","_id":"cmir5cbxd00142clefunfgelw"},{"post_id":"cmir5cbx8000c2cleg5kagkqt","category_id":"cmir5cbxc000w2cled0t44xj3","_id":"cmir5cbxd00182cle72xhfag1"},{"post_id":"cmir5cbx8000d2cle1nrd9zzo","category_id":"cmir5cbx8000f2cle5rixfiot","_id":"cmir5cbxd001b2cle0dwte3td"},{"post_id":"cmir5cbx9000h2cleepyz3gik","category_id":"cmir5cbxd00172cle0o0e9fkp","_id":"cmir5cbxe001g2cle7als5rw9"},{"post_id":"cmir5cbx9000j2cle91tpg8jm","category_id":"cmir5cbxc000w2cled0t44xj3","_id":"cmir5cbxe001j2cleb7twf2i3"},{"post_id":"cmir5cbxa000n2clehybodb22","category_id":"cmir5cbxe001f2cle6ahx6oc9","_id":"cmir5cbxe001o2cleb39q30mu"},{"post_id":"cmir5cbxa000p2cle41q41j63","category_id":"cmir5cbxc000w2cled0t44xj3","_id":"cmir5cbxf001r2cle8z26032i"},{"post_id":"cmir5cbxb000v2clefrpl4tbr","category_id":"cmir5cbxe001n2cle0zhb332y","_id":"cmir5cbxf001v2cle709walym"},{"post_id":"cmir5cbxc000y2cle5l5t5bsu","category_id":"cmir5cbxf001s2cle91ov93fz","_id":"cmir5cbxf001z2cleakay4yoa"},{"post_id":"cmir5cbxc00112cle0em682ed","category_id":"cmir5cbxf001w2cle9q73fs9j","_id":"cmir5cbxf00222clegfdec7t2"}],"PostTag":[{"post_id":"cmir5cbx200012clehhvb9q1s","tag_id":"cmir5cbx600052cleg3i7fmmf","_id":"cmir5cbx7000b2clef5tf8k9e"},{"post_id":"cmir5cbx400032cle30rzhlpf","tag_id":"cmir5cbx7000a2cleem7o7vc1","_id":"cmir5cbx9000i2cle0je03voh"},{"post_id":"cmir5cbx600062cle080kfzdd","tag_id":"cmir5cbx9000g2cle55mqfbea","_id":"cmir5cbxa000o2cle7jnfcfr5"},{"post_id":"cmir5cbx600072cleffaz24zu","tag_id":"cmir5cbx9000m2cleagp24ax4","_id":"cmir5cbxb000u2cle4o4s2qck"},{"post_id":"cmir5cbx700082clehg2e7hbh","tag_id":"cmir5cbxb000s2cle2rvu6cpe","_id":"cmir5cbxc00102cle4re4164g"},{"post_id":"cmir5cbx8000c2cleg5kagkqt","tag_id":"cmir5cbxc000z2cle91frfb2t","_id":"cmir5cbxd00162cle21rf6kn9"},{"post_id":"cmir5cbx8000d2cle1nrd9zzo","tag_id":"cmir5cbx9000m2cleagp24ax4","_id":"cmir5cbxd001a2clehsi109u3"},{"post_id":"cmir5cbx9000h2cleepyz3gik","tag_id":"cmir5cbxd00192clea3lv1h53","_id":"cmir5cbxd001e2cleckuiaua8"},{"post_id":"cmir5cbx9000j2cle91tpg8jm","tag_id":"cmir5cbxc000z2cle91frfb2t","_id":"cmir5cbxe001i2cleg41k19rk"},{"post_id":"cmir5cbxa000n2clehybodb22","tag_id":"cmir5cbxe001h2clegcux35ed","_id":"cmir5cbxe001m2cle0a2kcx2p"},{"post_id":"cmir5cbxa000p2cle41q41j63","tag_id":"cmir5cbxc000z2cle91frfb2t","_id":"cmir5cbxe001q2clef5cc8ogl"},{"post_id":"cmir5cbxb000t2cle4fzcfq7s","tag_id":"cmir5cbxb000s2cle2rvu6cpe","_id":"cmir5cbxf001u2clegj6ye2hg"},{"post_id":"cmir5cbxb000v2clefrpl4tbr","tag_id":"cmir5cbxf001t2clec0ish0sg","_id":"cmir5cbxf001y2clean71c2cd"},{"post_id":"cmir5cbxc000y2cle5l5t5bsu","tag_id":"cmir5cbxf001x2cleeo5i7ait","_id":"cmir5cbxf00212cle1jrodyz2"},{"post_id":"cmir5cbxc00112cle0em682ed","tag_id":"cmir5cbxf00202cle5fwadzzg","_id":"cmir5cbxf00232cle8qvwak8n"}],"Tag":[{"name":"math","_id":"cmir5cbx600052cleg3i7fmmf"},{"name":"data structure","_id":"cmir5cbx7000a2cleem7o7vc1"},{"name":"contest","_id":"cmir5cbx9000g2cle55mqfbea"},{"name":"XCPC","_id":"cmir5cbx9000m2cleagp24ax4"},{"name":"algorithm","_id":"cmir5cbxb000s2cle2rvu6cpe"},{"name":"linear algebra","_id":"cmir5cbxc000z2cle91frfb2t"},{"name":"Convex Optimization","_id":"cmir5cbxd00192clea3lv1h53"},{"name":"manacher","_id":"cmir5cbxe001h2clegcux35ed"},{"name":"GF","_id":"cmir5cbxf001t2clec0ish0sg"},{"name":"ubuntu","_id":"cmir5cbxf001x2cleeo5i7ait"},{"name":"blog","_id":"cmir5cbxf00202cle5fwadzzg"}]}}