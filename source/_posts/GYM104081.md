---
title: GYM104081
date: 2023-05-02
tag: [XCPC]
category: [Competitive Programming]
math: true
---

[2022年中国大学生程序设计竞赛女生专场](https://codeforces.com/gym/104081)

# 签到题和 L 题

过了 ACEGHL。别的都比较简单，L 稍微说两句。

L 如果不考虑距离限制就无脑启发式合并。有了距离限制之后就需要在启发式合并的时候额外维护需要删去的点的集合，这个如果没想清楚可能会导致实现起来很麻烦。注意 DFS 经过树上节点的顺序，可以发现只需要将相同深度的点放在一起，每次删的时候只会删同一深度的点，就容易实现了。

``` cpp
#include <bits/stdc++.h>
using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;
using ll = long long;
using uint = unsigned int;
using ull = unsigned long long;
using pii = std::pair<int, int>;
const int inf = 0x3f3f3f3f;
const int maxn = 1e5 + 5;
const double pi = acos(-1);

vector<int> g[maxn];
int color[maxn];
int K;
int dep[maxn], sz[maxn], big[maxn];
std::map<int, int> node[maxn];
int ans[maxn];
vector<int> vis[maxn];

void dfs0(int u, int f) {
    dep[u] = dep[f] + 1;
    sz[u] = 1;
    for (auto v : g[u]) {
        if (v == f) continue;
        dfs0(v, u);
        sz[u] += sz[v];
        if (sz[v] > sz[big[u]])
            big[u] = v;
    }
}

void dfs(int u, int f) {
    vis[dep[u]].push_back(u);
    if (sz[u] == 1) {
        node[u][color[u]] = 1;
        ans[u] = 1;
        return;
    }
    dfs(big[u], u);
    node[u].swap(node[big[u]]);
    node[u][color[u]]++;
    for (auto v : g[u]) {
        if (v == big[u] || v == f)
            continue;
        dfs(v, u);
        for (auto& [col, cnt] : node[v]) {
            node[u][col] += cnt;
        }
    }
    for (auto v : vis[dep[u] + K + 1]) {
        node[u][color[v]]--;
        if (node[u][color[v]] == 0) {
            node[u].erase(color[v]);
        }
    }
    vis[dep[u] + K + 1].clear();
    ans[u] = node[u].size();
}

void solve() {
    int n;
    cin >> n >> K;
    for (int i = 1; i <= n; ++i) {
        cin >> color[i];
    }
    for (int i = 1, u, v; i < n; ++i) {
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs0(1, 0);
    dfs(1, 0);
    int q;
    cin >> q;
    while (q--) {
        int x;
        cin >> x;
        cout << ans[x] << '\n';
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T = 1;
    // cin >> T;
    for (int t = 1; t <= T; ++t) {
        solve();
    }
    return 0;
}
```

下面是补题。试着补一下 BFIJK，D 太恶心了就不管了。

# I

当时也想过 dp，但是没完全想清楚。

令 $dp[i][0/1]$ 表示长度为 $i$ 的前缀用两种字符串交替表达的最小次数。然后对于每个起点 $i$，枚举所有终点 $j$，如果 $s[i\cdots j]$ 是一个存在的串，就去更新 $dp[j][0/1]$。事先只要用字典树维护一下那些串就好了，dp 的过程是 $O(n^2)$ 的。

``` cpp
#include <bits/stdc++.h>
using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;
using ll = long long;
using uint = unsigned int;
using ull = unsigned long long;
using pii = std::pair<int, int>;
const int inf = 0x3f3f3f3f;
const int maxn = 1e5 + 5;

struct Trie {
    static constexpr int ALPHABET = 26;
    struct Node {
        bool end;
        std::array<int, ALPHABET> next;
        Node(): end{}, next{} {}
    };

    std::vector<Node> trie;

    Trie() {
        init();
    }

    void init() {
        trie.assign(1, Node());
    }

    int newNode() {
        trie.emplace_back();
        return trie.size() - 1;
    }

    int insert(const vector<int>& a) {
        int cur = 0;
        for (auto& x : a) {
            if (trie[cur].next[x] == 0) {
                trie[cur].next[x] = newNode();
            }
            cur = trie[cur].next[x];
        }
        trie[cur].end = true;
        return cur;
    }

    int insert(const string& s, char offset = 'a') {
        vector<int> a(s.size());
        for (size_t i = 0; i < s.size(); ++i) {
            a[i] = s[i] - offset;
        }
        return insert(a);
    }

    int next(int p, int x) {
        return trie[p].next[x];
    }

    int next(int p, char c, char offset = 'a') {
        return next(p, c - 'a');
    }

    bool end(int p) {
        return trie[p].end;
    }

    int size() {
        return trie.size();
    }
};

void solve() {
    int n, m;
    cin >> n;
    Trie a, b;
    for (int i = 1; i <= n; ++i) {
        string s;
        cin >> s;
        a.insert(s);
    }
    cin >> m;
    for (int i = 1; i <= m; ++i) {
        string s;
        cin >> s;
        b.insert(s);
    }
    string s;
    cin >> s;
    int len = s.length();
    vector<int> dp1(len + 1, inf), dp2(len + 1, inf);
    dp1[0] = dp2[0] = 0;
    for (int i = 1; i <= len; ++i) {
        int pos = 0;
        for (int j = i; j <= len; ++j) {
            pos = a.next(pos, s[j - 1]);
            if (pos == 0)
                break;
            if (a.end(pos))
                dp1[j] = std::min(dp1[j], dp2[i - 1] + 1);
        }
        pos = 0;
        for (int j = i; j <= len; ++j) {
            pos = b.next(pos, s[j - 1]);
            if (pos == 0)
                break;
            if (b.end(pos))
                dp2[j] = std::min(dp2[j], dp1[i - 1] + 1);
        }
    }
    int ans = std::min(dp1[len], dp2[len]);
    cout << (ans == inf ? -1 : ans) << endl;
}

int main() {
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T = 1;
    // cin >> T;
    for (int trie = 1; trie <= T; ++trie) {
        solve();
    }
    return 0;
}
```

# F

首先要把九个数分成三组，每一组是由两个数经过三种运算得到的。

注意到 $(A| B)\oplus(A\&B)=A\oplus B$，确定了其中两个就可以算出第三个。

确定分组后，由于 $(A| B)+(A\&B)=A+B$，可以推出每个数的值。

因此可以直接搜索，就是有点麻烦。

题解给出了另一种做法：

随机化，第一个数固定放第一组，然后随机取一个，就可以确定第一组。第一组的成功率是 $\frac{2}{8}$。同样的方法取第二组，成功率是 $\frac{2}{5}$，总成功率就是 $\frac{1}{10}$。

然后考虑分完组之后，最大的肯定是 $A|B$，$A\&B$ 可以进一步通过随机去找，那么总的成功率就是 $\frac{1}{80}$。

这个做法感觉比搜索好写，并且写起来挺有趣的。

``` cpp
#include <bits/stdc++.h>
using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::string;
using ll = long long;
using uint = unsigned int;
using ull = unsigned long long;
using pii = std::pair<int, int>;
const int inf = 0x3f3f3f3f;
const int maxn = 1e5 + 5;

std::random_device rd;
std::mt19937 rng(rd());

void solve() {
    vector<ll> a(9);
    for (ll& i : a)
        cin >> i;
    for (int it = 1; it <= 2000; ++it) {
        std::shuffle(a.begin() + 1, a.end(), rng);
        ll x1 = (a[0] ^ a[1]);
        int id1 = 2;
        for (; id1 < 9; ++id1) {
            if (a[id1] == x1) 
                break;
        }
        if (id1 == 9)
            continue;
        std::swap(a[2], a[id1]);
        ll x2 = (a[3] ^ a[4]);
        int id2 = 5;
        for (; id2 < 9; ++id2) {
            if (a[id2] == x2) 
                break;
        }
        if (id2 == 9)
            continue;
        std::swap(a[5], a[id2]);
        if ((a[6] ^ a[7]) != a[8])
            continue;
        for (int i = 0; i < 9; i += 3) {
            for (int j = 1; j <= 2; ++j) {
                if (a[i] < a[i + j])
                    std::swap(a[i], a[i + j]);
            }
        }
        ll AB = a[0] + a[1];
        ll BC = a[3] + a[4];
        ll AC = a[6] + a[7];
        ll sum = AB + AC + BC;
        if (sum & 1)
            continue;
        sum /= 2;
        ll A = sum - BC, B = sum - AC, C = sum - AB;
        if ((A | B) != a[0] || (A & B) != a[1])
            continue;
        if ((B | C) != a[3] || (B & C) != a[4])
            continue;
        if ((A | C) != a[6] || (A & C) != a[7])
            continue;
        cout << A << " " << B << " " << C << '\n';
        break;
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T = 1;
    cin >> T;
    for (int t = 1; t <= T; ++t) {
        solve();
    }
    return 0;
}
```

# B

肯定想着虚树那一套方法，考虑用 set 维护前驱后继，然后可以发现除了最外面的一圈以外，其他数都是被覆盖过两次，根一次都没有，所以加上最外面一圈再除以二加上根即可。时间复杂度 。

# J

# K

区间和容易写成差分，二分答案后，就只是要判断  多少个小于 。发现值域很小，直接fft即可。注意到每个数都大于等于 ，所以负的都无用， 可以提前预处理。时间复杂度 。